{
  "version": 3,
  "sources": ["../../node_modules/mithril/render/vnode.js", "../../node_modules/mithril/render/hyperscriptVnode.js", "../../node_modules/mithril/util/hasOwn.js", "../../node_modules/mithril/render/emptyAttrs.js", "../../node_modules/mithril/render/cachedAttrsIsStaticMap.js", "../../node_modules/mithril/render/hyperscript.js", "../../node_modules/mithril/render/trust.js", "../../node_modules/mithril/render/fragment.js", "../../node_modules/mithril/hyperscript.js", "../../node_modules/mithril/render/delayedRemoval.js", "../../node_modules/mithril/render/domFor.js", "../../node_modules/mithril/render/render.js", "../../node_modules/mithril/render.js", "../../node_modules/mithril/api/mount-redraw.js", "../../node_modules/mithril/mount-redraw.js", "../../node_modules/mithril/querystring/build.js", "../../node_modules/mithril/pathname/build.js", "../../node_modules/mithril/request/request.js", "../../node_modules/mithril/request.js", "../../node_modules/mithril/util/decodeURIComponentSafe.js", "../../node_modules/mithril/querystring/parse.js", "../../node_modules/mithril/pathname/parse.js", "../../node_modules/mithril/pathname/compileTemplate.js", "../../node_modules/mithril/util/censor.js", "../../node_modules/mithril/api/router.js", "../../node_modules/mithril/route.js", "../../node_modules/mithril/index.js", "../../ts/index.ts", "../../ts/app.ts", "../../ts/components/header.ts", "../../ts/commons/events.ts", "../../ts/services/dark-mode.ts", "../../node_modules/.deno/@rgrannell1+tribbledb@0.0.31/node_modules/@rgrannell1/tribbledb/dist/mod.js", "../../ts/semantic/data.ts", "../../ts/constants.ts", "../../ts/semantic/derive.ts", "../../ts/commons/logger.ts", "../../node_modules/valibot/dist/index.mjs", "../../ts/commons/things.ts", "../../ts/components/thing-link.ts", "../../ts/commons/arrays.ts", "../../ts/services/emoji.ts", "../../ts/commons/parser.ts", "../../ts/schemas.ts", "../../ts/services/parsers.ts", "../../ts/services/readers.ts", "../../ts/services/photos.ts", "../../ts/services/albums.ts", "../../ts/services/names.ts", "../../ts/state.ts", "../../ts/components/sidebar.ts", "../../ts/pages/albums.ts", "../../ts/components/album-stats.ts", "../../ts/components/photo-album-metadata.ts", "../../ts/services/window.ts", "../../ts/components/photo-album.ts", "../../ts/components/photo.ts", "../../ts/components/metadata-icon.ts", "../../ts/components/place-links.ts", "../../ts/models/urn.ts", "../../ts/commons/sets.ts", "../../ts/pages/about.ts", "../../ts/pages/videos.ts", "../../ts/components/video.ts", "../../ts/services/videos.ts", "../../ts/pages/album.ts", "../../ts/services/dates.ts", "../../ts/components/album-share-button.ts", "../../ts/components/albums-button.ts", "../../ts/commons/strings.ts", "../../ts/pages/photos.ts", "../../ts/pages/photo.ts", "../../ts/components/album-button.ts", "../../ts/components/exif-data.ts", "../../ts/components/photo-info.ts", "../../ts/pages/listing.ts", "../../ts/components/thing-metadata.ts", "../../ts/components/thing-urls.ts", "../../ts/components/external-link.ts", "../../ts/pages/listings.ts", "../../ts/pages/thing.ts", "../../ts/components/thing-title.ts", "../../ts/components/places-list.ts", "../../ts/components/listing-link.ts", "../../ts/components/features-list.ts", "../../ts/components/feature-link.ts", "../../ts/components/unesco-list.ts", "../../ts/components/unesco-link.ts"],
  "sourcesContent": ["\"use strict\"\n\nfunction Vnode(tag, key, attrs, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, is: undefined, domSize: undefined, state: undefined, events: undefined, instance: undefined}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node == null || typeof node === \"boolean\") return null\n\tif (typeof node === \"object\") return node\n\treturn Vnode(\"#\", undefined, undefined, String(node), undefined, undefined)\n}\nVnode.normalizeChildren = function(input) {\n\t// Preallocate the array length (initially holey) and fill every index immediately in order.\n\t// Benchmarking shows better performance on V8.\n\tvar children = new Array(input.length)\n\t// Count the number of keyed normalized vnodes for consistency check.\n\t// Note: this is a perf-sensitive check.\n\t// Fun fact: merging the loop like this is somehow faster than splitting\n\t// the check within updateNodes(), noticeably so.\n\tvar numKeyed = 0\n\tfor (var i = 0; i < input.length; i++) {\n\t\tchildren[i] = Vnode.normalize(input[i])\n\t\tif (children[i] !== null && children[i].key != null) numKeyed++\n\t}\n\tif (numKeyed !== 0 && numKeyed !== input.length) {\n\t\tthrow new TypeError(children.includes(null)\n\t\t\t? \"In fragments, vnodes must either all have keys or none have keys. You may wish to consider using an explicit keyed empty fragment, m.fragment({key: ...}), instead of a hole.\"\n\t\t\t: \"In fragments, vnodes must either all have keys or none have keys.\"\n\t\t)\n\t}\n\treturn children\n}\n\nmodule.exports = Vnode\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\n\n// Note: the processing of variadic parameters is perf-sensitive.\n//\n// In native ES6, it might be preferable to define hyperscript and fragment\n// factories with a final ...args parameter and call hyperscriptVnode(...args),\n// since modern engines can optimize spread calls.\n//\n// However, benchmarks showed this was not faster. As a result, spread is used\n// only in the parameter lists of hyperscript and fragment, while an array is\n// passed to hyperscriptVnode.\nmodule.exports = function(attrs, children) {\n\tif (attrs == null || typeof attrs === \"object\" && attrs.tag == null && !Array.isArray(attrs)) {\n\t\tif (children.length === 1 && Array.isArray(children[0])) children = children[0]\n\t} else {\n\t\tchildren = children.length === 0 && Array.isArray(attrs) ? attrs : [attrs, ...children]\n\t\tattrs = undefined\n\t}\n\n\treturn Vnode(\"\", attrs && attrs.key, attrs, children)\n}\n", "// This exists so I'm only saving it once.\n\"use strict\"\n\nmodule.exports = {}.hasOwnProperty\n", "\"use strict\"\n\n// This is an attrs object that is used by default when attrs is undefined or null.\nmodule.exports = {}\n", "\"use strict\"\n\nvar emptyAttrs = require(\"./emptyAttrs\")\n\n// This Map manages the following:\n// - Whether an attrs is cached attrs generated by compileSelector().\n// - Whether the cached attrs is \"static\", i.e., does not contain any form attributes.\n// These information will be useful to skip updating attrs in render().\n//\n// Since the attrs used as keys in this map are not released from the selectorCache object,\n// there is no risk of memory leaks. Therefore, Map is used here instead of WeakMap.\nmodule.exports = new Map([[emptyAttrs, true]])\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\nvar hyperscriptVnode = require(\"./hyperscriptVnode\")\nvar hasOwn = require(\"../util/hasOwn\")\nvar emptyAttrs = require(\"./emptyAttrs\")\nvar cachedAttrsIsStaticMap = require(\"./cachedAttrsIsStaticMap\")\n\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = Object.create(null)\n\nfunction isEmpty(object) {\n\tfor (var key in object) if (hasOwn.call(object, key)) return false\n\treturn true\n}\n\nfunction isFormAttributeKey(key) {\n\treturn key === \"value\" || key === \"checked\" || key === \"selectedIndex\" || key === \"selected\"\n}\n\nfunction compileSelector(selector) {\n\tvar match, tag = \"div\", classes = [], attrs = {}, isStatic = true\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") tag = value\n\t\telse if (type === \"#\") attrs.id = value\n\t\telse if (type === \".\") classes.push(value)\n\t\telse if (match[3][0] === \"[\") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\")\n\t\t\tif (match[4] === \"class\") classes.push(attrValue)\n\t\t\telse {\n\t\t\t\tattrs[match[4]] = attrValue === \"\" ? attrValue : attrValue || true\n\t\t\t\tif (isFormAttributeKey(match[4])) isStatic = false\n\t\t\t}\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(\" \")\n\tif (isEmpty(attrs)) attrs = emptyAttrs\n\telse cachedAttrsIsStaticMap.set(attrs, isStatic)\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs, is: attrs.is}\n}\n\nfunction execSelector(state, vnode) {\n\tvnode.tag = state.tag\n\n\tvar attrs = vnode.attrs\n\tif (attrs == null) {\n\t\tvnode.attrs = state.attrs\n\t\tvnode.is = state.is\n\t\treturn vnode\n\t}\n\n\tif (hasOwn.call(attrs, \"class\")) {\n\t\tif (attrs.class != null) attrs.className = attrs.class\n\t\tattrs.class = null\n\t}\n\n\tif (state.attrs !== emptyAttrs) {\n\t\tvar className = attrs.className\n\t\tattrs = Object.assign({}, state.attrs, attrs)\n\n\t\tif (state.attrs.className != null) attrs.className =\n\t\t\tclassName != null\n\t\t\t\t? String(state.attrs.className) + \" \" + String(className)\n\t\t\t\t: state.attrs.className\n\t}\n\n\t// workaround for #2622 (reorder keys in attrs to set \"type\" first)\n\t// The DOM does things to inputs based on the \"type\", so it needs set first.\n\t// See: https://github.com/MithrilJS/mithril.js/issues/2622\n\tif (state.tag === \"input\" && hasOwn.call(attrs, \"type\")) {\n\t\tattrs = Object.assign({type: attrs.type}, attrs)\n\t}\n\n\t// This reduces the complexity of the evaluation of \"is\" within the render function.\n\tvnode.is = attrs.is\n\n\tvnode.attrs = attrs\n\n\treturn vnode\n}\n\nfunction hyperscript(selector, attrs, ...children) {\n\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t}\n\n\tvar vnode = hyperscriptVnode(attrs, children)\n\n\tif (typeof selector === \"string\") {\n\t\tvnode.children = Vnode.normalizeChildren(vnode.children)\n\t\tif (selector !== \"[\") return execSelector(selectorCache[selector] || compileSelector(selector), vnode)\n\t}\n\n\tif (vnode.attrs == null) vnode.attrs = {}\n\tvnode.tag = selector\n\treturn vnode\n}\n\nmodule.exports = hyperscript\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\n\nmodule.exports = function(html) {\n\tif (html == null) html = \"\"\n\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined)\n}\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\nvar hyperscriptVnode = require(\"./hyperscriptVnode\")\n\nmodule.exports = function(attrs, ...children) {\n\tvar vnode = hyperscriptVnode(attrs, children)\n\n\tif (vnode.attrs == null) vnode.attrs = {}\n\tvnode.tag = \"[\"\n\tvnode.children = Vnode.normalizeChildren(vnode.children)\n\treturn vnode\n}\n", "\"use strict\"\n\nvar hyperscript = require(\"./render/hyperscript\")\n\nhyperscript.trust = require(\"./render/trust\")\nhyperscript.fragment = require(\"./render/fragment\")\n\nmodule.exports = hyperscript\n", "\"use strict\"\n\nmodule.exports = new WeakMap\n", "\"use strict\"\n\nvar delayedRemoval = require(\"./delayedRemoval\")\n\nfunction *domFor(vnode) {\n\t// To avoid unintended mangling of the internal bundler,\n\t// parameter destructuring is not used here.\n\tvar dom = vnode.dom\n\tvar domSize = vnode.domSize\n\tvar generation = delayedRemoval.get(dom)\n\tif (dom != null) do {\n\t\tvar nextSibling = dom.nextSibling\n\n\t\tif (delayedRemoval.get(dom) === generation) {\n\t\t\tyield dom\n\t\t\tdomSize--\n\t\t}\n\n\t\tdom = nextSibling\n\t}\n\twhile (domSize)\n}\n\nmodule.exports = domFor\n", "\"use strict\"\n\nvar Vnode = require(\"./vnode\")\nvar delayedRemoval = require(\"./delayedRemoval\")\nvar domFor = require(\"./domFor\")\nvar cachedAttrsIsStaticMap = require(\"./cachedAttrsIsStaticMap\")\n\nmodule.exports = function() {\n\tvar nameSpace = {\n\t\tsvg: \"http://www.w3.org/2000/svg\",\n\t\tmath: \"http://www.w3.org/1998/Math/MathML\"\n\t}\n\n\tvar currentRedraw\n\tvar currentRender\n\n\tfunction getDocument(dom) {\n\t\treturn dom.ownerDocument;\n\t}\n\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\n\t//sanity check to discourage people from doing `vnode.state = ...`\n\tfunction checkState(vnode, original) {\n\t\tif (vnode.state !== original) throw new Error(\"'vnode.state' must not be modified.\")\n\t}\n\n\t//Note: the hook is passed as the `this` argument to allow proxying the\n\t//arguments without requiring a full array allocation to do so. It also\n\t//takes advantage of the fact the current `vnode` is the first argument in\n\t//all lifecycle methods.\n\tfunction callHook(vnode) {\n\t\tvar original = vnode.state\n\t\ttry {\n\t\t\treturn this.apply(original, arguments)\n\t\t} finally {\n\t\t\tcheckState(vnode, original)\n\t\t}\n\t}\n\n\t// IE11 (at least) throws an UnspecifiedError when accessing document.activeElement when\n\t// inside an iframe. Catch and swallow this error, and heavy-handidly return null.\n\tfunction activeElement(dom) {\n\t\ttry {\n\t\t\treturn getDocument(dom).activeElement\n\t\t} catch (e) {\n\t\t\treturn null\n\t\t}\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === \"string\") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase \"#\": createText(parent, vnode, nextSibling); break\n\t\t\t\tcase \"<\": createHTML(parent, vnode, ns, nextSibling); break\n\t\t\t\tcase \"[\": createFragment(parent, vnode, hooks, ns, nextSibling); break\n\t\t\t\tdefault: createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = getDocument(parent).createTextNode(vnode.children)\n\t\tinsertDOM(parent, vnode.dom, nextSibling)\n\t}\n\tvar possibleParents = {caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\"}\n\tfunction createHTML(parent, vnode, ns, nextSibling) {\n\t\tvar match = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\t// not using the proper parent makes the child element(s) vanish.\n\t\t//     var div = document.createElement(\"div\")\n\t\t//     div.innerHTML = \"<td>i</td><td>j</td>\"\n\t\t//     console.log(div.innerHTML)\n\t\t// --> \"ij\", no <td> in sight.\n\t\tvar temp = getDocument(parent).createElement(possibleParents[match[1]] || \"div\")\n\t\tif (ns === \"http://www.w3.org/2000/svg\") {\n\t\t\ttemp.innerHTML = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\">\" + vnode.children + \"</svg>\"\n\t\t\ttemp = temp.firstChild\n\t\t} else {\n\t\t\ttemp.innerHTML = vnode.children\n\t\t}\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = getDocument(parent).createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertDOM(parent, fragment, nextSibling)\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = getDocument(parent).createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertDOM(parent, fragment, nextSibling)\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs = vnode.attrs\n\t\tvar is = vnode.is\n\n\t\tns = getNameSpace(vnode) || ns\n\n\t\tvar element = ns ?\n\t\t\tis ? getDocument(parent).createElementNS(ns, tag, {is: is}) : getDocument(parent).createElementNS(ns, tag) :\n\t\t\tis ? getDocument(parent).createElement(tag, {is: is}) : getDocument(parent).createElement(tag)\n\t\tvnode.dom = element\n\n\t\tif (attrs != null) {\n\t\t\tsetAttrs(vnode, attrs, ns)\n\t\t}\n\n\t\tinsertDOM(parent, element, nextSibling)\n\n\t\tif (!maybeSetContentEditable(vnode)) {\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tif (vnode.tag === \"select\" && attrs != null) setLateSelectAttrs(vnode, attrs)\n\t\t\t}\n\t\t}\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === \"function\") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === \"function\") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tinitLifecycle(vnode.state, vnode, hooks)\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tcreateNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t}\n\t}\n\n\t//update\n\t/**\n\t * @param {Element|Fragment} parent - the parent element\n\t * @param {Vnode[] | null} old - the list of vnodes of the last `render()` call for\n\t *                               this part of the tree\n\t * @param {Vnode[] | null} vnodes - as above, but for the current `render()` call.\n\t * @param {Function[]} hooks - an accumulator of post-render hooks (oncreate/onupdate)\n\t * @param {Element | null} nextSibling - the next DOM node if we're dealing with a\n\t *                                       fragment that is not the last item in its\n\t *                                       parent\n\t * @param {'svg' | 'math' | String | null} ns) - the current XML namespace, if any\n\t * @returns void\n\t */\n\t// This function diffs and patches lists of vnodes, both keyed and unkeyed.\n\t//\n\t// We will:\n\t//\n\t// 1. describe its general structure\n\t// 2. focus on the diff algorithm optimizations\n\t// 3. discuss DOM node operations.\n\n\t// ## Overview:\n\t//\n\t// The updateNodes() function:\n\t// - deals with trivial cases\n\t// - determines whether the lists are keyed or unkeyed based on the first non-null node\n\t//   of each list.\n\t// - diffs them and patches the DOM if needed (that's the brunt of the code)\n\t// - manages the leftovers: after diffing, are there:\n\t//   - old nodes left to remove?\n\t// \t - new nodes to insert?\n\t// \t deal with them!\n\t//\n\t// The lists are only iterated over once, with an exception for the nodes in `old` that\n\t// are visited in the fourth part of the diff and in the `removeNodes` loop.\n\n\t// ## Diffing\n\t//\n\t// Reading https://github.com/localvoid/ivi/blob/ddc09d06abaef45248e6133f7040d00d3c6be853/packages/ivi/src/vdom/implementation.ts#L617-L837\n\t// may be good for context on longest increasing subsequence-based logic for moving nodes.\n\t//\n\t// In order to diff keyed lists, one has to\n\t//\n\t// 1) match nodes in both lists, per key, and update them accordingly\n\t// 2) create the nodes present in the new list, but absent in the old one\n\t// 3) remove the nodes present in the old list, but absent in the new one\n\t// 4) figure out what nodes in 1) to move in order to minimize the DOM operations.\n\t//\n\t// To achieve 1) one can create a dictionary of keys => index (for the old list), then iterate\n\t// over the new list and for each new vnode, find the corresponding vnode in the old list using\n\t// the map.\n\t// 2) is achieved in the same step: if a new node has no corresponding entry in the map, it is new\n\t// and must be created.\n\t// For the removals, we actually remove the nodes that have been updated from the old list.\n\t// The nodes that remain in that list after 1) and 2) have been performed can be safely removed.\n\t// The fourth step is a bit more complex and relies on the longest increasing subsequence (LIS)\n\t// algorithm.\n\t//\n\t// the longest increasing subsequence is the list of nodes that can remain in place. Imagine going\n\t// from `1,2,3,4,5` to `4,5,1,2,3` where the numbers are not necessarily the keys, but the indices\n\t// corresponding to the keyed nodes in the old list (keyed nodes `e,d,c,b,a` => `b,a,e,d,c` would\n\t//  match the above lists, for example).\n\t//\n\t// In there are two increasing subsequences: `4,5` and `1,2,3`, the latter being the longest. We\n\t// can update those nodes without moving them, and only call `insertNode` on `4` and `5`.\n\t//\n\t// @localvoid adapted the algo to also support node deletions and insertions (the `lis` is actually\n\t// the longest increasing subsequence *of old nodes still present in the new list*).\n\t//\n\t// It is a general algorithm that is fireproof in all circumstances, but it requires the allocation\n\t// and the construction of a `key => oldIndex` map, and three arrays (one with `newIndex => oldIndex`,\n\t// the `LIS` and a temporary one to create the LIS).\n\t//\n\t// So we cheat where we can: if the tails of the lists are identical, they are guaranteed to be part of\n\t// the LIS and can be updated without moving them.\n\t//\n\t// If two nodes are swapped, they are guaranteed not to be part of the LIS, and must be moved (with\n\t// the exception of the last node if the list is fully reversed).\n\t//\n\t// ## Finding the next sibling.\n\t//\n\t// `updateNode()` and `createNode()` expect a nextSibling parameter to perform DOM operations.\n\t// When the list is being traversed top-down, at any index, the DOM nodes up to the previous\n\t// vnode reflect the content of the new list, whereas the rest of the DOM nodes reflect the old\n\t// list. The next sibling must be looked for in the old list using `getNextSibling(... oldStart + 1 ...)`.\n\t//\n\t// In the other scenarios (swaps, upwards traversal, map-based diff),\n\t// the new vnodes list is traversed upwards. The DOM nodes at the bottom of the list reflect the\n\t// bottom part of the new vnodes list, and we can use the `v.dom`  value of the previous node\n\t// as the next sibling (cached in the `nextSibling` variable).\n\n\n\t// ## DOM node moves\n\t//\n\t// In most scenarios `updateNode()` and `createNode()` perform the DOM operations. However,\n\t// this is not the case if the node moved (second and fourth part of the diff algo). We move\n\t// the old DOM nodes before updateNode runs because it enables us to use the cached `nextSibling`\n\t// variable rather than fetching it using `getNextSibling()`.\n\n\tfunction updateNodes(parent, old, vnodes, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null || old.length === 0) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null || vnodes.length === 0) removeNodes(parent, old, 0, old.length)\n\t\telse {\n\t\t\tvar isOldKeyed = old[0] != null && old[0].key != null\n\t\t\tvar isKeyed = vnodes[0] != null && vnodes[0].key != null\n\t\t\tvar start = 0, oldStart = 0\n\t\t\tif (!isOldKeyed) while (oldStart < old.length && old[oldStart] == null) oldStart++\n\t\t\tif (!isKeyed) while (start < vnodes.length && vnodes[start] == null) start++\n\t\t\tif (isOldKeyed !== isKeyed) {\n\t\t\t\tremoveNodes(parent, old, oldStart, old.length)\n\t\t\t\tcreateNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)\n\t\t\t} else if (!isKeyed) {\n\t\t\t\t// Don't index past the end of either list (causes deopts).\n\t\t\t\tvar commonLength = old.length < vnodes.length ? old.length : vnodes.length\n\t\t\t\t// Rewind if necessary to the first non-null index on either side.\n\t\t\t\t// We could alternatively either explicitly create or remove nodes when `start !== oldStart`\n\t\t\t\t// but that would be optimizing for sparse lists which are more rare than dense ones.\n\t\t\t\tstart = start < oldStart ? start : oldStart\n\t\t\t\tfor (; start < commonLength; start++) {\n\t\t\t\t\to = old[start]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t\tif (o === v || o == null && v == null) continue\n\t\t\t\t\telse if (o == null) createNode(parent, v, hooks, ns, getNextSibling(old, start + 1, nextSibling))\n\t\t\t\t\telse if (v == null) removeNode(parent, o)\n\t\t\t\t\telse updateNode(parent, o, v, hooks, getNextSibling(old, start + 1, nextSibling), ns)\n\t\t\t\t}\n\t\t\t\tif (old.length > commonLength) removeNodes(parent, old, start, old.length)\n\t\t\t\tif (vnodes.length > commonLength) createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)\n\t\t\t} else {\n\t\t\t\t// keyed diff\n\t\t\t\tvar oldEnd = old.length - 1, end = vnodes.length - 1, map, o, v, oe, ve, topSibling\n\n\t\t\t\t// bottom-up\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t\tif (oe.key !== ve.key) break\n\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\t// top-down\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\to = old[oldStart]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t\tif (o.key !== v.key) break\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tif (o !== v) updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), ns)\n\t\t\t\t}\n\t\t\t\t// swaps and list reversals\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\tif (start === end) break\n\t\t\t\t\tif (o.key !== ve.key || oe.key !== v.key) break\n\t\t\t\t\ttopSibling = getNextSibling(old, oldStart, nextSibling)\n\t\t\t\t\tmoveDOM(parent, oe, topSibling)\n\t\t\t\t\tif (oe !== v) updateNode(parent, oe, v, hooks, topSibling, ns)\n\t\t\t\t\tif (++start <= --end) moveDOM(parent, o, nextSibling)\n\t\t\t\t\tif (o !== ve) updateNode(parent, o, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldStart++; oldEnd--\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t\to = old[oldStart]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t}\n\t\t\t\t// bottom up once again\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\tif (oe.key !== ve.key) break\n\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t}\n\t\t\t\tif (start > end) removeNodes(parent, old, oldStart, oldEnd + 1)\n\t\t\t\telse if (oldStart > oldEnd) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\t\telse {\n\t\t\t\t\t// inspired by ivi https://github.com/ivijs/ivi/ by Boris Kaul\n\t\t\t\t\tvar originalNextSibling = nextSibling, vnodesLength = end - start + 1, oldIndices = new Array(vnodesLength), li=0, i=0, pos = 2147483647, matched = 0, map, lisIndices\n\t\t\t\t\tfor (i = 0; i < vnodesLength; i++) oldIndices[i] = -1\n\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\tif (map == null) map = getKeyMap(old, oldStart, oldEnd + 1)\n\t\t\t\t\t\tve = vnodes[i]\n\t\t\t\t\t\tvar oldIndex = map[ve.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tpos = (oldIndex < pos) ? oldIndex : -1 // becomes -1 if nodes were re-ordered\n\t\t\t\t\t\t\toldIndices[i-start] = oldIndex\n\t\t\t\t\t\t\toe = old[oldIndex]\n\t\t\t\t\t\t\told[oldIndex] = null\n\t\t\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\t\t\tmatched++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnextSibling = originalNextSibling\n\t\t\t\t\tif (matched !== oldEnd - oldStart + 1) removeNodes(parent, old, oldStart, oldEnd + 1)\n\t\t\t\t\tif (matched === 0) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (pos === -1) {\n\t\t\t\t\t\t\t// the indices of the indices of the items that are part of the\n\t\t\t\t\t\t\t// longest increasing subsequence in the oldIndices list\n\t\t\t\t\t\t\tlisIndices = makeLisIndices(oldIndices)\n\t\t\t\t\t\t\tli = lisIndices.length - 1\n\t\t\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\t\t\tv = vnodes[i]\n\t\t\t\t\t\t\t\tif (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (lisIndices[li] === i - start) li--\n\t\t\t\t\t\t\t\t\telse moveDOM(parent, v, nextSibling)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (v.dom != null) nextSibling = vnodes[i].dom\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\t\t\tv = vnodes[i]\n\t\t\t\t\t\t\t\tif (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\t\tif (v.dom != null) nextSibling = vnodes[i].dom\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag && old.is === vnode.is) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode.events = old.events\n\t\t\tif (shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tupdateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase \"#\": updateText(old, vnode); break\n\t\t\t\t\tcase \"<\": updateHTML(parent, old, vnode, ns, nextSibling); break\n\t\t\t\t\tcase \"[\": updateFragment(parent, old, vnode, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(parent, old)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, ns, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\tremoveDOM(parent, old)\n\t\t\tcreateHTML(parent, vnode, ns, nextSibling)\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction updateFragment(parent, old, vnode, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvnode.domSize = domSize\n\t}\n\tfunction updateElement(old, vnode, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\n\t\tif (old.attrs != vnode.attrs || (vnode.attrs != null && !cachedAttrsIsStaticMap.get(vnode.attrs))) {\n\t\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\t}\n\t\tif (!maybeSetContentEditable(vnode)) {\n\t\t\tupdateNodes(element, old.children, vnode.children, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, ns) {\n\t\tvnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tupdateLifecycle(vnode.state, vnode, hooks)\n\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse {\n\t\t\tif (old.instance != null) removeNode(parent, old.instance)\n\t\t\tvnode.domSize = 0\n\t\t}\n\t}\n\tfunction getKeyMap(vnodes, start, end) {\n\t\tvar map = Object.create(null)\n\t\tfor (; start < end; start++) {\n\t\t\tvar vnode = vnodes[start]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key = vnode.key\n\t\t\t\tif (key != null) map[key] = start\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\t// Lifted from ivi https://github.com/ivijs/ivi/\n\t// takes a list of unique numbers (-1 is special and can\n\t// occur multiple times) and returns an array with the indices\n\t// of the items that are part of the longest increasing\n\t// subsequence\n\tvar lisTemp = []\n\tfunction makeLisIndices(a) {\n\t\tvar result = [0]\n\t\tvar u = 0, v = 0, i = 0\n\t\tvar il = lisTemp.length = a.length\n\t\tfor (var i = 0; i < il; i++) lisTemp[i] = a[i]\n\t\tfor (var i = 0; i < il; ++i) {\n\t\t\tif (a[i] === -1) continue\n\t\t\tvar j = result[result.length - 1]\n\t\t\tif (a[j] < a[i]) {\n\t\t\t\tlisTemp[i] = j\n\t\t\t\tresult.push(i)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tu = 0\n\t\t\tv = result.length - 1\n\t\t\twhile (u < v) {\n\t\t\t\t// Fast integer average without overflow.\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tvar c = (u >>> 1) + (v >>> 1) + (u & v & 1)\n\t\t\t\tif (a[result[c]] < a[i]) {\n\t\t\t\t\tu = c + 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv = c\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] < a[result[u]]) {\n\t\t\t\tif (u > 0) lisTemp[i] = result[u - 1]\n\t\t\t\tresult[u] = i\n\t\t\t}\n\t\t}\n\t\tu = result.length\n\t\tv = result[u - 1]\n\t\twhile (u-- > 0) {\n\t\t\tresult[u] = v\n\t\t\tv = lisTemp[v]\n\t\t}\n\t\tlisTemp.length = 0\n\t\treturn result\n\t}\n\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\n\t// This handles fragments with zombie children (removed from vdom, but persisted in DOM through onbeforeremove)\n\tfunction moveDOM(parent, vnode, nextSibling) {\n\t\tif (vnode.dom != null) {\n\t\t\tvar target\n\t\t\tif (vnode.domSize == null || vnode.domSize === 1) {\n\t\t\t\t// don't allocate for the common case\n\t\t\t\ttarget = vnode.dom\n\t\t\t} else {\n\t\t\t\ttarget = getDocument(parent).createDocumentFragment()\n\t\t\t\tfor (var dom of domFor(vnode)) target.appendChild(dom)\n\t\t\t}\n\t\t\tinsertDOM(parent, target, nextSibling)\n\t\t}\n\t}\n\n\tfunction insertDOM(parent, dom, nextSibling) {\n\t\tif (nextSibling != null) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\n\tfunction maybeSetContentEditable(vnode) {\n\t\tif (vnode.attrs == null || (\n\t\t\tvnode.attrs.contenteditable == null && // attribute\n\t\t\tvnode.attrs.contentEditable == null // property\n\t\t)) return false\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === \"<\") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (children != null && children.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted.\")\n\t\treturn true\n\t}\n\n\t//remove\n\tfunction removeNodes(parent, vnodes, start, end) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) removeNode(parent, vnode)\n\t\t}\n\t}\n\tfunction tryBlockRemove(parent, vnode, source, counter) {\n\t\tvar original = vnode.state\n\t\tvar result = callHook.call(source.onbeforeremove, vnode)\n\t\tif (result == null) return\n\n\t\tvar generation = currentRender\n\t\tfor (var dom of domFor(vnode)) delayedRemoval.set(dom, generation)\n\t\tcounter.v++\n\n\t\tPromise.resolve(result).finally(function () {\n\t\t\tcheckState(vnode, original)\n\t\t\ttryResumeRemove(parent, vnode, counter)\n\t\t})\n\t}\n\tfunction tryResumeRemove(parent, vnode, counter) {\n\t\tif (--counter.v === 0) {\n\t\t\tonremove(vnode)\n\t\t\tremoveDOM(parent, vnode)\n\t\t}\n\t}\n\tfunction removeNode(parent, vnode) {\n\t\tvar counter = {v: 1}\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode.state.onbeforeremove === \"function\") tryBlockRemove(parent, vnode, vnode.state, counter)\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === \"function\") tryBlockRemove(parent, vnode, vnode.attrs, counter)\n\t\ttryResumeRemove(parent, vnode, counter)\n\t}\n\tfunction removeDOM(parent, vnode) {\n\t\tif (vnode.dom == null) return\n\t\tif (vnode.domSize == null || vnode.domSize === 1) {\n\t\t\tparent.removeChild(vnode.dom)\n\t\t} else {\n\t\t\tfor (var dom of domFor(vnode)) parent.removeChild(dom)\n\t\t}\n\t}\n\n\tfunction onremove(vnode) {\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode.state.onremove === \"function\") callHook.call(vnode.state.onremove, vnode)\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === \"function\") callHook.call(vnode.attrs.onremove, vnode)\n\t\tif (typeof vnode.tag !== \"string\") {\n\t\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\t} else {\n\t\t\tif (vnode.events != null) vnode.events._ = null\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//attrs\n\tfunction setAttrs(vnode, attrs, ns) {\n\t\tfor (var key in attrs) {\n\t\t\tsetAttr(vnode, key, null, attrs[key], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key, old, value, ns) {\n\t\tif (key === \"key\" || value == null || isLifecycleMethod(key) || (old === value && !isFormAttribute(vnode, key)) && typeof value !== \"object\") return\n\t\tif (key[0] === \"o\" && key[1] === \"n\") return updateEvent(vnode, key, value)\n\t\tif (key.slice(0, 6) === \"xlink:\") vnode.dom.setAttributeNS(\"http://www.w3.org/1999/xlink\", key.slice(6), value)\n\t\telse if (key === \"style\") updateStyle(vnode.dom, old, value)\n\t\telse if (hasPropertyKey(vnode, key, ns)) {\n\t\t\tif (key === \"value\") {\n\t\t\t\t// Only do the coercion if we're actually going to check the value.\n\t\t\t\t/* eslint-disable no-implicit-coercion */\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\t//setting input[type=file][value] to same value causes an error to be generated if it's non-empty\n\t\t\t\t//minlength/maxlength validation isn't performed on script-set values(#2256)\n\t\t\t\tif ((vnode.tag === \"input\" || vnode.tag === \"textarea\") && vnode.dom.value === \"\" + value) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === \"select\" && old !== null && vnode.dom.value === \"\" + value) return\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === \"option\" && old !== null && vnode.dom.value === \"\" + value) return\n\t\t\t\t//setting input[type=file][value] to different value is an error if it's non-empty\n\t\t\t\t// Not ideal, but it at least works around the most common source of uncaught exceptions for now.\n\t\t\t\tif (vnode.tag === \"input\" && vnode.attrs.type === \"file\" && \"\" + value !== \"\") { console.error(\"`value` is read-only on file inputs!\"); return }\n\t\t\t\t/* eslint-enable no-implicit-coercion */\n\t\t\t}\n\t\t\t// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.\n\t\t\tif (vnode.tag === \"input\" && key === \"type\") vnode.dom.setAttribute(key, value)\n\t\t\telse vnode.dom[key] = value\n\t\t} else {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tif (value) vnode.dom.setAttribute(key, \"\")\n\t\t\t\telse vnode.dom.removeAttribute(key)\n\t\t\t}\n\t\t\telse vnode.dom.setAttribute(key === \"className\" ? \"class\" : key, value)\n\t\t}\n\t}\n\tfunction removeAttr(vnode, key, old, ns) {\n\t\tif (key === \"key\" || old == null || isLifecycleMethod(key)) return\n\t\tif (key[0] === \"o\" && key[1] === \"n\") updateEvent(vnode, key, undefined)\n\t\telse if (key === \"style\") updateStyle(vnode.dom, old, null)\n\t\telse if (\n\t\t\thasPropertyKey(vnode, key, ns)\n\t\t\t&& key !== \"className\"\n\t\t\t&& key !== \"title\" // creates \"null\" as title\n\t\t\t&& !(key === \"value\" && (\n\t\t\t\tvnode.tag === \"option\"\n\t\t\t\t|| vnode.tag === \"select\" && vnode.dom.selectedIndex === -1 && vnode.dom === activeElement(vnode.dom)\n\t\t\t))\n\t\t\t&& !(vnode.tag === \"input\" && key === \"type\")\n\t\t) {\n\t\t\tvnode.dom[key] = null\n\t\t} else {\n\t\t\tvar nsLastIndex = key.indexOf(\":\")\n\t\t\tif (nsLastIndex !== -1) key = key.slice(nsLastIndex + 1)\n\t\t\tif (old !== false) vnode.dom.removeAttribute(key === \"className\" ? \"class\" : key)\n\t\t}\n\t}\n\tfunction setLateSelectAttrs(vnode, attrs) {\n\t\tif (\"value\" in attrs) {\n\t\t\tif(attrs.value === null) {\n\t\t\t\tif (vnode.dom.selectedIndex !== -1) vnode.dom.value = null\n\t\t\t} else {\n\t\t\t\tvar normalized = \"\" + attrs.value // eslint-disable-line no-implicit-coercion\n\t\t\t\tif (vnode.dom.value !== normalized || vnode.dom.selectedIndex === -1) {\n\t\t\t\t\tvnode.dom.value = normalized\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (\"selectedIndex\" in attrs) setAttr(vnode, \"selectedIndex\", null, attrs.selectedIndex, undefined)\n\t}\n\tfunction updateAttrs(vnode, old, attrs, ns) {\n\t\t// Some attributes may NOT be case-sensitive (e.g. data-***),\n\t\t// so removal should be done first to prevent accidental removal for newly setting values.\n\t\tvar val\n\t\tif (old != null) {\n\t\t\tif (old === attrs && !cachedAttrsIsStaticMap.has(attrs)) {\n\t\t\t\tconsole.warn(\"Don't reuse attrs object, use new object for every redraw, this will throw in next major\")\n\t\t\t}\n\t\t\tfor (var key in old) {\n\t\t\t\tif (((val = old[key]) != null) && (attrs == null || attrs[key] == null)) {\n\t\t\t\t\tremoveAttr(vnode, key, val, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (attrs != null) {\n\t\t\tfor (var key in attrs) {\n\t\t\t\tsetAttr(vnode, key, old && old[key], attrs[key], ns)\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && (vnode.dom === activeElement(vnode.dom) || vnode.tag === \"option\" && vnode.dom.parentNode === activeElement(vnode.dom))\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\"\n\t}\n\tfunction hasPropertyKey(vnode, key, ns) {\n\t\t// Filter out namespaced keys\n\t\treturn ns === undefined && (\n\t\t\t// If it's a custom element, just keep it.\n\t\t\tvnode.tag.indexOf(\"-\") > -1 || vnode.is ||\n\t\t\t// If it's a normal element, let's try to avoid a few browser bugs.\n\t\t\tkey !== \"href\" && key !== \"list\" && key !== \"form\" && key !== \"width\" && key !== \"height\"// && key !== \"type\"\n\t\t\t// Defer the property check until *after* we check everything.\n\t\t) && key in vnode.dom\n\t}\n\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) {\n\t\t\t// Styles are equivalent, do nothing.\n\t\t} else if (style == null) {\n\t\t\t// New style is missing, just clear it.\n\t\t\telement.style = \"\"\n\t\t} else if (typeof style !== \"object\") {\n\t\t\t// New style is a string, let engine deal with patching.\n\t\t\telement.style = style\n\t\t} else if (old == null || typeof old !== \"object\") {\n\t\t\t// `old` is missing or a string, `style` is an object.\n\t\t\telement.style = \"\"\n\t\t\t// Add new style properties\n\t\t\tfor (var key in style) {\n\t\t\t\tvar value = style[key]\n\t\t\t\tif (value != null) {\n\t\t\t\t\tif (key.includes(\"-\")) element.style.setProperty(key, String(value))\n\t\t\t\t\telse element.style[key] = String(value)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Both old & new are (different) objects.\n\t\t\t// Remove style properties that no longer exist\n\t\t\t// Style properties may have two cases(dash-case and camelCase),\n\t\t\t// so removal should be done first to prevent accidental removal for newly setting values.\n\t\t\tfor (var key in old) {\n\t\t\t\tif (old[key] != null && style[key] == null) {\n\t\t\t\t\tif (key.includes(\"-\")) element.style.removeProperty(key)\n\t\t\t\t\telse element.style[key] = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update style properties that have changed\n\t\t\tfor (var key in style) {\n\t\t\t\tvar value = style[key]\n\t\t\t\tif (value != null && (value = String(value)) !== String(old[key])) {\n\t\t\t\t\tif (key.includes(\"-\")) element.style.setProperty(key, value)\n\t\t\t\t\telse element.style[key] = value\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Here's an explanation of how this works:\n\t// 1. The event names are always (by design) prefixed by `on`.\n\t// 2. The EventListener interface accepts either a function or an object\n\t//    with a `handleEvent` method.\n\t// 3. The object does not inherit from `Object.prototype`, to avoid\n\t//    any potential interference with that (e.g. setters).\n\t// 4. The event name is remapped to the handler before calling it.\n\t// 5. In function-based event handlers, `ev.target === this`. We replicate\n\t//    that below.\n\t// 6. In function-based event handlers, `return false` prevents the default\n\t//    action and stops event propagation. We replicate that below.\n\tfunction EventDict() {\n\t\t// Save this, so the current redraw is correctly tracked.\n\t\tthis._ = currentRedraw\n\t}\n\tEventDict.prototype = Object.create(null)\n\tEventDict.prototype.handleEvent = function (ev) {\n\t\tvar handler = this[\"on\" + ev.type]\n\t\tvar result\n\t\tif (typeof handler === \"function\") result = handler.call(ev.currentTarget, ev)\n\t\telse if (typeof handler.handleEvent === \"function\") handler.handleEvent(ev)\n\t\tvar self = this\n\t\tif (self._ != null) {\n\t\t\tif (ev.redraw !== false) (0, self._)()\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\tPromise.resolve(result).then(function () {\n\t\t\t\t\tif (self._ != null && ev.redraw !== false) (0, self._)()\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif (result === false) {\n\t\t\tev.preventDefault()\n\t\t\tev.stopPropagation()\n\t\t}\n\t}\n\n\t//event\n\tfunction updateEvent(vnode, key, value) {\n\t\tif (vnode.events != null) {\n\t\t\tvnode.events._ = currentRedraw\n\t\t\tif (vnode.events[key] === value) return\n\t\t\tif (value != null && (typeof value === \"function\" || typeof value === \"object\")) {\n\t\t\t\tif (vnode.events[key] == null) vnode.dom.addEventListener(key.slice(2), vnode.events, false)\n\t\t\t\tvnode.events[key] = value\n\t\t\t} else {\n\t\t\t\tif (vnode.events[key] != null) vnode.dom.removeEventListener(key.slice(2), vnode.events, false)\n\t\t\t\tvnode.events[key] = undefined\n\t\t\t}\n\t\t} else if (value != null && (typeof value === \"function\" || typeof value === \"object\")) {\n\t\t\tvnode.events = new EventDict()\n\t\t\tvnode.dom.addEventListener(key.slice(2), vnode.events, false)\n\t\t\tvnode.events[key] = value\n\t\t}\n\t}\n\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === \"function\") callHook.call(source.oninit, vnode)\n\t\tif (typeof source.oncreate === \"function\") hooks.push(callHook.bind(source.oncreate, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === \"function\") hooks.push(callHook.bind(source.onupdate, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tdo {\n\t\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === \"function\") {\n\t\t\t\tvar force = callHook.call(vnode.attrs.onbeforeupdate, vnode, old)\n\t\t\t\tif (force !== undefined && !force) break\n\t\t\t}\n\t\t\tif (typeof vnode.tag !== \"string\" && typeof vnode.state.onbeforeupdate === \"function\") {\n\t\t\t\tvar force = callHook.call(vnode.state.onbeforeupdate, vnode, old)\n\t\t\t\tif (force !== undefined && !force) break\n\t\t\t}\n\t\t\treturn false\n\t\t} while (false); // eslint-disable-line no-constant-condition\n\t\tvnode.dom = old.dom\n\t\tvnode.domSize = old.domSize\n\t\tvnode.instance = old.instance\n\t\t// One would think having the actual latest attributes would be ideal,\n\t\t// but it doesn't let us properly diff based on our current internal\n\t\t// representation. We have to save not only the old DOM info, but also\n\t\t// the attributes used to create it, as we diff *that*, not against the\n\t\t// DOM directly (with a few exceptions in `setAttr`). And, of course, we\n\t\t// need to save the children and text as they are conceptually not\n\t\t// unlike special \"attributes\" internally.\n\t\tvnode.attrs = old.attrs\n\t\tvnode.children = old.children\n\t\tvnode.text = old.text\n\t\treturn true\n\t}\n\n\tvar currentDOM\n\n\treturn function(dom, vnodes, redraw) {\n\t\tif (!dom) throw new TypeError(\"DOM element being rendered to does not exist.\")\n\t\tif (currentDOM != null && dom.contains(currentDOM)) {\n\t\t\tthrow new TypeError(\"Node is currently being rendered to and thus is locked.\")\n\t\t}\n\t\tvar prevRedraw = currentRedraw\n\t\tvar prevDOM = currentDOM\n\t\tvar hooks = []\n\t\tvar active = activeElement(dom)\n\t\tvar namespace = dom.namespaceURI\n\n\t\tcurrentDOM = dom\n\t\tcurrentRedraw = typeof redraw === \"function\" ? redraw : undefined\n\t\tcurrentRender = {}\n\t\ttry {\n\t\t\t// First time rendering into a node clears it out\n\t\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\t\t\tvnodes = Vnode.normalizeChildren(Array.isArray(vnodes) ? vnodes : [vnodes])\n\t\t\tupdateNodes(dom, dom.vnodes, vnodes, hooks, null, namespace === \"http://www.w3.org/1999/xhtml\" ? undefined : namespace)\n\t\t\tdom.vnodes = vnodes\n\t\t\t// `document.activeElement` can return null: https://html.spec.whatwg.org/multipage/interaction.html#dom-document-activeelement\n\t\t\tif (active != null && activeElement(dom) !== active && typeof active.focus === \"function\") active.focus()\n\t\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\t} finally {\n\t\t\tcurrentRedraw = prevRedraw\n\t\t\tcurrentDOM = prevDOM\n\t\t}\n\t}\n}\n", "\"use strict\"\n\nmodule.exports = require(\"./render/render\")()\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\n\nmodule.exports = function(render, schedule, console) {\n\tvar subscriptions = []\n\tvar pending = false\n\tvar offset = -1\n\n\tfunction sync() {\n\t\tfor (offset = 0; offset < subscriptions.length; offset += 2) {\n\t\t\ttry { render(subscriptions[offset], Vnode(subscriptions[offset + 1]), redraw) }\n\t\t\tcatch (e) { console.error(e) }\n\t\t}\n\t\toffset = -1\n\t}\n\n\tfunction redraw() {\n\t\tif (!pending) {\n\t\t\tpending = true\n\t\t\tschedule(function() {\n\t\t\t\tpending = false\n\t\t\t\tsync()\n\t\t\t})\n\t\t}\n\t}\n\n\tredraw.sync = sync\n\n\tfunction mount(root, component) {\n\t\tif (component != null && component.view == null && typeof component !== \"function\") {\n\t\t\tthrow new TypeError(\"m.mount expects a component, not a vnode.\")\n\t\t}\n\n\t\tvar index = subscriptions.indexOf(root)\n\t\tif (index >= 0) {\n\t\t\tsubscriptions.splice(index, 2)\n\t\t\tif (index <= offset) offset -= 2\n\t\t\trender(root, [])\n\t\t}\n\n\t\tif (component != null) {\n\t\t\tsubscriptions.push(root, component)\n\t\t\trender(root, Vnode(component), redraw)\n\t\t}\n\t}\n\n\treturn {mount: mount, redraw: redraw}\n}\n", "\"use strict\"\n\nvar render = require(\"./render\")\n\nmodule.exports = require(\"./api/mount-redraw\")(render, typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : null, typeof console !== \"undefined\" ? console : null)\n", "\"use strict\"\n\nmodule.exports = function(object) {\n\tif (Object.prototype.toString.call(object) !== \"[object Object]\") return \"\"\n\n\tvar args = []\n\tfor (var key in object) {\n\t\tdestructure(key, object[key])\n\t}\n\n\treturn args.join(\"&\")\n\n\tfunction destructure(key, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === \"[object Object]\") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key) + (value != null && value !== \"\" ? \"=\" + encodeURIComponent(value) : \"\"))\n\t}\n}\n", "\"use strict\"\n\nvar buildQueryString = require(\"../querystring/build\")\n\n// Returns `path` from `template` + `params`\nmodule.exports = function(template, params) {\n\tif ((/:([^\\/\\.-]+)(\\.{3})?:/).test(template)) {\n\t\tthrow new SyntaxError(\"Template parameter names must be separated by either a '/', '-', or '.'.\")\n\t}\n\tif (params == null) return template\n\tvar queryIndex = template.indexOf(\"?\")\n\tvar hashIndex = template.indexOf(\"#\")\n\tvar queryEnd = hashIndex < 0 ? template.length : hashIndex\n\tvar pathEnd = queryIndex < 0 ? queryEnd : queryIndex\n\tvar path = template.slice(0, pathEnd)\n\tvar query = {}\n\n\tObject.assign(query, params)\n\n\tvar resolved = path.replace(/:([^\\/\\.-]+)(\\.{3})?/g, function(m, key, variadic) {\n\t\tdelete query[key]\n\t\t// If no such parameter exists, don't interpolate it.\n\t\tif (params[key] == null) return m\n\t\t// Escape normal parameters, but not variadic ones.\n\t\treturn variadic ? params[key] : encodeURIComponent(String(params[key]))\n\t})\n\n\t// In case the template substitution adds new query/hash parameters.\n\tvar newQueryIndex = resolved.indexOf(\"?\")\n\tvar newHashIndex = resolved.indexOf(\"#\")\n\tvar newQueryEnd = newHashIndex < 0 ? resolved.length : newHashIndex\n\tvar newPathEnd = newQueryIndex < 0 ? newQueryEnd : newQueryIndex\n\tvar result = resolved.slice(0, newPathEnd)\n\n\tif (queryIndex >= 0) result += template.slice(queryIndex, queryEnd)\n\tif (newQueryIndex >= 0) result += (queryIndex < 0 ? \"?\" : \"&\") + resolved.slice(newQueryIndex, newQueryEnd)\n\tvar querystring = buildQueryString(query)\n\tif (querystring) result += (queryIndex < 0 && newQueryIndex < 0 ? \"?\" : \"&\") + querystring\n\tif (hashIndex >= 0) result += template.slice(hashIndex)\n\tif (newHashIndex >= 0) result += (hashIndex < 0 ? \"\" : \"&\") + resolved.slice(newHashIndex)\n\treturn result\n}\n", "\"use strict\"\n\nvar buildPathname = require(\"../pathname/build\")\nvar hasOwn = require(\"../util/hasOwn\")\n\nmodule.exports = function($window, oncompletion) {\n\tfunction PromiseProxy(executor) {\n\t\treturn new Promise(executor)\n\t}\n\n\tfunction makeRequest(url, args) {\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\turl = buildPathname(url, args.params)\n\t\t\tvar method = args.method != null ? args.method.toUpperCase() : \"GET\"\n\t\t\tvar body = args.body\n\t\t\tvar assumeJSON = (args.serialize == null || args.serialize === JSON.serialize) && !(body instanceof $window.FormData || body instanceof $window.URLSearchParams)\n\t\t\tvar responseType = args.responseType || (typeof args.extract === \"function\" ? \"\" : \"json\")\n\n\t\t\tvar xhr = new $window.XMLHttpRequest(), aborted = false, isTimeout = false\n\t\t\tvar original = xhr, replacedAbort\n\t\t\tvar abort = xhr.abort\n\n\t\t\txhr.abort = function() {\n\t\t\t\taborted = true\n\t\t\t\tabort.call(this)\n\t\t\t}\n\n\t\t\txhr.open(method, url, args.async !== false, typeof args.user === \"string\" ? args.user : undefined, typeof args.password === \"string\" ? args.password : undefined)\n\n\t\t\tif (assumeJSON && body != null && !hasHeader(args, \"content-type\")) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\t\t}\n\t\t\tif (typeof args.deserialize !== \"function\" && !hasHeader(args, \"accept\")) {\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tif (args.timeout) xhr.timeout = args.timeout\n\t\t\txhr.responseType = responseType\n\n\t\t\tfor (var key in args.headers) {\n\t\t\t\tif (hasOwn.call(args.headers, key)) {\n\t\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txhr.onreadystatechange = function(ev) {\n\t\t\t\t// Don't throw errors on xhr.abort().\n\t\t\t\tif (aborted) return\n\n\t\t\t\tif (ev.target.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar success = (ev.target.status >= 200 && ev.target.status < 300) || ev.target.status === 304 || (/^file:\\/\\//i).test(url)\n\t\t\t\t\t\t// When the response type isn't \"\" or \"text\",\n\t\t\t\t\t\t// `xhr.responseText` is the wrong thing to use.\n\t\t\t\t\t\t// Browsers do the right thing and throw here, and we\n\t\t\t\t\t\t// should honor that and do the right thing by\n\t\t\t\t\t\t// preferring `xhr.response` where possible/practical.\n\t\t\t\t\t\tvar response = ev.target.response, message\n\n\t\t\t\t\t\tif (responseType === \"json\") {\n\t\t\t\t\t\t\t// For IE and Edge, which don't implement\n\t\t\t\t\t\t\t// `responseType: \"json\"`.\n\t\t\t\t\t\t\tif (!ev.target.responseType && typeof args.extract !== \"function\") {\n\t\t\t\t\t\t\t\t// Handle no-content which will not parse.\n\t\t\t\t\t\t\t\ttry { response = JSON.parse(ev.target.responseText) }\n\t\t\t\t\t\t\t\tcatch (e) { response = null }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!responseType || responseType === \"text\") {\n\t\t\t\t\t\t\t// Only use this default if it's text. If a parsed\n\t\t\t\t\t\t\t// document is needed on old IE and friends (all\n\t\t\t\t\t\t\t// unsupported), the user should use a custom\n\t\t\t\t\t\t\t// `config` instead. They're already using this at\n\t\t\t\t\t\t\t// their own risk.\n\t\t\t\t\t\t\tif (response == null) response = ev.target.responseText\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof args.extract === \"function\") {\n\t\t\t\t\t\t\tresponse = args.extract(ev.target, args)\n\t\t\t\t\t\t\tsuccess = true\n\t\t\t\t\t\t} else if (typeof args.deserialize === \"function\") {\n\t\t\t\t\t\t\tresponse = args.deserialize(response)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (success) {\n\t\t\t\t\t\t\tif (typeof args.type === \"function\") {\n\t\t\t\t\t\t\t\tif (Array.isArray(response)) {\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < response.length; i++) {\n\t\t\t\t\t\t\t\t\t\tresponse[i] = new args.type(response[i])\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse response = new args.type(response)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolve(response)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar completeErrorResponse = function() {\n\t\t\t\t\t\t\t\ttry { message = ev.target.responseText }\n\t\t\t\t\t\t\t\tcatch (e) { message = response }\n\t\t\t\t\t\t\t\tvar error = new Error(message)\n\t\t\t\t\t\t\t\terror.code = ev.target.status\n\t\t\t\t\t\t\t\terror.response = response\n\t\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (xhr.status === 0) {\n\t\t\t\t\t\t\t\t// Use setTimeout to push this code block onto the event queue\n\t\t\t\t\t\t\t\t// This allows `xhr.ontimeout` to run in the case that there is a timeout\n\t\t\t\t\t\t\t\t// Without this setTimeout, `xhr.ontimeout` doesn't have a chance to reject\n\t\t\t\t\t\t\t\t// as `xhr.onreadystatechange` will run before it\n\t\t\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\t\t\tif (isTimeout) return\n\t\t\t\t\t\t\t\t\tcompleteErrorResponse()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t} else completeErrorResponse()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txhr.ontimeout = function (ev) {\n\t\t\t\tisTimeout = true\n\t\t\t\tvar error = new Error(\"Request timed out\")\n\t\t\t\terror.code = ev.target.status\n\t\t\t\treject(error)\n\t\t\t}\n\n\t\t\tif (typeof args.config === \"function\") {\n\t\t\t\txhr = args.config(xhr, args, url) || xhr\n\n\t\t\t\t// Propagate the `abort` to any replacement XHR as well.\n\t\t\t\tif (xhr !== original) {\n\t\t\t\t\treplacedAbort = xhr.abort\n\t\t\t\t\txhr.abort = function() {\n\t\t\t\t\t\taborted = true\n\t\t\t\t\t\treplacedAbort.call(this)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body == null) xhr.send()\n\t\t\telse if (typeof args.serialize === \"function\") xhr.send(args.serialize(body))\n\t\t\telse if (body instanceof $window.FormData || body instanceof $window.URLSearchParams) xhr.send(body)\n\t\t\telse xhr.send(JSON.stringify(body))\n\t\t})\n\t}\n\n\t// In case the global Promise is some userland library's where they rely on\n\t// `foo instanceof this.constructor`, `this.constructor.resolve(value)`, or\n\t// similar. Let's *not* break them.\n\tPromiseProxy.prototype = Promise.prototype\n\tPromiseProxy.__proto__ = Promise // eslint-disable-line no-proto\n\n\tfunction hasHeader(args, name) {\n\t\tfor (var key in args.headers) {\n\t\t\tif (hasOwn.call(args.headers, key) && key.toLowerCase() === name) return true\n\t\t}\n\t\treturn false\n\t}\n\n\treturn {\n\t\trequest: function(url, args) {\n\t\t\tif (typeof url !== \"string\") { args = url; url = url.url }\n\t\t\telse if (args == null) args = {}\n\t\t\tvar promise = makeRequest(url, args)\n\t\t\tif (args.background === true) return promise\n\t\t\tvar count = 0\n\t\t\tfunction complete() {\n\t\t\t\tif (--count === 0 && typeof oncompletion === \"function\") oncompletion()\n\t\t\t}\n\n\t\t\treturn wrap(promise)\n\n\t\t\tfunction wrap(promise) {\n\t\t\t\tvar then = promise.then\n\t\t\t\t// Set the constructor, so engines know to not await or resolve\n\t\t\t\t// this as a native promise. At the time of writing, this is\n\t\t\t\t// only necessary for V8, but their behavior is the correct\n\t\t\t\t// behavior per spec. See this spec issue for more details:\n\t\t\t\t// https://github.com/tc39/ecma262/issues/1577. Also, see the\n\t\t\t\t// corresponding comment in `request/tests/test-request.js` for\n\t\t\t\t// a bit more background on the issue at hand.\n\t\t\t\tpromise.constructor = PromiseProxy\n\t\t\t\tpromise.then = function() {\n\t\t\t\t\tcount++\n\t\t\t\t\tvar next = then.apply(promise, arguments)\n\t\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\t\tcomplete()\n\t\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t\t})\n\t\t\t\t\treturn wrap(next)\n\t\t\t\t}\n\t\t\t\treturn promise\n\t\t\t}\n\t\t}\n\t}\n}\n", "\"use strict\"\n\nvar mountRedraw = require(\"./mount-redraw\")\n\nmodule.exports = require(\"./request/request\")(typeof window !== \"undefined\" ? window : null, mountRedraw.redraw)\n", "\"use strict\"\n\n/*\nPercent encodings encode UTF-8 bytes, so this regexp needs to match that.\nHere's how UTF-8 encodes stuff:\n- `00-7F`: 1-byte, for U+0000-U+007F\n- `C2-DF 80-BF`: 2-byte, for U+0080-U+07FF\n- `E0-EF 80-BF 80-BF`: 3-byte, encodes U+0800-U+FFFF\n- `F0-F4 80-BF 80-BF 80-BF`: 4-byte, encodes U+10000-U+10FFFF\nIn this, there's a number of invalid byte sequences:\n- `80-BF`: Continuation byte, invalid as start\n- `C0-C1 80-BF`: Overlong encoding for U+0000-U+007F\n- `E0 80-9F 80-BF`: Overlong encoding for U+0080-U+07FF\n- `ED A0-BF 80-BF`: Encoding for UTF-16 surrogate U+D800-U+DFFF\n- `F0 80-8F 80-BF 80-BF`: Overlong encoding for U+0800-U+FFFF\n- `F4 90-BF`: RFC 3629 restricted UTF-8 to only code points UTF-16 could encode.\n- `F5-FF`: RFC 3629 restricted UTF-8 to only code points UTF-16 could encode.\nSo in reality, only the following sequences can encode are valid characters:\n- 00-7F\n- C2-DF 80-BF\n- E0    A0-BF 80-BF\n- E1-EC 80-BF 80-BF\n- ED    80-9F 80-BF\n- EE-EF 80-BF 80-BF\n- F0    90-BF 80-BF 80-BF\n- F1-F3 80-BF 80-BF 80-BF\n- F4    80-8F 80-BF 80-BF\n\nThe regexp just tries to match this as compactly as possible.\n*/\nvar validUtf8Encodings = /%(?:[0-7]|(?!c[01]|e0%[89]|ed%[ab]|f0%8|f4%[9ab])(?:c|d|(?:e|f[0-4]%[89ab])[\\da-f]%[89ab])[\\da-f]%[89ab])[\\da-f]/gi\n\nmodule.exports = function(str) {\n\treturn String(str).replace(validUtf8Encodings, decodeURIComponent)\n}\n", "\"use strict\"\n\nvar decodeURIComponentSafe = require(\"../util/decodeURIComponentSafe\")\n\nmodule.exports = function(string) {\n\tif (string === \"\" || string == null) return {}\n\tif (string.charAt(0) === \"?\") string = string.slice(1)\n\n\tvar entries = string.split(\"&\"), counters = {}, data = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split(\"=\")\n\t\tvar key = decodeURIComponentSafe(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponentSafe(entry[1]) : \"\"\n\n\t\tif (value === \"true\") value = true\n\t\telse if (value === \"false\") value = false\n\n\t\tvar levels = key.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data\n\t\tif (key.indexOf(\"[\") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == \"\" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tif (level === \"\") {\n\t\t\t\tvar key = levels.slice(0, j).join()\n\t\t\t\tif (counters[key] == null) {\n\t\t\t\t\tcounters[key] = Array.isArray(cursor) ? cursor.length : 0\n\t\t\t\t}\n\t\t\t\tlevel = counters[key]++\n\t\t\t}\n\t\t\t// Disallow direct prototype pollution\n\t\t\telse if (level === \"__proto__\") break\n\t\t\tif (j === levels.length - 1) cursor[level] = value\n\t\t\telse {\n\t\t\t\t// Read own properties exclusively to disallow indirect\n\t\t\t\t// prototype pollution\n\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(cursor, level)\n\t\t\t\tif (desc != null) desc = desc.value\n\t\t\t\tif (desc == null) cursor[level] = desc = isNumber ? [] : {}\n\t\t\t\tcursor = desc\n\t\t\t}\n\t\t}\n\t}\n\treturn data\n}\n", "\"use strict\"\n\nvar parseQueryString = require(\"../querystring/parse\")\n\n// Returns `{path, params}` from `url`\nmodule.exports = function(url) {\n\tvar queryIndex = url.indexOf(\"?\")\n\tvar hashIndex = url.indexOf(\"#\")\n\tvar queryEnd = hashIndex < 0 ? url.length : hashIndex\n\tvar pathEnd = queryIndex < 0 ? queryEnd : queryIndex\n\tvar path = url.slice(0, pathEnd).replace(/\\/{2,}/g, \"/\")\n\n\tif (!path) path = \"/\"\n\telse {\n\t\tif (path[0] !== \"/\") path = \"/\" + path\n\t}\n\treturn {\n\t\tpath: path,\n\t\tparams: queryIndex < 0\n\t\t\t? {}\n\t\t\t: parseQueryString(url.slice(queryIndex + 1, queryEnd)),\n\t}\n}\n", "\"use strict\"\n\nvar parsePathname = require(\"./parse\")\n\n// Compiles a template into a function that takes a resolved path (without query\n// strings) and returns an object containing the template parameters with their\n// parsed values. This expects the input of the compiled template to be the\n// output of `parsePathname`. Note that it does *not* remove query parameters\n// specified in the template.\nmodule.exports = function(template) {\n\tvar templateData = parsePathname(template)\n\tvar templateKeys = Object.keys(templateData.params)\n\tvar keys = []\n\tvar regexp = new RegExp(\"^\" + templateData.path.replace(\n\t\t// I escape literal text so people can use things like `:file.:ext` or\n\t\t// `:lang-:locale` in routes. This is all merged into one pass so I\n\t\t// don't also accidentally escape `-` and make it harder to detect it to\n\t\t// ban it from template parameters.\n\t\t/:([^\\/.-]+)(\\.{3}|\\.(?!\\.)|-)?|[\\\\^$*+.()|\\[\\]{}]/g,\n\t\tfunction(m, key, extra) {\n\t\t\tif (key == null) return \"\\\\\" + m\n\t\t\tkeys.push({k: key, r: extra === \"...\"})\n\t\t\tif (extra === \"...\") return \"(.*)\"\n\t\t\tif (extra === \".\") return \"([^/]+)\\\\.\"\n\t\t\treturn \"([^/]+)\" + (extra || \"\")\n\t\t}\n\t) + \"\\\\/?$\")\n\treturn function(data) {\n\t\t// First, check the params. Usually, there isn't any, and it's just\n\t\t// checking a static set.\n\t\tfor (var i = 0; i < templateKeys.length; i++) {\n\t\t\tif (templateData.params[templateKeys[i]] !== data.params[templateKeys[i]]) return false\n\t\t}\n\t\t// If no interpolations exist, let's skip all the ceremony\n\t\tif (!keys.length) return regexp.test(data.path)\n\t\tvar values = regexp.exec(data.path)\n\t\tif (values == null) return false\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tdata.params[keys[i].k] = keys[i].r ? values[i + 1] : decodeURIComponent(values[i + 1])\n\t\t}\n\t\treturn true\n\t}\n}\n", "\"use strict\"\n\n// Note: this is mildly perf-sensitive.\n//\n// It does *not* use `delete` - dynamic `delete`s usually cause objects to bail\n// out into dictionary mode and just generally cause a bunch of optimization\n// issues within engines.\n//\n// Ideally, I would've preferred to do this, if it weren't for the optimization\n// issues:\n//\n// ```js\n// const hasOwn = require(\"./hasOwn\")\n// const magic = [\n//     \"key\", \"oninit\", \"oncreate\", \"onbeforeupdate\", \"onupdate\",\n//     \"onbeforeremove\", \"onremove\",\n// ]\n// module.exports = (attrs, extras) => {\n//     const result = Object.assign(Object.create(null), attrs)\n//     for (const key of magic) delete result[key]\n//     if (extras != null) for (const key of extras) delete result[key]\n//     return result\n// }\n// ```\n\nvar hasOwn = require(\"./hasOwn\")\nvar magic = /^(?:key|oninit|oncreate|onbeforeupdate|onupdate|onbeforeremove|onremove)$/\n\nmodule.exports = function(attrs, extras) {\n\tvar result = {}\n\n\tif (extras != null) {\n\t\tfor (var key in attrs) {\n\t\t\tif (hasOwn.call(attrs, key) && !magic.test(key) && extras.indexOf(key) < 0) {\n\t\t\t\tresult[key] = attrs[key]\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var key in attrs) {\n\t\t\tif (hasOwn.call(attrs, key) && !magic.test(key)) {\n\t\t\t\tresult[key] = attrs[key]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\nvar hyperscript = require(\"../render/hyperscript\")\n\nvar decodeURIComponentSafe = require(\"../util/decodeURIComponentSafe\")\nvar buildPathname = require(\"../pathname/build\")\nvar parsePathname = require(\"../pathname/parse\")\nvar compileTemplate = require(\"../pathname/compileTemplate\")\nvar censor = require(\"../util/censor\")\n\nmodule.exports = function($window, mountRedraw) {\n\tvar p = Promise.resolve()\n\n\tvar scheduled = false\n\n\tvar ready = false\n\tvar hasBeenResolved = false\n\n\tvar dom, compiled, fallbackRoute\n\n\tvar currentResolver, component, attrs, currentPath, lastUpdate\n\n\tvar RouterRoot = {\n\t\tonremove: function() {\n\t\t\tready = hasBeenResolved = false\n\t\t\t$window.removeEventListener(\"popstate\", fireAsync, false)\n\t\t},\n\t\tview: function() {\n\t\t\t// The route has already been resolved.\n\t\t\t// Therefore, the following early return is not needed.\n\t\t\t// if (!hasBeenResolved) return\n\n\t\t\tvar vnode = Vnode(component, attrs.key, attrs)\n\t\t\tif (currentResolver) return currentResolver.render(vnode)\n\t\t\t// Wrap in a fragment to preserve existing key semantics\n\t\t\treturn [vnode]\n\t\t},\n\t}\n\n\tvar SKIP = route.SKIP = {}\n\n\tfunction resolveRoute() {\n\t\tscheduled = false\n\t\t// Consider the pathname holistically. The prefix might even be invalid,\n\t\t// but that's not our problem.\n\t\tvar prefix = $window.location.hash\n\t\tif (route.prefix[0] !== \"#\") {\n\t\t\tprefix = $window.location.search + prefix\n\t\t\tif (route.prefix[0] !== \"?\") {\n\t\t\t\tprefix = $window.location.pathname + prefix\n\t\t\t\tif (prefix[0] !== \"/\") prefix = \"/\" + prefix\n\t\t\t}\n\t\t}\n\t\tvar path = decodeURIComponentSafe(prefix).slice(route.prefix.length)\n\t\tvar data = parsePathname(path)\n\n\t\tObject.assign(data.params, $window.history.state)\n\n\t\tfunction reject(e) {\n\t\t\tconsole.error(e)\n\t\t\troute.set(fallbackRoute, null, {replace: true})\n\t\t}\n\n\t\tloop(0)\n\t\tfunction loop(i) {\n\t\t\tfor (; i < compiled.length; i++) {\n\t\t\t\tif (compiled[i].check(data)) {\n\t\t\t\t\tvar payload = compiled[i].component\n\t\t\t\t\tvar matchedRoute = compiled[i].route\n\t\t\t\t\tvar localComp = payload\n\t\t\t\t\tvar update = lastUpdate = function(comp) {\n\t\t\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\t\t\tif (comp === SKIP) return loop(i + 1)\n\t\t\t\t\t\tcomponent = comp != null && (typeof comp.view === \"function\" || typeof comp === \"function\")? comp : \"div\"\n\t\t\t\t\t\tattrs = data.params, currentPath = path, lastUpdate = null\n\t\t\t\t\t\tcurrentResolver = payload.render ? payload : null\n\t\t\t\t\t\tif (hasBeenResolved) mountRedraw.redraw()\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\thasBeenResolved = true\n\t\t\t\t\t\t\tmountRedraw.mount(dom, RouterRoot)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// There's no understating how much I *wish* I could\n\t\t\t\t\t// use `async`/`await` here...\n\t\t\t\t\tif (payload.view || typeof payload === \"function\") {\n\t\t\t\t\t\tpayload = {}\n\t\t\t\t\t\tupdate(localComp)\n\t\t\t\t\t}\n\t\t\t\t\telse if (payload.onmatch) {\n\t\t\t\t\t\tp.then(function () {\n\t\t\t\t\t\t\treturn payload.onmatch(data.params, path, matchedRoute)\n\t\t\t\t\t\t}).then(update, path === fallbackRoute ? null : reject)\n\t\t\t\t\t}\n\t\t\t\t\telse update(/* \"div\" */)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (path === fallbackRoute) {\n\t\t\t\tthrow new Error(\"Could not resolve default route \" + fallbackRoute + \".\")\n\t\t\t}\n\t\t\troute.set(fallbackRoute, null, {replace: true})\n\t\t}\n\t}\n\n\tfunction fireAsync() {\n\t\tif (!scheduled) {\n\t\t\tscheduled = true\n\t\t\t// TODO: just do `mountRedraw.redraw()` here and elide the timer\n\t\t\t// dependency. Note that this will muck with tests a *lot*, so it's\n\t\t\t// not as easy of a change as it sounds.\n\t\t\tsetTimeout(resolveRoute)\n\t\t}\n\t}\n\n\tfunction route(root, defaultRoute, routes) {\n\t\tif (!root) throw new TypeError(\"DOM element being rendered to does not exist.\")\n\n\t\tcompiled = Object.keys(routes).map(function(route) {\n\t\t\tif (route[0] !== \"/\") throw new SyntaxError(\"Routes must start with a '/'.\")\n\t\t\tif ((/:([^\\/\\.-]+)(\\.{3})?:/).test(route)) {\n\t\t\t\tthrow new SyntaxError(\"Route parameter names must be separated with either '/', '.', or '-'.\")\n\t\t\t}\n\t\t\treturn {\n\t\t\t\troute: route,\n\t\t\t\tcomponent: routes[route],\n\t\t\t\tcheck: compileTemplate(route),\n\t\t\t}\n\t\t})\n\t\tfallbackRoute = defaultRoute\n\t\tif (defaultRoute != null) {\n\t\t\tvar defaultData = parsePathname(defaultRoute)\n\n\t\t\tif (!compiled.some(function (i) { return i.check(defaultData) })) {\n\t\t\t\tthrow new ReferenceError(\"Default route doesn't match any known routes.\")\n\t\t\t}\n\t\t}\n\t\tdom = root\n\n\t\t$window.addEventListener(\"popstate\", fireAsync, false)\n\n\t\tready = true\n\n\t\t// The RouterRoot component is mounted when the route is first resolved.\n\t\tresolveRoute()\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\n\t\tpath = buildPathname(path, data)\n\t\tif (ready) {\n\t\t\tfireAsync()\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, route.prefix + path)\n\t\t\telse $window.history.pushState(state, title, route.prefix + path)\n\t\t}\n\t\telse {\n\t\t\t$window.location.href = route.prefix + path\n\t\t}\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = \"#!\"\n\troute.Link = {\n\t\tview: function(vnode) {\n\t\t\t// Omit the used parameters from the rendered element - they are\n\t\t\t// internal. Also, censor the various lifecycle methods.\n\t\t\t//\n\t\t\t// We don't strip the other parameters because for convenience we\n\t\t\t// let them be specified in the selector as well.\n\t\t\tvar child = hyperscript(\n\t\t\t\tvnode.attrs.selector || \"a\",\n\t\t\t\tcensor(vnode.attrs, [\"options\", \"params\", \"selector\", \"onclick\"]),\n\t\t\t\tvnode.children\n\t\t\t)\n\t\t\tvar options, onclick, href\n\n\t\t\t// Let's provide a *right* way to disable a route link, rather than\n\t\t\t// letting people screw up accessibility on accident.\n\t\t\t//\n\t\t\t// The attribute is coerced so users don't get surprised over\n\t\t\t// `disabled: 0` resulting in a button that's somehow routable\n\t\t\t// despite being visibly disabled.\n\t\t\tif (child.attrs.disabled = Boolean(child.attrs.disabled)) {\n\t\t\t\tchild.attrs.href = null\n\t\t\t\tchild.attrs[\"aria-disabled\"] = \"true\"\n\t\t\t\t// If you *really* do want add `onclick` on a disabled link, use\n\t\t\t\t// an `oncreate` hook to add it.\n\t\t\t} else {\n\t\t\t\toptions = vnode.attrs.options\n\t\t\t\tonclick = vnode.attrs.onclick\n\t\t\t\t// Easier to build it now to keep it isomorphic.\n\t\t\t\thref = buildPathname(child.attrs.href, vnode.attrs.params)\n\t\t\t\tchild.attrs.href = route.prefix + href\n\t\t\t\tchild.attrs.onclick = function(e) {\n\t\t\t\t\tvar result\n\t\t\t\t\tif (typeof onclick === \"function\") {\n\t\t\t\t\t\tresult = onclick.call(e.currentTarget, e)\n\t\t\t\t\t} else if (onclick == null || typeof onclick !== \"object\") {\n\t\t\t\t\t\t// do nothing\n\t\t\t\t\t} else if (typeof onclick.handleEvent === \"function\") {\n\t\t\t\t\t\tonclick.handleEvent(e)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Adapted from React Router's implementation:\n\t\t\t\t\t// https://github.com/ReactTraining/react-router/blob/520a0acd48ae1b066eb0b07d6d4d1790a1d02482/packages/react-router-dom/modules/Link.js\n\t\t\t\t\t//\n\t\t\t\t\t// Try to be flexible and intuitive in how we handle links.\n\t\t\t\t\t// Fun fact: links aren't as obvious to get right as you\n\t\t\t\t\t// would expect. There's a lot more valid ways to click a\n\t\t\t\t\t// link than this, and one might want to not simply click a\n\t\t\t\t\t// link, but right click or command-click it to copy the\n\t\t\t\t\t// link target, etc. Nope, this isn't just for blind people.\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Skip if `onclick` prevented default\n\t\t\t\t\t\tresult !== false && !e.defaultPrevented &&\n\t\t\t\t\t\t// Ignore everything but left clicks\n\t\t\t\t\t\t(e.button === 0 || e.which === 0 || e.which === 1) &&\n\t\t\t\t\t\t// Let the browser handle `target=_blank`, etc.\n\t\t\t\t\t\t(!e.currentTarget.target || e.currentTarget.target === \"_self\") &&\n\t\t\t\t\t\t// No modifier keys\n\t\t\t\t\t\t!e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey\n\t\t\t\t\t) {\n\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\te.redraw = false\n\t\t\t\t\t\troute.set(href, null, options)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn child\n\t\t},\n\t}\n\troute.param = function(key) {\n\t\treturn attrs && key != null ? attrs[key] : attrs\n\t}\n\n\treturn route\n}\n", "\"use strict\"\n\nvar mountRedraw = require(\"./mount-redraw\")\n\nmodule.exports = require(\"./api/router\")(typeof window !== \"undefined\" ? window : null, mountRedraw)\n", "\"use strict\"\n\nvar hyperscript = require(\"./hyperscript\")\nvar mountRedraw = require(\"./mount-redraw\")\nvar request = require(\"./request\")\nvar router = require(\"./route\")\n\nvar m = function m() { return hyperscript.apply(this, arguments) }\nm.m = hyperscript\nm.trust = hyperscript.trust\nm.fragment = hyperscript.fragment\nm.Fragment = \"[\"\nm.mount = mountRedraw.mount\nm.route = router\nm.render = require(\"./render\")\nm.redraw = mountRedraw.redraw\nm.request = request.request\nm.parseQueryString = require(\"./querystring/parse\")\nm.buildQueryString = require(\"./querystring/build\")\nm.parsePathname = require(\"./pathname/parse\")\nm.buildPathname = require(\"./pathname/build\")\nm.vnode = require(\"./render/vnode\")\nm.censor = require(\"./util/censor\")\nm.domFor = require(\"./render/domFor\")\n\nmodule.exports = m\n", "import m from \"mithril\";\nimport {\n  AboutApp,\n  AlbumApp,\n  AlbumsApp,\n  ListingApp,\n  ListingsApp,\n  PhotoApp,\n  PhotosApp,\n  ThingApp,\n  VideosApp,\n} from \"./app.ts\";\n\nm.route(document.body, \"/albums\", {\n  \"/albums\": AlbumsApp,\n  \"/about\": AboutApp,\n  \"/videos\": VideosApp,\n  \"/photos\": PhotosApp,\n  \"/album/:id\": AlbumApp,\n  \"/thing/:pair\": ThingApp,\n  \"/photo/:id\": PhotoApp,\n  \"/listing/:type\": ListingApp,\n  \"/listings\": ListingsApp,\n});\n", "/*\n * Mithril's Router wants components, so for the moment each page has a\n * wrapper app.\n */\n\nimport m from \"mithril\";\nimport { Header } from \"./components/header.ts\";\nimport { loadState } from \"./state.ts\";\nimport { Sidebar } from \"./components/sidebar.ts\";\nimport { AlbumsPage } from \"./pages/albums.ts\";\nimport {\n  readAlbumPhotosByAlbumId,\n  readAlbumVideosByAlbumId,\n  readAllAlbums,\n  readThingsByAlbumId,\n} from \"./services/albums.ts\";\nimport { AboutPage } from \"./pages/about.ts\";\nimport { VideosPage } from \"./pages/videos.ts\";\nimport { readAllVideos } from \"./services/videos.ts\";\nimport { listen } from \"./commons/events.ts\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport type { TripleObject } from \"@rgrannell1/tribbledb\";\nimport { AlbumPage } from \"./pages/album.ts\";\nimport { PhotosPage } from \"./pages/photos.ts\";\nimport { PhotoPage } from \"./pages/photo.ts\";\nimport { readAllPhotos } from \"./services/photos.ts\";\nimport { readAlbum, readPhoto } from \"./services/readers.ts\";\nimport { ListingPage } from \"./pages/listing.ts\";\nimport { ListingsPage } from \"./pages/listings.ts\";\nimport { readNamedTypeThings, readThing } from \"./commons/things.ts\";\nimport type { Album } from \"./types.ts\";\nimport { ThingPage } from \"./pages/thing.ts\";\n\ntype AppAttrs = {};\nconst state = await loadState();\n\nlisten(\"navigate\", (event: Event) => {\n  const { route } = (event as CustomEvent).detail;\n  console.info(`navigating to route: ${route}`);\n\n  state.sidebarVisible = false;\n  m.route.set(route);\n});\n\nlisten(\"switch_theme\", () => {\n  state.darkMode = !state.darkMode;\n});\n\nlisten(\"click_burger_menu\", () => {\n  state.sidebarVisible = !state.sidebarVisible;\n});\n\n/* */\nexport function AlbumsApp(): m.Component<AppAttrs> {\n  return {\n    oninit() {\n    },\n    view() {\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(AlbumsPage, {\n              albums: readAllAlbums(state.data),\n              services: state.services,\n              visible: state.sidebarVisible,\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function AlbumApp(): m.Component<AppAttrs> {\n  return {\n    oninit() {\n      const id = m.route.param(\"id\");\n      state.currentAlbum = `urn:r\u00F3:album:${id}`;\n    },\n    view() {\n      if (!state.currentAlbum) {\n        return m(\"p\", \"No album selected\");\n      }\n      const album = readAlbum(state.data, state.currentAlbum) as Album;\n      const photos = readAlbumPhotosByAlbumId(state.data, state.currentAlbum);\n      const videos = readAlbumVideosByAlbumId(state.data, state.currentAlbum);\n\n      if (!album) {\n        return m(\"p\", \"Album not found\");\n      }\n\n      const { subjects, locations } = readThingsByAlbumId(\n        state.data,\n        state.currentAlbum,\n      );\n\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(AlbumPage, {\n              album,\n              subjects,\n              country: album.country || [],\n              locations,\n              photos,\n              videos,\n              services: state.services,\n              visible: state.sidebarVisible,\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function AboutApp(): m.Component<AppAttrs> {\n  return {\n    view() {\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(AboutPage, { visible: state.sidebarVisible }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function VideosApp(): m.Component<AppAttrs> {\n  return {\n    view() {\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(VideosPage, {\n              videos: readAllVideos(state.data),\n              visible: state.sidebarVisible,\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function PhotosApp(): m.Component<AppAttrs> {\n  return {\n    view() {\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(PhotosPage, {\n              photos: readAllPhotos(state.data),\n              visible: state.sidebarVisible,\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function ThingApp(): m.Component<AppAttrs> {\n  let things: TripleObject[] = [];\n\n  return {\n    view() {\n      const pair = m.route.param(\"pair\");\n      state.currentUrn = `urn:r\u00F3:${pair}`;\n\n      const parsed = asUrn(state.currentUrn);\n      if (parsed.id === \"*\") {\n        things = readNamedTypeThings(state.data, pair.split(\":\")[0]);\n      } else {\n        const thing = readThing(state.data, state.currentUrn);\n        if (thing) {\n          things = [thing];\n        }\n      }\n\n      if (!state.currentUrn) {\n        return m(\"p\", \"No thing selected\");\n      }\n\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(ThingPage, {\n              urn: state.currentUrn,\n              things,\n              services: state.services,\n              visible: state.sidebarVisible,\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function PhotoApp(): m.Component<AppAttrs> {\n  return {\n    oninit() {\n      const id = m.route.param(\"id\");\n      state.currentPhoto = `urn:r\u00F3:photo:${id}`;\n    },\n    view() {\n      if (!state.currentPhoto) {\n        return m(\"p\", \"No photo selected\");\n      }\n      const photo = readPhoto(state.data, state.currentPhoto);\n\n      if (!photo) {\n        return m(\"p\", \"Photo not found\");\n      }\n\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(PhotoPage, { photo, services: state.services, visible: state.sidebarVisible }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function ListingApp(): m.Component<AppAttrs> {\n  return {\n    oninit() {\n      const type = m.route.param(\"type\");\n      state.currentType = type;\n    },\n\n    view() {\n      if (!state.currentType) {\n        return m(\"p\", \"No type selected\");\n      }\n\n      const things = readNamedTypeThings(state.data, state.currentType);\n\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(ListingPage, {\n              type: state.currentType,\n              things,\n              services: state.services,\n              visible: state.sidebarVisible,\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\nexport function ListingsApp(): m.Component<AppAttrs> {\n  return {\n    view() {\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(ListingsPage, { visible: state.sidebarVisible }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { broadcast, navigate } from \"../commons/events.ts\";\n\ntype HeaderAttrs = {\n  darkMode: boolean;\n};\n\n/*\n * The sidebar menu\n */\nfunction BurgerMenu() {\n  const onclick = (_: Event) => {\n    broadcast(\"click_burger_menu\", {});\n  };\n\n  return {\n    view() {\n      return m(\"a\", { onclick }, m(\"span.burger\", \"\u039E\"));\n    },\n  };\n}\n\n/*\n * The link to the homepage\n */\nfunction HeaderBrandText() {\n  const BRAND_TEXT = \"photos\";\n\n  return {\n    view() {\n      return m(\"a\", {\n        href: \"#/\",\n        onclick: navigate(\"/\"),\n      }, m(\"span.brand\", BRAND_TEXT));\n    },\n  };\n}\n\n/*\n * The RSS icon. Roughly, \uD83D\uDEDC\n */\nfunction RSSIcon() {\n  const SVG_PATH = m(\"path\", {\n    fill: \"#ff9132\",\n    d: \"M 4.259,23.467c-2.35,0-4.259,1.917-4.259,4.252c0,2.349, 1.909,4.244, 4.259,4.244 c 2.358,0, 4.265-1.895, 4.265-4.244C 8.525,25.383, 6.618,23.467, 4.259,23.467zM 0.005,10.873l0,6.133 c 3.993,0, 7.749,1.562, 10.577,4.391c 2.825,2.822, 4.384,6.595, 4.384,10.603l 6.16,0 C 21.125,20.349, 11.648,10.873, 0.005,10.873zM 0.012,0l0,6.136 c 14.243,0, 25.836,11.604, 25.836,25.864L 32,32 C 32,14.36, 17.648,0, 0.012,0z\",\n  });\n\n  return {\n    view() {\n      return m(\n        \"a.rss\",\n        { title: \"rss\", href: \"/manifest/atom/atom-index.xml\" },\n        [\n          m(\"svg\", {\n            alt: \"rss\",\n            width: \"25px\",\n            height: \"25px\",\n            viewBox: \"0 0 32 32\",\n            style: \"position: relative; top: 5px;\",\n          }, [\n            SVG_PATH,\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nfunction ThemeSwitch() {\n  return {\n    view(vnode: m.Vnode<HeaderAttrs>) {\n      const text = vnode.attrs.darkMode ? \"\u2600\uFE0F\" : \"\uD83C\uDF19\";\n\n      return m(\n        \"a\",\n        {},\n        m(\"span.brand.switch\", {\n          onclick: () => {\n            broadcast(\"switch_theme\", {});\n          },\n        }, text),\n      );\n    },\n  };\n}\n\n/* */\nexport function Header() {\n  return {\n    view(vnode: m.Vnode<HeaderAttrs>) {\n      return m(\"nav.header\", { role: \"navigation\" }, [\n        // TODO this is a bad fix to an unknown reversion which messed up header item placement\n        // ideally we should find out what's actually wrong with the css, but for now...\n        // also, it doesn't work properly in Chrome\n        m(\"ul\", { style: \"display: ruby\" }, [\n          m(\"li.header-item\", {}, m(BurgerMenu())),\n          m(\"li.header-item\", {}, m(HeaderBrandText())),\n          m(\"li.rss-tag header-item\", { style: \"float: right\" }, m(RSSIcon())),\n          m(\n            \"li.header-item\",\n            { style: \"float: right\" },\n            m(ThemeSwitch(), {\n              darkMode: vnode.attrs.darkMode,\n            }),\n          ),\n        ]),\n      ]);\n    },\n  };\n}\n", "/*\n * Handle state-updates in response to events by delegating to other services. Handles\n * state-updates and rerenders.\n */\n\nimport type { ApplicationEvents } from \"../types.ts\";\n\n/*\n * Broadcast a custom application event to the document.\n */\nexport function broadcast(\n  label: ApplicationEvents,\n  detail: CustomEvent[\"detail\"],\n) {\n  console.info(`broadcasting event: ${label}`, detail);\n\n  (window as any).document.dispatchEvent(\n    new CustomEvent(label, {\n      detail,\n    }),\n  );\n}\n\n/*\n * Listen for custom application events.\n */\nexport function listen(\n  label: ApplicationEvents,\n  callback: (event: Event) => void,\n) {\n  (window as any).document.addEventListener(label, callback);\n}\n\n/*\n * Prevent default action for an event.\n *\n * @param event The event to block.\n */\nexport function block(event: Event) {\n  event?.preventDefault();\n}\n\n/*\n * Broadcast a navigation event and block the default action.\n *\n * @param route The route to navigate to.\n */\nexport function navigate(route: string) {\n  return (event: Event) => {\n    broadcast(\"navigate\", { route });\n    block(event);\n  };\n}\n", "/*\n * Manages dark mode preference in local storage\n */\nexport function load() {\n  return localStorage.getItem(\"darkMode\") === \"true\";\n}\n\nexport function save(value: boolean) {\n  return localStorage.setItem(\"darkMode\", `${value}`);\n}\n", "// src/sets.ts\nvar IndexedSet = class _IndexedSet {\n  #idx;\n  #map;\n  #reverseMap;\n  constructor() {\n    this.#idx = 0;\n    this.#map = /* @__PURE__ */ new Map();\n    this.#reverseMap = /* @__PURE__ */ new Map();\n  }\n  /*\n   * Return the underlying map of values to indices\n   */\n  map() {\n    return this.#map;\n  }\n  /*\n   * Return the underlying map of indices to values\n   */\n  reverseMap() {\n    return this.#reverseMap;\n  }\n  /*\n   * Add a value to the set, and return its index\n   */\n  add(value) {\n    if (this.#map.has(value)) {\n      return this.#map.get(value);\n    }\n    this.#map.set(value, this.#idx);\n    this.#reverseMap.set(this.#idx, value);\n    this.#idx++;\n    return this.#idx - 1;\n  }\n  /**\n   * Set the index for a value in the set\n   */\n  setIndex(value, index) {\n    this.#map.set(value, index);\n    this.#reverseMap.set(index, value);\n  }\n  /**\n   * Get the index for a value in the set\n   */\n  getIndex(value) {\n    return this.#map.get(value);\n  }\n  /**\n   * Set the values for an index in the set\n   */\n  getValue(idx) {\n    return this.#reverseMap.get(idx);\n  }\n  /**\n   * Does this structure have a value?\n   */\n  has(value) {\n    return this.#map.has(value);\n  }\n  clone() {\n    const newSet = new _IndexedSet();\n    for (const [key, value] of this.#map.entries()) {\n      newSet.setIndex(key, value);\n    }\n    return newSet;\n  }\n};\n\n// src/tribble/parse.ts\nvar TribbleParser = class {\n  stringIndex;\n  constructor() {\n    this.stringIndex = new IndexedSet();\n  }\n  /*\n   * Parse a triple-line of tribble format text, and return a triple\n   */\n  parseTriple(line) {\n    const match = line.match(/^(\\d+) (\\d+) (\\d+)$/);\n    if (!match) {\n      throw new SyntaxError(`Invalid format for triple line: ${line}`);\n    }\n    const src = this.stringIndex.getValue(parseInt(match[1], 10));\n    const rel = this.stringIndex.getValue(parseInt(match[2], 10));\n    const tgt = this.stringIndex.getValue(parseInt(match[3], 10));\n    if (src === void 0 || rel === void 0 || tgt === void 0) {\n      throw new SyntaxError(`Invalid triple reference: ${line}`);\n    }\n    return [src, rel, tgt];\n  }\n  /*\n   * Parse a declaration line of tribble format text, and\n   * update the index.\n   */\n  parseDeclaration(line) {\n    const match = line.match(/^(\\d+) \"(.*)\"$/);\n    if (!match) {\n      throw new SyntaxError(`Invalid format for declaration line: ${line}`);\n    }\n    const id = match[1];\n    const value = match[2];\n    this.stringIndex.setIndex(value, parseInt(id, 10));\n  }\n  /*\n   * Parse a line of tribble format text, and return a triple when possible. Otherwise\n   * update the index.\n   */\n  parse(line) {\n    const isTriple = /^(\\d+)\\s(\\d+)\\s(\\d+)$/;\n    if (isTriple.test(line)) {\n      return this.parseTriple(line);\n    } else {\n      this.parseDeclaration(line);\n      return;\n    }\n  }\n};\n\n// src/tribble/stringify.ts\nvar TribbleStringifier = class {\n  stringIndex;\n  constructor() {\n    this.stringIndex = new IndexedSet();\n  }\n  /*\n   * Convert a triple to tribble format and return the encoding.\n   */\n  stringify(triple) {\n    const message = [];\n    const [source, relation, target] = triple;\n    for (const value of triple) {\n      if (!this.stringIndex.has(value)) {\n        const newId = this.stringIndex.add(value);\n        const stringifiedValue = value === \"null\" || value === null ? JSON.stringify(\"null\") : JSON.stringify(value.toString());\n        message.push(`${newId} ${stringifiedValue}`);\n      }\n    }\n    message.push(\n      `${this.stringIndex.getIndex(source)} ${this.stringIndex.getIndex(relation)} ${this.stringIndex.getIndex(target)}`\n    );\n    return message.join(\"\\n\");\n  }\n};\n\n// src/urn.ts\nfunction parseUrn(urn) {\n  const delimited = urn.split(\":\", 4);\n  const type = delimited[2];\n  const remainder = delimited[3] ?? \"\";\n  const idx = remainder.indexOf(\"?\");\n  const queryString = idx !== -1 ? remainder.slice(idx + 1) : \"\";\n  const id = idx !== -1 ? remainder.slice(0, idx) : remainder;\n  const qs = queryString ? Object.fromEntries(new URLSearchParams(queryString)) : {};\n  return {\n    type,\n    id,\n    qs\n  };\n}\nfunction asUrn(value, namespace = \"r\\xF3\") {\n  if (typeof value !== \"string\" || !value.startsWith(`urn:${namespace}:`)) {\n    return {\n      type: \"unknown\",\n      id: value,\n      qs: {}\n    };\n  }\n  return parseUrn(value);\n}\n\n// src/metrics.ts\nvar IndexPerformanceMetrics = class _IndexPerformanceMetrics {\n  mapReadCount;\n  constructor() {\n    this.mapReadCount = 0;\n  }\n  mapRead() {\n    this.mapReadCount++;\n  }\n  clone() {\n    const clone = new _IndexPerformanceMetrics();\n    clone.mapReadCount = this.mapReadCount;\n    return clone;\n  }\n};\n\n// src/hash.ts\nfunction hashTriple(triple) {\n  const [src, rel, tgt] = triple;\n  let hashValue = 0;\n  for (let i = 0; i < src.length; i++) {\n    hashValue = (hashValue << 5) - hashValue + src.charCodeAt(i);\n    hashValue |= 0;\n  }\n  for (let i = 0; i < rel.length; i++) {\n    hashValue = (hashValue << 5) - hashValue + rel.charCodeAt(i);\n    hashValue |= 0;\n  }\n  for (let i = 0; i < tgt.length; i++) {\n    hashValue = (hashValue << 5) - hashValue + tgt.charCodeAt(i);\n    hashValue |= 0;\n  }\n  return hashValue.toString();\n}\n\n// src/indices/index.ts\nvar Index = class _Index {\n  // Internal indexed representation for memory efficiency\n  indexedTriples;\n  // Metadata cache for efficient deletion\n  tripleMetadata;\n  // String indexing sets for memory efficiency\n  stringIndex;\n  tripleHashes;\n  hashIndices;\n  sourceType;\n  sourceId;\n  // note: QS uses a composite key: <key>=<value>\n  sourceQs;\n  relations;\n  targetType;\n  targetId;\n  targetQs;\n  metrics;\n  stringUrn;\n  constructor(triples) {\n    this.indexedTriples = [];\n    this.tripleMetadata = /* @__PURE__ */ new Map();\n    this.stringIndex = new IndexedSet();\n    this.tripleHashes = /* @__PURE__ */ new Set();\n    this.hashIndices = /* @__PURE__ */ new Map();\n    this.sourceType = /* @__PURE__ */ new Map();\n    this.sourceId = /* @__PURE__ */ new Map();\n    this.sourceQs = /* @__PURE__ */ new Map();\n    this.relations = /* @__PURE__ */ new Map();\n    this.targetType = /* @__PURE__ */ new Map();\n    this.targetId = /* @__PURE__ */ new Map();\n    this.targetQs = /* @__PURE__ */ new Map();\n    this.stringUrn = /* @__PURE__ */ new Map();\n    this.add(triples);\n    this.metrics = new IndexPerformanceMetrics();\n  }\n  /*\n   * Delete triples from the index\n   */\n  delete(triples) {\n    for (let idx = 0; idx < triples.length; idx++) {\n      const triple = triples[idx];\n      const tripleHash = hashTriple(triple);\n      const tripleIndex = this.hashIndices.get(tripleHash);\n      if (tripleIndex === void 0) {\n        continue;\n      }\n      this.tripleHashes.delete(tripleHash);\n      this.hashIndices.delete(tripleHash);\n      const metadata = this.tripleMetadata.get(tripleIndex);\n      if (metadata) {\n        this.sourceType.get(metadata.sourceTypeIdx)?.delete(tripleIndex);\n        this.sourceId.get(metadata.sourceIdIdx)?.delete(tripleIndex);\n        this.relations.get(metadata.relation)?.delete(tripleIndex);\n        this.targetType.get(metadata.targetTypeIdx)?.delete(tripleIndex);\n        this.targetId.get(metadata.targetIdIdx)?.delete(tripleIndex);\n        for (const qsIdx of metadata.sourceQsIndices) {\n          this.sourceQs.get(qsIdx)?.delete(tripleIndex);\n        }\n        for (const qsIdx of metadata.targetQsIndices) {\n          this.targetQs.get(qsIdx)?.delete(tripleIndex);\n        }\n        this.tripleMetadata.delete(tripleIndex);\n      }\n      delete this.indexedTriples[tripleIndex];\n    }\n  }\n  /*\n   * Return the triples that are absent from the index\n   */\n  difference(triples) {\n    return triples.filter((triple) => !this.hasTriple(triple));\n  }\n  /*\n   * Check if a triple is present in the index\n   */\n  hasTriple(triple) {\n    return this.tripleHashes.has(hashTriple(triple));\n  }\n  /*\n   * Get the index of a specific triple\n   */\n  getTripleIndex(triple) {\n    const hash = hashTriple(triple);\n    return this.hashIndices.get(hash);\n  }\n  /*\n   * Add new triples to the index incrementally\n   */\n  add(triples) {\n    for (let jdx = 0; jdx < triples.length; jdx++) {\n      const triple = triples[jdx];\n      const source = triple[0];\n      const relation = triple[1];\n      const target = triple[2];\n      let parsedSource = this.stringUrn.get(source);\n      if (!parsedSource) {\n        parsedSource = asUrn(source);\n        this.stringUrn.set(source, parsedSource);\n      }\n      let parsedTarget = this.stringUrn.get(target);\n      if (!parsedTarget) {\n        parsedTarget = asUrn(target);\n        this.stringUrn.set(target, parsedTarget);\n      }\n      const sourceIdx = this.stringIndex.add(source);\n      const targetIdx = this.stringIndex.add(target);\n      const sourceTypeIdx = this.stringIndex.add(parsedSource.type);\n      const sourceIdIdx = this.stringIndex.add(parsedSource.id);\n      const targetTypeIdx = this.stringIndex.add(parsedTarget.type);\n      const targetIdIdx = this.stringIndex.add(parsedTarget.id);\n      const hash = hashTriple(triple);\n      if (this.tripleHashes.has(hash)) {\n        continue;\n      }\n      this.tripleHashes.add(hash);\n      const idx = this.indexedTriples.length;\n      this.hashIndices.set(hash, idx);\n      this.indexedTriples.push([sourceIdx, relation, targetIdx]);\n      const sourceQsIndices = [];\n      const targetQsIndices = [];\n      let sourceTypeSet = this.sourceType.get(sourceTypeIdx);\n      if (!sourceTypeSet) {\n        sourceTypeSet = /* @__PURE__ */ new Set();\n        this.sourceType.set(sourceTypeIdx, sourceTypeSet);\n      }\n      sourceTypeSet.add(idx);\n      let sourceIdSet = this.sourceId.get(sourceIdIdx);\n      if (!sourceIdSet) {\n        sourceIdSet = /* @__PURE__ */ new Set();\n        this.sourceId.set(sourceIdIdx, sourceIdSet);\n      }\n      sourceIdSet.add(idx);\n      for (const [key, val] of Object.entries(parsedSource.qs)) {\n        const qsIdx = this.stringIndex.add(`${key}=${val}`);\n        sourceQsIndices.push(qsIdx);\n        let sourceQsSet = this.sourceQs.get(qsIdx);\n        if (!sourceQsSet) {\n          sourceQsSet = /* @__PURE__ */ new Set();\n          this.sourceQs.set(qsIdx, sourceQsSet);\n        }\n        sourceQsSet.add(idx);\n      }\n      let relationSet = this.relations.get(relation);\n      if (!relationSet) {\n        relationSet = /* @__PURE__ */ new Set();\n        this.relations.set(relation, relationSet);\n      }\n      relationSet.add(idx);\n      let targetTypeSet = this.targetType.get(targetTypeIdx);\n      if (!targetTypeSet) {\n        targetTypeSet = /* @__PURE__ */ new Set();\n        this.targetType.set(targetTypeIdx, targetTypeSet);\n      }\n      targetTypeSet.add(idx);\n      let targetIdSet = this.targetId.get(targetIdIdx);\n      if (!targetIdSet) {\n        targetIdSet = /* @__PURE__ */ new Set();\n        this.targetId.set(targetIdIdx, targetIdSet);\n      }\n      targetIdSet.add(idx);\n      for (const [key, val] of Object.entries(parsedTarget.qs)) {\n        const qsIdx = this.stringIndex.add(`${key}=${val}`);\n        targetQsIndices.push(qsIdx);\n        let targetQsSet = this.targetQs.get(qsIdx);\n        if (!targetQsSet) {\n          targetQsSet = /* @__PURE__ */ new Set();\n          this.targetQs.set(qsIdx, targetQsSet);\n        }\n        targetQsSet.add(idx);\n      }\n      this.tripleMetadata.set(idx, {\n        sourceTypeIdx,\n        sourceIdIdx,\n        sourceQsIndices,\n        relation,\n        targetTypeIdx,\n        targetIdIdx,\n        targetQsIndices\n      });\n    }\n    return this;\n  }\n  /*\n   * Get the number of triples in the index\n   */\n  get length() {\n    return this.tripleHashes.size;\n  }\n  /*\n   * Get the actual array length including gaps (for cursor index management)\n   */\n  get arrayLength() {\n    return this.indexedTriples.length;\n  }\n  /*\n   * Reconstruct the original triples from the indexed representation\n   */\n  triples() {\n    return this.indexedTriples.filter((triple) => triple !== void 0).map(([sourceIdx, relation, targetIdx]) => [\n      this.stringIndex.getValue(sourceIdx),\n      relation,\n      this.stringIndex.getValue(targetIdx)\n    ]);\n  }\n  /*\n   * Get a specific triple by index\n   */\n  getTriple(index) {\n    if (index < 0 || index >= this.indexedTriples.length) {\n      return void 0;\n    }\n    const indexedTriple = this.indexedTriples[index];\n    if (!indexedTriple) {\n      return void 0;\n    }\n    const [sourceIdx, relation, targetIdx] = indexedTriple;\n    return [\n      this.stringIndex.getValue(sourceIdx),\n      relation,\n      this.stringIndex.getValue(targetIdx)\n    ];\n  }\n  /*\n   * Get the string indices for a specific triple by triple index\n   */\n  getTripleIndices(index) {\n    if (index < 0 || index >= this.indexedTriples.length) {\n      return void 0;\n    }\n    return this.indexedTriples[index];\n  }\n  /*\n   * Helper methods to convert string keys to indices for external API compatibility\n   */\n  getSourceTypeSet(type) {\n    const typeIdx = this.stringIndex.getIndex(type);\n    if (typeIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.sourceType.get(typeIdx);\n  }\n  getSourceIdSet(id) {\n    const idIdx = this.stringIndex.getIndex(id);\n    if (idIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.sourceId.get(idIdx);\n  }\n  getSourceQsSet(key, val) {\n    const qsIdx = this.stringIndex.getIndex(`${key}=${val}`);\n    if (qsIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.sourceQs.get(qsIdx);\n  }\n  getRelationSet(relation) {\n    this.metrics.mapRead();\n    return this.relations.get(relation);\n  }\n  getTargetTypeSet(type) {\n    const typeIdx = this.stringIndex.getIndex(type);\n    if (typeIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.targetType.get(typeIdx);\n  }\n  getTargetIdSet(id) {\n    const idIdx = this.stringIndex.getIndex(id);\n    if (idIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.targetId.get(idIdx);\n  }\n  getTargetQsSet(key, val) {\n    const qsIdx = this.stringIndex.getIndex(`${key}=${val}`);\n    if (qsIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.targetQs.get(qsIdx);\n  }\n  /*\n   * Get all unique source strings\n   */\n  getUniqueSources() {\n    const uniqueSourceIndices = /* @__PURE__ */ new Set();\n    for (const triple of this.indexedTriples) {\n      if (triple !== void 0) {\n        uniqueSourceIndices.add(triple[0]);\n      }\n    }\n    const sources = /* @__PURE__ */ new Set();\n    for (const sourceIdx of uniqueSourceIndices) {\n      const sourceStr = this.stringIndex.getValue(sourceIdx);\n      if (sourceStr !== void 0) {\n        sources.add(sourceStr);\n      }\n    }\n    return sources;\n  }\n  /*\n   * Get all unique relation strings\n   */\n  getUniqueRelations() {\n    return new Set(this.relations.keys());\n  }\n  /*\n   * Get all unique target strings\n   */\n  getUniqueTargets() {\n    const uniqueTargetIndices = /* @__PURE__ */ new Set();\n    for (const triple of this.indexedTriples) {\n      if (triple !== void 0) {\n        uniqueTargetIndices.add(triple[2]);\n      }\n    }\n    const targets = /* @__PURE__ */ new Set();\n    for (const targetIdx of uniqueTargetIndices) {\n      const targetStr = this.stringIndex.getValue(targetIdx);\n      if (targetStr !== void 0) {\n        targets.add(targetStr);\n      }\n    }\n    return targets;\n  }\n  /*\n   * Deep-clone the index\n   */\n  clone() {\n    const newIndex = new _Index([]);\n    newIndex.indexedTriples = this.indexedTriples.slice();\n    newIndex.tripleMetadata = new Map(this.tripleMetadata);\n    newIndex.stringIndex = this.stringIndex.clone();\n    newIndex.tripleHashes = new Set(this.tripleHashes);\n    newIndex.hashIndices = new Map(this.hashIndices);\n    const cloneMap = (original) => {\n      const newMap = /* @__PURE__ */ new Map();\n      for (const [key, valueSet] of original.entries()) {\n        newMap.set(key, new Set(valueSet));\n      }\n      return newMap;\n    };\n    const cloneRelationMap = (original) => {\n      const newMap = /* @__PURE__ */ new Map();\n      for (const [key, valueSet] of original.entries()) {\n        newMap.set(key, new Set(valueSet));\n      }\n      return newMap;\n    };\n    newIndex.sourceType = cloneMap(this.sourceType);\n    newIndex.sourceId = cloneMap(this.sourceId);\n    newIndex.sourceQs = cloneMap(this.sourceQs);\n    newIndex.relations = cloneRelationMap(this.relations);\n    newIndex.targetType = cloneMap(this.targetType);\n    newIndex.targetId = cloneMap(this.targetId);\n    newIndex.targetQs = cloneMap(this.targetQs);\n    newIndex.stringUrn = new Map(this.stringUrn);\n    newIndex.metrics = this.metrics.clone();\n    return newIndex;\n  }\n};\n\n// src/db/inputs.ts\nfunction isUrn(value) {\n  return value.startsWith(`urn:`);\n}\nfunction parseNodeSearch(search) {\n  if (typeof search === \"string\") {\n    return isUrn(search) ? [asUrn(search)] : [{\n      type: \"unknown\",\n      id: search\n    }];\n  }\n  if (Array.isArray(search)) {\n    return search.map((subsearch) => {\n      return isUrn(subsearch) ? asUrn(subsearch) : {\n        type: \"unknown\",\n        id: subsearch\n      };\n    });\n  }\n  return [search];\n}\nfunction parseRelation(search) {\n  return typeof search === \"string\" || Array.isArray(search) ? { relation: search } : search;\n}\nfunction parseSearch(search) {\n  const source = Array.isArray(search) ? search[0] : search.source;\n  const relation = Array.isArray(search) ? search[1] : search.relation;\n  const target = Array.isArray(search) ? search[2] : search.target;\n  const out = {};\n  if (source) {\n    out.source = parseNodeSearch(source);\n  }\n  if (relation) {\n    out.relation = parseRelation(relation);\n  }\n  if (target) {\n    out.target = parseNodeSearch(target);\n  }\n  return out;\n}\n\n// src/tribble-db.ts\nvar TribbleDB = class _TribbleDB {\n  index;\n  validations;\n  constructor(triples, validations = {}) {\n    this.index = new Index(triples);\n    this.validations = validations;\n  }\n  static of(triples) {\n    return new _TribbleDB(triples);\n  }\n  static from(objects) {\n    const triples = [];\n    for (const obj of objects) {\n      const { id, ...relations } = obj;\n      if (typeof id !== \"string\") {\n        throw new Error(\"Each TripleObject must have a string id.\");\n      }\n      for (const [relation, target] of Object.entries(relations)) {\n        if (Array.isArray(target)) {\n          for (const sub of target) {\n            triples.push([id, relation, sub]);\n          }\n        } else {\n          triples.push([id, relation, target]);\n        }\n      }\n    }\n    return new _TribbleDB(triples);\n  }\n  validateTriples(triples) {\n    const messages = [];\n    for (const [source, relation, target] of triples) {\n      const validator = this.validations[relation];\n      if (!validator) {\n        continue;\n      }\n      const { type } = asUrn(source);\n      const res = validator(type, relation, target);\n      if (typeof res === \"string\") {\n        messages.push(res);\n      }\n    }\n    if (messages.length > 0) {\n      throw new Error(`Triple validation failed:\n- ${messages.join(\"\\n- \")}`);\n    }\n  }\n  add(triples) {\n    this.validateTriples(triples);\n    this.index.add(triples);\n  }\n  delete(triples) {\n    this.index.delete(triples);\n    return this;\n  }\n  triples() {\n    return this.index.triples();\n  }\n  sources() {\n    return this.index.getUniqueSources();\n  }\n  relations() {\n    return this.index.getUniqueRelations();\n  }\n  targets() {\n    return this.index.getUniqueTargets();\n  }\n  firstTriple() {\n    const allTriples = this.triples();\n    return allTriples.length > 0 ? allTriples[0] : void 0;\n  }\n  firstSource() {\n    return this.index.getTriple(0)?.[0];\n  }\n  firstRelation() {\n    return this.index.getTriple(0)?.[1];\n  }\n  firstTarget() {\n    return this.index.getTriple(0)?.[2];\n  }\n  firstObject(listOnly = false) {\n    let firstId = void 0;\n    const obj = {};\n    for (const [source, relationName, target] of this.index.triples()) {\n      if (firstId === void 0) {\n        firstId = source;\n        obj.id = source;\n      }\n      if (firstId !== source) {\n        continue;\n      }\n      if (!Object.prototype.hasOwnProperty.call(obj, relationName)) {\n        obj[relationName] = listOnly ? [target] : target;\n      } else if (Array.isArray(obj[relationName])) {\n        if (!obj[relationName].includes(target)) {\n          obj[relationName].push(target);\n        }\n      } else {\n        obj[relationName] = obj[relationName] === target ? obj[relationName] : [obj[relationName], target];\n      }\n    }\n    return Object.keys(obj).length > 0 ? obj : void 0;\n  }\n  objects(listOnly = false) {\n    const objs = /* @__PURE__ */ new Map();\n    for (const [source, relationName, target] of this.index.triples()) {\n      let obj = objs.get(source);\n      if (!obj) {\n        obj = { id: source };\n        objs.set(source, obj);\n      }\n      const relationRef = obj[relationName];\n      if (!relationRef) {\n        obj[relationName] = listOnly ? [target] : target;\n      } else if (Array.isArray(relationRef)) {\n        if (!relationRef.includes(target)) {\n          relationRef.push(target);\n        }\n      } else {\n        obj[relationName] = relationRef === target ? relationRef : [relationRef, target];\n      }\n    }\n    return Array.from(objs.values());\n  }\n  map(fnc) {\n    return new _TribbleDB(this.triples().map(fnc));\n  }\n  flatMap(fnc) {\n    return new _TribbleDB(this.triples().flatMap(fnc));\n  }\n  deduplicateTriples(triples) {\n    const seen = /* @__PURE__ */ new Set();\n    const result = [];\n    for (const triple of triples) {\n      const tripleHash = hashTriple(triple);\n      if (!seen.has(tripleHash)) {\n        seen.add(tripleHash);\n        result.push(triple);\n      }\n    }\n    return result;\n  }\n  merge(other) {\n    this.add(other.triples());\n    return this;\n  }\n  clone() {\n    return new _TribbleDB(this.triples(), this.validations);\n  }\n  readThing(urn, opts = { qs: false }) {\n    const allTriples = this.triples();\n    const matchingTriples = [];\n    if (opts.qs) {\n      const { type, id } = asUrn(urn);\n      for (const triple of allTriples) {\n        const sourceParsed = asUrn(triple[0]);\n        if (sourceParsed.type === type && sourceParsed.id === id) {\n          matchingTriples.push(triple);\n        }\n      }\n    } else {\n      for (const triple of allTriples) {\n        if (triple[0] === urn) {\n          matchingTriples.push(triple);\n        }\n      }\n    }\n    if (matchingTriples.length === 0) return void 0;\n    const obj = { id: matchingTriples[0][0] };\n    for (const [, relation, target] of matchingTriples) {\n      if (!Object.prototype.hasOwnProperty.call(obj, relation)) {\n        obj[relation] = target;\n      } else if (Array.isArray(obj[relation])) {\n        if (!obj[relation].includes(target)) {\n          obj[relation].push(target);\n        }\n      } else {\n        obj[relation] = [obj[relation], target];\n      }\n    }\n    return obj;\n  }\n  readThings(urns, opts = { qs: false }) {\n    const results = [];\n    for (const urn of urns) {\n      const thing = this.readThing(urn, opts);\n      if (thing !== void 0) {\n        results.push(thing);\n      }\n    }\n    return results;\n  }\n  parseThing(parser, urn, opts = { qs: false }) {\n    const thing = this.readThing(urn, opts);\n    return thing ? parser(thing) : void 0;\n  }\n  parseThings(parser, urns, opts = { qs: false }) {\n    const results = [];\n    for (const urn of urns) {\n      const res = this.parseThing(parser, urn, opts);\n      if (res) {\n        results.push(res);\n      }\n    }\n    return results;\n  }\n  intersectSets(set1, set2) {\n    const result = /* @__PURE__ */ new Set();\n    for (const item of set1) {\n      if (set2.has(item)) {\n        result.add(item);\n      }\n    }\n    return result;\n  }\n  search(params) {\n    const parsed = parseSearch(params);\n    if (!parsed.source && !parsed.relation && !parsed.target) {\n      return new _TribbleDB(this.triples(), this.validations);\n    }\n    let candidateIndices = null;\n    if (parsed.relation) {\n      const relationNames = Array.isArray(parsed.relation.relation) ? parsed.relation.relation : [parsed.relation.relation];\n      if (relationNames.length > 0) {\n        candidateIndices = /* @__PURE__ */ new Set();\n        for (const relName of relationNames) {\n          const ids = this.index.getRelationSet(relName);\n          if (ids) {\n            for (const idx of ids) {\n              candidateIndices.add(idx);\n            }\n          }\n        }\n      }\n    }\n    if (parsed.source) {\n      const sourceIds = this.getTripleIndicesForNodeQueries(\n        parsed.source,\n        \"source\"\n      );\n      if (candidateIndices === null) {\n        candidateIndices = sourceIds;\n      } else {\n        const intersection = /* @__PURE__ */ new Set();\n        for (const idx of candidateIndices) {\n          if (sourceIds.has(idx)) {\n            intersection.add(idx);\n          }\n        }\n        candidateIndices = intersection;\n      }\n    }\n    if (parsed.target) {\n      const targetIds = this.getTripleIndicesForNodeQueries(\n        parsed.target,\n        \"target\"\n      );\n      if (candidateIndices === null) {\n        candidateIndices = targetIds;\n      } else {\n        const intersection = /* @__PURE__ */ new Set();\n        for (const idx of candidateIndices) {\n          if (targetIds.has(idx)) {\n            intersection.add(idx);\n          }\n        }\n        candidateIndices = intersection;\n      }\n    }\n    if (candidateIndices === null || candidateIndices.size === 0) {\n      return new _TribbleDB([], this.validations);\n    }\n    const matchingTriples = [];\n    for (const tripleIdx of candidateIndices) {\n      const triple = this.index.getTriple(tripleIdx);\n      if (!triple) continue;\n      const [source, relation, target] = triple;\n      if (parsed.source) {\n        let sourceMatches = false;\n        for (const sourceQuery of parsed.source) {\n          if (sourceQuery.predicate && !sourceQuery.predicate(source)) {\n            continue;\n          }\n          sourceMatches = true;\n          break;\n        }\n        if (!sourceMatches) continue;\n      }\n      if (parsed.relation?.predicate && !parsed.relation.predicate(relation)) {\n        continue;\n      }\n      if (parsed.target) {\n        let targetMatches = false;\n        for (const targetQuery of parsed.target) {\n          if (targetQuery.predicate && !targetQuery.predicate(target)) {\n            continue;\n          }\n          targetMatches = true;\n          break;\n        }\n        if (!targetMatches) continue;\n      }\n      matchingTriples.push(triple);\n    }\n    return new _TribbleDB(matchingTriples, this.validations);\n  }\n  getTripleIndicesForNodeQueries(queries, position) {\n    const result = /* @__PURE__ */ new Set();\n    for (const query of queries) {\n      const hasIndexableConstraints = query.type !== void 0 || query.id !== void 0 || query.qs !== void 0 && Object.keys(query.qs).length > 0;\n      if (!hasIndexableConstraints) {\n        for (let idx = 0; idx < this.index.arrayLength; idx++) {\n          result.add(idx);\n        }\n        continue;\n      }\n      const queryMatches = [];\n      if (query.type !== void 0) {\n        const typeSet = position === \"source\" ? this.index.getSourceTypeSet(query.type) : this.index.getTargetTypeSet(query.type);\n        if (typeSet) {\n          queryMatches.push(typeSet);\n        } else {\n          continue;\n        }\n      }\n      if (query.id !== void 0) {\n        const ids = Array.isArray(query.id) ? query.id : [query.id];\n        const idUnion = /* @__PURE__ */ new Set();\n        for (const nodeId of ids) {\n          const idSet = position === \"source\" ? this.index.getSourceIdSet(nodeId) : this.index.getTargetIdSet(nodeId);\n          if (idSet) {\n            for (const idx of idSet) {\n              idUnion.add(idx);\n            }\n          }\n        }\n        if (idUnion.size > 0) {\n          queryMatches.push(idUnion);\n        } else {\n          continue;\n        }\n      }\n      if (query.qs !== void 0) {\n        const qsKeys = Object.keys(query.qs);\n        if (qsKeys.length > 0) {\n          const qsSets = [];\n          for (const key of qsKeys) {\n            const qsSet = position === \"source\" ? this.index.getSourceQsSet(key, query.qs[key]) : this.index.getTargetQsSet(key, query.qs[key]);\n            if (qsSet) {\n              qsSets.push(qsSet);\n            } else {\n              qsSets.length = 0;\n              break;\n            }\n          }\n          if (qsSets.length > 0) {\n            let qsIntersection = qsSets[0];\n            for (let idx = 1; idx < qsSets.length; idx++) {\n              qsIntersection = this.intersectSets(qsIntersection, qsSets[idx]);\n              if (qsIntersection.size === 0) break;\n            }\n            queryMatches.push(qsIntersection);\n          } else {\n            continue;\n          }\n        }\n      }\n      if (queryMatches.length === 0) {\n        continue;\n      }\n      let queryResult = queryMatches[0];\n      for (let idx = 1; idx < queryMatches.length; idx++) {\n        queryResult = this.intersectSets(queryResult, queryMatches[idx]);\n        if (queryResult.size === 0) break;\n      }\n      for (const idx of queryResult) {\n        result.add(idx);\n      }\n    }\n    return result;\n  }\n  searchTriples(params) {\n    const parsed = parseSearch(params);\n    if (!parsed.source && !parsed.relation && !parsed.target) {\n      return this.triples();\n    }\n    let candidateIndices = null;\n    if (parsed.relation) {\n      const relationNames = Array.isArray(parsed.relation.relation) ? parsed.relation.relation : [parsed.relation.relation];\n      if (relationNames.length > 0) {\n        candidateIndices = /* @__PURE__ */ new Set();\n        for (const relName of relationNames) {\n          const ids = this.index.getRelationSet(relName);\n          if (ids) {\n            for (const idx of ids) {\n              candidateIndices.add(idx);\n            }\n          }\n        }\n      }\n    }\n    if (parsed.source) {\n      const sourceIds = this.getTripleIndicesForNodeQueries(\n        parsed.source,\n        \"source\"\n      );\n      if (candidateIndices === null) {\n        candidateIndices = sourceIds;\n      } else {\n        const intersection = /* @__PURE__ */ new Set();\n        for (const idx of candidateIndices) {\n          if (sourceIds.has(idx)) {\n            intersection.add(idx);\n          }\n        }\n        candidateIndices = intersection;\n      }\n    }\n    if (parsed.target) {\n      const targetIds = this.getTripleIndicesForNodeQueries(\n        parsed.target,\n        \"target\"\n      );\n      if (candidateIndices === null) {\n        candidateIndices = targetIds;\n      } else {\n        const intersection = /* @__PURE__ */ new Set();\n        for (const idx of candidateIndices) {\n          if (targetIds.has(idx)) {\n            intersection.add(idx);\n          }\n        }\n        candidateIndices = intersection;\n      }\n    }\n    if (candidateIndices === null || candidateIndices.size === 0) {\n      return [];\n    }\n    const matchingTriples = [];\n    for (const tripleIdx of candidateIndices) {\n      const triple = this.index.getTriple(tripleIdx);\n      if (!triple) continue;\n      const [source, relation, target] = triple;\n      if (parsed.source) {\n        let sourceMatches = false;\n        for (const sourceQuery of parsed.source) {\n          if (sourceQuery.predicate && !sourceQuery.predicate(source)) {\n            continue;\n          }\n          sourceMatches = true;\n          break;\n        }\n        if (!sourceMatches) continue;\n      }\n      if (parsed.relation?.predicate && !parsed.relation.predicate(relation)) {\n        continue;\n      }\n      if (parsed.target) {\n        let targetMatches = false;\n        for (const targetQuery of parsed.target) {\n          if (targetQuery.predicate && !targetQuery.predicate(target)) {\n            continue;\n          }\n          targetMatches = true;\n          break;\n        }\n        if (!targetMatches) continue;\n      }\n      matchingTriples.push(triple);\n    }\n    return matchingTriples;\n  }\n  /*\n   * Search for triples matching a search-query, and applies a transformation function\n   * to each matching triple in-place.\n   */\n  searchFlatmap(search, fnc) {\n    const matchingTriples = this.searchTriples(search);\n    const transformedTriples = matchingTriples.flatMap(fnc);\n    const originalHashes = /* @__PURE__ */ new Set();\n    const transformedHashes = /* @__PURE__ */ new Set();\n    const transformedByHash = /* @__PURE__ */ new Map();\n    for (const triple of matchingTriples) {\n      originalHashes.add(hashTriple(triple));\n    }\n    for (const triple of transformedTriples) {\n      const hash = hashTriple(triple);\n      transformedHashes.add(hash);\n      transformedByHash.set(hash, triple);\n    }\n    const triplesToDelete = [];\n    for (const triple of matchingTriples) {\n      const hash = hashTriple(triple);\n      if (!transformedHashes.has(hash)) {\n        triplesToDelete.push(triple);\n      }\n    }\n    const triplesToAdd = [];\n    for (const hash of transformedHashes) {\n      if (!originalHashes.has(hash)) {\n        triplesToAdd.push(transformedByHash.get(hash));\n      }\n    }\n    if (triplesToDelete.length > 0) {\n      this.delete(triplesToDelete);\n    }\n    if (triplesToAdd.length > 0) {\n      this.add(triplesToAdd);\n    }\n    return this;\n  }\n  get triplesCount() {\n    return this.index.length;\n  }\n};\nexport {\n  TribbleDB,\n  TribbleParser,\n  TribbleStringifier,\n  asUrn,\n  parseUrn\n};\n", "/*\n * Load tribblefile from a URL as a stream of triples.\n */\n\nimport { TribbleDB } from \"@rgrannell1/tribbledb\";\nimport type { Triple } from \"@rgrannell1/tribbledb\";\nimport { TribbleParser } from \"@rgrannell1/tribbledb\";\n\n/*\n * Stream triples from a URL\n *\n * @param url The URL to fetch triples from\n */\nexport async function* streamTribbles(url: string): AsyncGenerator<Triple[]> {\n  const parser = new TribbleParser();\n  const res = await fetch(url);\n  if (!res.body) {\n    throw new Error(\"No response body\");\n  }\n\n  const decoder = new TextDecoderStream();\n  const reader = res.body.pipeThrough(decoder).getReader();\n  let buffer = \"\";\n\n  // rather than yield 20k times, yield a few larger batches...\n  // experimentally, 500 items seems about right\n  const tripleBuffer: Triple[] = [];\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    buffer += value;\n    const lines = buffer.split(\"\\n\");\n    buffer = lines.pop() ?? \"\";\n    for (const line of lines) {\n      const triple = parser.parse(line);\n      if (triple !== undefined) {\n        tripleBuffer.push(triple);\n      }\n\n      if (tripleBuffer.length >= 500) {\n        yield [...tripleBuffer];\n        tripleBuffer.length = 0;\n      }\n    }\n  }\n\n  // parse any remaining line in buffer\n  if (buffer.length > 0) {\n    const triple = parser.parse(buffer);\n    if (triple !== undefined) {\n      tripleBuffer.push(triple);\n    }\n  }\n\n  // and yield any leftover triples\n  if (tripleBuffer.length > 0) {\n    yield [...tripleBuffer];\n  }\n}\n\nlet tdb: TribbleDB | null = null;\n\n/*\n * Load triples from a URL. This takes about 500ms to run (Oct 27 2025) and\n * takes about 60% of load-time of the page. This needs to be reworked, as in the litelement\n * version, to incrementally stream load the database while allowing the page to render.\n *\n * For now, lets make blocking load faster than 500ms...\n *\n * October 28 2025: about 250ms now\n */\nexport async function loadTriples(\n  url: string,\n  schema: Record<string, any> = {},\n  perTriple: (triple: Triple) => Triple[] = (x) => [x],\n): Promise<TribbleDB> {\n  if (!tdb) {\n    tdb = new TribbleDB([], schema);\n  }\n\n  for await (const triples of streamTribbles(url)) {\n    for (const triple of triples) {\n      tdb.add(perTriple(triple));\n    }\n  }\n\n  return tdb;\n}\n", "export const SMALL_DEVICE_WIDTH = 500;\n\nexport const PHOTO_WIDTH = 400;\nexport const PHOTO_HEIGHT = 400;\n\nexport class KnownRelations {\n  static ALBUM_ID = \"albumId\";\n  static SUBJECT = \"subject\";\n  static LOCATION = \"location\";\n  static LONGITUDE = \"longitude\";\n  static LATITUDE = \"latitude\";\n  static COUNTRY = \"country\";\n  static FLAG = \"flag\";\n  static RATING = \"rating\";\n  static NAME = \"name\";\n  static BIRDWATCH_URL = \"birdwatchUrl\";\n  static WIKIPEDIA = \"wikipedia\";\n  static CREATED_AT = \"createdAt\";\n  static SEASON = \"season\";\n  static F_STOP = \"f_stop\";\n  static FOCAL_LENGTH = \"focalLength\";\n  static MODEL = \"model\";\n  static EXPOSURE_TIME = \"exposureTime\";\n  static ISO = \"iso\";\n  static WIDTH = \"width\";\n  static HEIGHT = \"height\";\n  static THUMBNAIL_URL = \"thumbnailUrl\";\n  static PNG_URL = \"pngUrl\";\n  static MID_IMAGE_LOSSY_URL = \"midImageLossyUrl\";\n  static FULL_IMAGE = \"fullImage\";\n  static POSTER_URL = \"posterUrl\";\n  static VIDEO_URL_1080P = \"videoUrl1080p\";\n  static VIDEO_URL_480P = \"videoUrl480p\";\n  static VIDEO_URL_720P = \"videoUrl720p\";\n  static VIDEO_URL_UNSCALED = \"videoUrlUnscaled\";\n  static YEAR = \"year\";\n  static CONTAINS = \"contains\";\n  static IN = \"in\";\n  static STYLE = \"style\";\n  // horrible\n  static FLAGS = \"flags\";\n\n  static CONTAINS_ALBUM = \"containsAlbum\";\n  static TRIP = \"trip\";\n}\n\nexport class KnownTypes {\n  static PLACE = \"place\";\n  static COUNTRY = \"country\";\n  static BIRD = \"bird\";\n  static MAMMAL = \"mammal\";\n  static REPTILE = \"reptile\";\n  static AMPHIBIAN = \"amphibian\";\n  static INSECT = \"insect\";\n  static CAMERA = \"camera\";\n  static PHOTO = \"photo\";\n  static VIDEO = \"video\";\n  static ALBUM = \"album\";\n  static UNESCO = \"unesco\";\n  static FISH = \"fish\";\n  static PLACE_FEATURE = \"place_feature\";\n}\n\n/*\n * It does make sense to say \"show every place photo\",\n * so designate some types as non-listable on the Listing page\n */\nexport const NonListableTypes = new Set([\n  KnownTypes.COUNTRY,\n  KnownTypes.CAMERA,\n  KnownTypes.PLACE,\n]);\n\n/*\n * A few words have irregular plurals; store them here\n * so we can display them without saying `Countrys`\n */\nexport const PLURALS = new Map<string, string>([\n  [\"country\", \"countries\"],\n]);\n\n/*\n * Renamed relations mapping\n */\nexport const RENAMED_RELATIONS = new Map<string, string>([]);\n\n/*\n * These relations should all expand to CDN urls\n */\nexport const CDN_RELATIONS = new Set([\n  KnownRelations.THUMBNAIL_URL,\n  KnownRelations.PNG_URL,\n  KnownRelations.MID_IMAGE_LOSSY_URL,\n  KnownRelations.FULL_IMAGE,\n  KnownRelations.POSTER_URL,\n  KnownRelations.VIDEO_URL_1080P,\n  KnownRelations.VIDEO_URL_480P,\n  KnownRelations.VIDEO_URL_720P,\n  KnownRelations.VIDEO_URL_UNSCALED,\n]);\n\n/*\n * Some relationships have inverses; store this data here\n * (though it could be passed in band in the Tribble file in future)\n */\nexport const RelationSymmetries = [\n  [KnownRelations.IN, KnownRelations.CONTAINS],\n  [KnownRelations.CONTAINS_ALBUM, KnownRelations.TRIP],\n];\n\n/*\n * A list of shortened Curies passed to the UI, and how to expand them\n */\nexport const CURIES = {\n  \"i\": \"urn:r\u00F3:\",\n  \"birdwatch\": \"https://birdwatchireland.ie/birds/\",\n  \"photos\": \"https://photos-cdn.rgrannell.xyz/\",\n  \"wiki\": \"https://en.wikipedia.org/wiki/\",\n};\n\n// Curies match this pattern\nexport const CURIE_REGEX = /^\\[([a-z]*):(.*)\\]$/;\n\n// TODO inject via environmental variable\nexport const ENDPOINT = \"https://photos-cdn.rgrannell.xyz\";\n\nexport const SCROLL_HIDE_THRESHOLD = 200;\n\n/*\n * Places have features, use these features to pick an emoji to represent the place\n */\nexport const PLACE_FEATURES_TO_EMOJI = {\n  aquarium: \"\uD83D\uDC20\",\n  aquaduct: \"\uD83C\uDFDB\uFE0F\",\n  archaeological: \"\uD83C\uDFFA\",\n  beach: \"\uD83C\uDFD6\uFE0F\",\n  bridge: \"\uD83C\uDF09\",\n  canal: \"\uD83D\uDEA4\",\n  castle: \"\uD83C\uDFF0\",\n  church: \"\u26EA\",\n  cathedral: \"\u26EA\",\n  continent: \"\uD83C\uDF0D\",\n  cave: \"\u26CF\uFE0F\",\n  city: \"\uD83C\uDFD9\uFE0F\",\n  cliffs: \"\u26F0\uFE0F\",\n  county: \"\uD83D\uDDFA\uFE0F\",\n  district: \"\uD83C\uDFD8\uFE0F\",\n  garden: \"\uD83C\uDF3A\",\n  harbor: \"\u2693\",\n  island: \"\uD83C\uDFDD\uFE0F\",\n  lake: \"\uD83C\uDFDE\uFE0F\",\n  monument: \"\uD83D\uDDFF\",\n  mosque: \"\uD83D\uDD4C\",\n  mountain: \"\uD83C\uDFD4\uFE0F\",\n  mountains: \"\uD83C\uDFD4\uFE0F\",\n  museum: \"\uD83C\uDFDB\uFE0F\",\n  monastery: \"\uD83C\uDFEF\",\n  national: \"\uD83C\uDDFA\uD83C\uDDF3\",\n  nature: \"\uD83C\uDF3F\",\n  palace: \"\uD83C\uDFEF\",\n  park: \"\uD83C\uDF33\",\n  port: \"\uD83D\uDEF3\uFE0F\",\n  rainforest: \"\uD83C\uDF34\",\n  square: \"\uD83C\uDFE2\",\n  state: \"\uD83C\uDFDB\uFE0F\",\n  street: \"\uD83D\uDEB6\u200D\u2642\uFE0F\",\n  town: \"\uD83C\uDFD8\uFE0F\",\n  train: \"\uD83D\uDE86\",\n  unesco: \"\uD83C\uDFDB\uFE0F\",\n  village: \"\uD83C\uDFE1\",\n  volcano: \"\uD83C\uDF0B\",\n  waterfall: \"\uD83D\uDCA6\",\n  wildlife: \"\uD83E\uDD81\",\n  zoo: \"\uD83E\uDD93\",\n};\n\n/*\n * A list of cameras I've taken photos on\n */\nexport const CAMERA_MODELS = new Set([\n  \"dc-gh5\",\n  \"dc-gh6\",\n  \"dmc-fz72\",\n  \"dmc-g7\",\n  \"finepix-f70exr\",\n  \"xz-1\",\n]);\n\n/*\n * A list of phones I've taken photos on\n */\nexport const PHONE_MODELS = new Set([\n  \"pixel-4a\",\n  \"pixel-7-pro\",\n  \"pixel-9a\",\n  \"sm-a520f\",\n]);\n\nexport const BinomialTypes = new Set([\n  KnownTypes.BIRD,\n  KnownTypes.MAMMAL,\n  KnownTypes.REPTILE,\n  KnownTypes.AMPHIBIAN,\n  KnownTypes.FISH,\n  KnownTypes.INSECT,\n]);\n", "/*\n * We want to limit how much we send to the server,\n * so some triples are modified or derived client-side\n */\n\nimport type { TribbleDB, Triple } from \"@rgrannell1/tribbledb\";\n\nimport {\n  CDN_RELATIONS,\n  CURIE_REGEX,\n  CURIES,\n  ENDPOINT,\n  KnownRelations,\n  RelationSymmetries,\n} from \"../constants.ts\";\n\nconst styleNames = new Set<string>();\n\n/*\n * Expand CDN urls with their endpoint\n */\nexport function expandCdnUrls(triple: Triple): Triple[] {\n  const [src, rel, tgt] = triple;\n\n  const isCDNRelation = Array.from(CDN_RELATIONS).some((candidate: string) => {\n    return rel === candidate;\n  });\n\n  if (!isCDNRelation) {\n    return [triple];\n  }\n\n  return [[\n    src,\n    rel,\n    `${ENDPOINT}${tgt}`,\n  ]];\n}\n\n/*\n * Expand shortened URNS into urn:r\u00F3:\n */\nexport function expandUrns(triple: Triple): Triple[] {\n  const [src, rel, tgt] = triple;\n\n  return [[\n    typeof src === \"string\" && src.startsWith(\"::\")\n      ? `urn:r\u00F3:${src.slice(2)}`\n      : src,\n    rel,\n    typeof tgt === \"string\" && tgt.startsWith(\"::\")\n      ? `urn:r\u00F3:${tgt.slice(2)}`\n      : tgt,\n  ]];\n}\n\n/*\n * Add years as a relation, when a date is present\n */\nexport function addYear(tdb: TribbleDB) {\n  const years = tdb.search({\n    relation: KnownRelations.CREATED_AT,\n  }).triples().flatMap(([src, _, tgt]) => {\n    const date = new Date(tgt);\n\n    if (isNaN(date.getTime())) {\n      return [];\n    }\n\n    const year = date.getUTCFullYear().toString();\n\n    return [[src, KnownRelations.YEAR, year]] as Triple[];\n  });\n\n  tdb.add(years);\n}\n\n/*\n * Reverse relationships\n *\n * some relations imply other; X parent-of Y implies Y child-of X\n */\nexport function addInverseRelations(tdb: TribbleDB) {\n  const triples: Triple[] = [];\n\n  for (const [to, from] of RelationSymmetries) {\n    const results = tdb.search({\n      relation: to,\n    }).triples();\n\n    for (const [src, _, tgt] of results) {\n      triples.push([tgt, from, src]);\n    }\n  }\n\n  tdb.add(triples);\n}\n\nconst CURIE_CACHE = new Map<string, string>();\n\n/*\n * Expand curie-formatted URLS into their full form.\n */\nexport function expandCurie(curies: Record<string, string>, value: string) {\n  const cached = CURIE_CACHE.get(value);\n  if (cached) {\n    return cached;\n  }\n\n  if (typeof value !== \"string\" || !CURIE_REGEX.test(value)) {\n    return value;\n  }\n  const match = value.match(CURIE_REGEX);\n\n  if (!match) {\n    return value;\n  }\n\n  const prefix = match[1];\n  const id = match[2];\n\n  const result = curies[prefix] ? `${curies[prefix]}${id}` : value;\n\n  CURIE_CACHE.set(value, result);\n  return result;\n}\n\n/*\n * Some URNs are sent in CURIE format to compact them; expand\n * e.g [wiki:olm] => https://en.wikipedia.org/wiki/olm\n */\nexport function expandTripleCuries(\n  triple: Triple,\n) {\n  const [src, rel, tgt] = triple;\n\n  return [\n    [\n      expandCurie(CURIES, src),\n      rel,\n      expandCurie(CURIES, tgt),\n    ],\n  ];\n}\n\n/*\n * Construct a location tree based on `in` relations.\n */\nexport function buildLocationTrees(\n  tdb: TribbleDB,\n) {\n  // This is a bit unpleasant\n  const treeState = {\n    nodes: new Map<string, {\n      id: string;\n      parents: Set<string>;\n    }>(),\n    // used later to detect whether a node is a leaf\n    branchIds: new Set<string>(),\n  };\n\n  const results = tdb.search({\n    relation: KnownRelations.IN,\n  }).triples();\n\n  const nodes = treeState.nodes;\n  for (const [src, , tgt] of results) {\n    let srcNode = nodes.get(src);\n    if (!srcNode) {\n      srcNode = { id: src, parents: new Set() };\n      nodes.set(src, srcNode);\n    }\n\n    let tgtNode = nodes.get(tgt);\n    if (!tgtNode) {\n      tgtNode = { id: tgt, parents: new Set() };\n      nodes.set(tgt, tgtNode);\n    }\n\n    treeState.branchIds.add(tgt);\n    srcNode?.parents.add(tgt);\n  }\n\n  return treeState;\n}\n\n// This should be in mirror, but for testing...\nexport const HARD_CODED_TRIPLES: Triple[] = [\n  [\"urn:r\u00F3:rating:%E2%AD%90\", KnownRelations.NAME, \"\u2B50\"],\n  [\"urn:r\u00F3:rating:%E2%AD%90%E2%AD%90\", KnownRelations.NAME, \"\u2B50\u2B50\"],\n  [\"urn:r\u00F3:rating:%E2%AD%90%E2%AD%90%E2%AD%90\", KnownRelations.NAME, \"\u2B50\u2B50\u2B50\"],\n  [\n    \"urn:r\u00F3:rating:%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90\",\n    KnownRelations.NAME,\n    \"\u2B50\u2B50\u2B50\u2B50\",\n  ],\n  [\n    \"urn:r\u00F3:rating:%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90\",\n    KnownRelations.NAME,\n    \"\u2B50\u2B50\u2B50\u2B50\u2B50\",\n  ],\n];\n\n/*\n * Compose all triple modifiers together.\n *\n * This is a bottleneck\n * - takes roughly 100ms to run as of Nov 25 tribbledb v0.16\n * - takes 70ms after v0.18 Nov 25 and moving some derivations to non-linear scan adds\n *\n * @param triple The input triple to modify.\n */\nexport function deriveTriples(\n  triple: Triple,\n): Triple[] {\n  const tripleProcessors = [\n    expandUrns,\n    expandTripleCuries,\n    expandCdnUrls,\n  ];\n\n  let outputTriples: Triple[] = [triple];\n  for (const fn of tripleProcessors) {\n    let nextStep: Triple[] = [];\n\n    for (const triple of outputTriples) {\n      nextStep.push(...(fn(triple) as Triple[]));\n    }\n\n    outputTriples = [...nextStep];\n    nextStep = [];\n  }\n\n  return outputTriples;\n}\n\n/*\n * Operations that add but do not modify existing triples,\n * to be run after all indexing is complete.\n */\nexport function postIndexing(tdb: TribbleDB) {\n  addYear(tdb);\n  addInverseRelations(tdb);\n  addNestedLocations(tdb);\n}\n\n/*\n * During the initial flatmap processing of the ingested triples,\n * we built up a tree describing which places are contained in which others.\n * Construct the transitive relations in this function.\n */\nexport function addNestedLocations(tdb: TribbleDB) {\n  const treeState = buildLocationTrees(tdb);\n  /*\n   * Recurse up the tree from the leaves, tracing the path we followed.\n   */\n  function recurse(path: string[], urn: string): Triple[] {\n    const triples: Triple[] = [];\n\n    const node = treeState.nodes.get(urn);\n\n    // Probably not possible\n    if (!node) {\n      throw new Error(`no node in location tree for ${urn}`);\n    }\n\n    // Beats implementing cycle-detection\n    if (path.length > 5) {\n      throw new Error(`likely cycle; ${JSON.stringify(path)}`);\n    }\n\n    if (node.parents.size === 0) {\n      // in this case, we have a path A :IN B :IN C :IN D\n      // return [A, B], [A, C], [A, D], [B, C], ..., [C, D]\n      // which should be the set of transitive in relations.\n      // For good measure, throw in the `contains` inverse relation\n      const totalPath = [...path, urn];\n\n      for (let idx = 0; idx < totalPath.length - 1; idx++) {\n        for (let jdx = idx; jdx < totalPath.length; jdx++) {\n          const src = totalPath[idx];\n          const tgt = totalPath[jdx];\n\n          if (src === tgt) {\n            continue;\n          }\n\n          triples.push([src, KnownRelations.IN, tgt]);\n          triples.push([tgt, KnownRelations.CONTAINS, src]);\n        }\n      }\n    } else {\n      for (const parent of node.parents) {\n        triples.push(...recurse([...path, urn], parent));\n      }\n    }\n\n    return triples;\n  }\n\n  const triples: Triple[] = [];\n\n  // Recurse up from all leaves A :IN B, and\n  // return all transitive location relations\n  for (const nodeId of treeState.nodes.keys()) {\n    if (treeState.branchIds.has(nodeId)) {\n      continue;\n    }\n\n    triples.push(...recurse([], nodeId));\n  }\n\n  tdb.add(triples);\n}\n\n/*\n * TODO: if a photo is in Zaragoza, it's in Spain. Make sure that\n         link is captured.\n */\n", "// TODO dd typing\n\nexport function logParseWarning(issues: any): void {\n  const message: string[] = [];\n\n  for (const issue of issues) {\n    message.push(\n      `Parse warning @\\n${\n        JSON.stringify(issue.path, null, 2)\n      }\\n: ${issue.message}`,\n    );\n  }\n\n  // TODO; error out instead\n  console.warn(message.join(\"\\n\"));\n  console.trace();\n}\n", "//#region src/storages/globalConfig/globalConfig.ts\nlet store$4;\n/**\n* Sets the global configuration.\n*\n* @param config The configuration.\n*/\nfunction setGlobalConfig(config$1) {\n\tstore$4 = {\n\t\t...store$4,\n\t\t...config$1\n\t};\n}\n/**\n* Returns the global configuration.\n*\n* @param config The config to merge.\n*\n* @returns The configuration.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalConfig(config$1) {\n\treturn {\n\t\tlang: config$1?.lang ?? store$4?.lang,\n\t\tmessage: config$1?.message,\n\t\tabortEarly: config$1?.abortEarly ?? store$4?.abortEarly,\n\t\tabortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly\n\t};\n}\n/**\n* Deletes the global configuration.\n*/\nfunction deleteGlobalConfig() {\n\tstore$4 = void 0;\n}\n\n//#endregion\n//#region src/storages/globalMessage/globalMessage.ts\nlet store$3;\n/**\n* Sets a global error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setGlobalMessage(message$1, lang) {\n\tif (!store$3) store$3 = /* @__PURE__ */ new Map();\n\tstore$3.set(lang, message$1);\n}\n/**\n* Returns a global error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalMessage(lang) {\n\treturn store$3?.get(lang);\n}\n/**\n* Deletes a global error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteGlobalMessage(lang) {\n\tstore$3?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/schemaMessage/schemaMessage.ts\nlet store$2;\n/**\n* Sets a schema error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSchemaMessage(message$1, lang) {\n\tif (!store$2) store$2 = /* @__PURE__ */ new Map();\n\tstore$2.set(lang, message$1);\n}\n/**\n* Returns a schema error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSchemaMessage(lang) {\n\treturn store$2?.get(lang);\n}\n/**\n* Deletes a schema error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteSchemaMessage(lang) {\n\tstore$2?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/specificMessage/specificMessage.ts\nlet store$1;\n/**\n* Sets a specific error message.\n*\n* @param reference The identifier reference.\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSpecificMessage(reference, message$1, lang) {\n\tif (!store$1) store$1 = /* @__PURE__ */ new Map();\n\tif (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());\n\tstore$1.get(reference).set(lang, message$1);\n}\n/**\n* Returns a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSpecificMessage(reference, lang) {\n\treturn store$1?.get(reference)?.get(lang);\n}\n/**\n* Deletes a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*/\nfunction deleteSpecificMessage(reference, lang) {\n\tstore$1?.get(reference)?.delete(lang);\n}\n\n//#endregion\n//#region src/utils/_stringify/_stringify.ts\n/**\n* Stringifies an unknown input to a literal or type string.\n*\n* @param input The unknown input.\n*\n* @returns A literal or type string.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _stringify(input) {\n\tconst type = typeof input;\n\tif (type === \"string\") return `\"${input}\"`;\n\tif (type === \"number\" || type === \"bigint\" || type === \"boolean\") return `${input}`;\n\tif (type === \"object\" || type === \"function\") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n\treturn type;\n}\n\n//#endregion\n//#region src/utils/_addIssue/_addIssue.ts\n/**\n* Adds an issue to the dataset.\n*\n* @param context The issue context.\n* @param label The issue label.\n* @param dataset The input dataset.\n* @param config The configuration.\n* @param other The optional props.\n*\n* @internal\n*/\nfunction _addIssue(context, label, dataset, config$1, other) {\n\tconst input = other && \"input\" in other ? other.input : dataset.value;\n\tconst expected = other?.expected ?? context.expects ?? null;\n\tconst received = other?.received ?? /* @__PURE__ */ _stringify(input);\n\tconst issue = {\n\t\tkind: context.kind,\n\t\ttype: context.type,\n\t\tinput,\n\t\texpected,\n\t\treceived,\n\t\tmessage: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n\t\trequirement: context.requirement,\n\t\tpath: other?.path,\n\t\tissues: other?.issues,\n\t\tlang: config$1.lang,\n\t\tabortEarly: config$1.abortEarly,\n\t\tabortPipeEarly: config$1.abortPipeEarly\n\t};\n\tconst isSchema = context.kind === \"schema\";\n\tconst message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);\n\tif (message$1 !== void 0) issue.message = typeof message$1 === \"function\" ? message$1(issue) : message$1;\n\tif (isSchema) dataset.typed = false;\n\tif (dataset.issues) dataset.issues.push(issue);\n\telse dataset.issues = [issue];\n}\n\n//#endregion\n//#region src/utils/_getByteCount/_getByteCount.ts\nlet textEncoder;\n/**\n* Returns the byte count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The byte count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getByteCount(input) {\n\tif (!textEncoder) textEncoder = new TextEncoder();\n\treturn textEncoder.encode(input).length;\n}\n\n//#endregion\n//#region src/utils/_getGraphemeCount/_getGraphemeCount.ts\nlet segmenter;\n/**\n* Returns the grapheme count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The grapheme count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getGraphemeCount(input) {\n\tif (!segmenter) segmenter = new Intl.Segmenter();\n\tconst segments = segmenter.segment(input);\n\tlet count = 0;\n\tfor (const _ of segments) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_getLastMetadata/_getLastMetadata.ts\n/**\n* Returns the last top-level value of a given metadata type from a schema\n* using a breadth-first search that starts with the last item in the pipeline.\n*\n* @param schema The schema to search.\n* @param type The metadata type.\n*\n* @returns The value, if any.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getLastMetadata(schema, type) {\n\tif (\"pipe\" in schema) {\n\t\tconst nestedSchemas = [];\n\t\tfor (let index = schema.pipe.length - 1; index >= 0; index--) {\n\t\t\tconst item = schema.pipe[index];\n\t\t\tif (item.kind === \"schema\" && \"pipe\" in item) nestedSchemas.push(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === type) return item[type];\n\t\t}\n\t\tfor (const nestedSchema of nestedSchemas) {\n\t\t\tconst result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);\n\t\t\tif (result !== void 0) return result;\n\t\t}\n\t}\n}\n\n//#endregion\n//#region src/utils/_getStandardProps/_getStandardProps.ts\n/**\n* Returns the Standard Schema properties.\n*\n* @param context The schema context.\n*\n* @returns The Standard Schema properties.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getStandardProps(context) {\n\treturn {\n\t\tversion: 1,\n\t\tvendor: \"valibot\",\n\t\tvalidate(value$1) {\n\t\t\treturn context[\"~run\"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/utils/_getWordCount/_getWordCount.ts\nlet store;\n/**\n* Returns the word count of the input.\n*\n* @param locales The locales to be used.\n* @param input The input to be measured.\n*\n* @returns The word count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getWordCount(locales, input) {\n\tif (!store) store = /* @__PURE__ */ new Map();\n\tif (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n\tconst segments = store.get(locales).segment(input);\n\tlet count = 0;\n\tfor (const segment of segments) if (segment.isWordLike) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\n/**\n* Non-digit regex.\n*/\nconst NON_DIGIT_REGEX = /\\D/gu;\n/**\n* Checks whether a string with numbers corresponds to the luhn algorithm.\n*\n* @param input The input to be checked.\n*\n* @returns Whether input is valid.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isLuhnAlgo(input) {\n\tconst number$1 = input.replace(NON_DIGIT_REGEX, \"\");\n\tlet length$1 = number$1.length;\n\tlet bit = 1;\n\tlet sum = 0;\n\twhile (length$1) {\n\t\tconst value$1 = +number$1[--length$1];\n\t\tbit ^= 1;\n\t\tsum += bit ? [\n\t\t\t0,\n\t\t\t2,\n\t\t\t4,\n\t\t\t6,\n\t\t\t8,\n\t\t\t1,\n\t\t\t3,\n\t\t\t5,\n\t\t\t7,\n\t\t\t9\n\t\t][value$1] : value$1;\n\t}\n\treturn sum % 10 === 0;\n}\n\n//#endregion\n//#region src/utils/_isValidObjectKey/_isValidObjectKey.ts\n/**\n* Disallows inherited object properties and prevents object prototype\n* pollution by disallowing certain keys.\n*\n* @param object The object to check.\n* @param key The key to check.\n*\n* @returns Whether the key is allowed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isValidObjectKey(object$1, key) {\n\treturn Object.hasOwn(object$1, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n//#endregion\n//#region src/utils/_joinExpects/_joinExpects.ts\n/**\n* Joins multiple `expects` values with the given separator.\n*\n* @param values The `expects` values.\n* @param separator The separator.\n*\n* @returns The joined `expects` property.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _joinExpects(values$1, separator) {\n\tconst list = [...new Set(values$1)];\n\tif (list.length > 1) return `(${list.join(` ${separator} `)})`;\n\treturn list[0] ?? \"never\";\n}\n\n//#endregion\n//#region src/utils/entriesFromList/entriesFromList.ts\n/**\n* Creates an object entries definition from a list of keys and a schema.\n*\n* @param list A list of keys.\n* @param schema The schema of the keys.\n*\n* @returns The object entries.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromList(list, schema) {\n\tconst entries$1 = {};\n\tfor (const key of list) entries$1[key] = schema;\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/entriesFromObjects/entriesFromObjects.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromObjects(schemas) {\n\tconst entries$1 = {};\n\tfor (const schema of schemas) Object.assign(entries$1, schema.entries);\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/getDotPath/getDotPath.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDotPath(issue) {\n\tif (issue.path) {\n\t\tlet key = \"\";\n\t\tfor (const item of issue.path) if (typeof item.key === \"string\" || typeof item.key === \"number\") if (key) key += `.${item.key}`;\n\t\telse key += item.key;\n\t\telse return null;\n\t\treturn key;\n\t}\n\treturn null;\n}\n\n//#endregion\n//#region src/utils/isOfKind/isOfKind.ts\n/**\n* A generic type guard to check the kind of an object.\n*\n* @param kind The kind to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfKind(kind, object$1) {\n\treturn object$1.kind === kind;\n}\n\n//#endregion\n//#region src/utils/isOfType/isOfType.ts\n/**\n* A generic type guard to check the type of an object.\n*\n* @param type The type to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfType(type, object$1) {\n\treturn object$1.type === type;\n}\n\n//#endregion\n//#region src/utils/isValiError/isValiError.ts\n/**\n* A type guard to check if an error is a ValiError.\n*\n* @param error The error to check.\n*\n* @returns Whether its a ValiError.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isValiError(error) {\n\treturn error instanceof ValiError;\n}\n\n//#endregion\n//#region src/utils/ValiError/ValiError.ts\n/**\n* A Valibot error with useful information.\n*/\nvar ValiError = class extends Error {\n\t/**\n\t* Creates a Valibot error with useful information.\n\t*\n\t* @param issues The error issues.\n\t*/\n\tconstructor(issues) {\n\t\tsuper(issues[0].message);\n\t\tthis.name = \"ValiError\";\n\t\tthis.issues = issues;\n\t}\n};\n\n//#endregion\n//#region src/actions/args/args.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction args(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: args,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst argsDataset = this.schema[\"~run\"]({ value: args_ }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/args/argsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction argsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: argsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args$1) => {\n\t\t\t\tconst argsDataset = await schema[\"~run\"]({ value: args$1 }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/await/awaitAsync.ts\n/**\n* Creates an await transformation action.\n*\n* @returns An await action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction awaitAsync() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"await\",\n\t\treference: awaitAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/regex.ts\n/**\n* [Base64](https://en.wikipedia.org/wiki/Base64) regex.\n*/\nconst BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\n/**\n* [BIC](https://en.wikipedia.org/wiki/ISO_9362) regex.\n*/\nconst BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\n/**\n* [Cuid2](https://github.com/paralleldrive/cuid2) regex.\n*/\nconst CUID2_REGEX = /^[a-z][\\da-z]*$/u;\n/**\n* [Decimal](https://en.wikipedia.org/wiki/Decimal) regex.\n*/\nconst DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\n/**\n* [Digits](https://en.wikipedia.org/wiki/Numerical_digit) regex.\n*/\nconst DIGITS_REGEX = /^\\d+$/u;\n/**\n* [Email address](https://en.wikipedia.org/wiki/Email_address) regex.\n*/\nconst EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\n/**\n* Emoji regex from [emoji-regex-xs](https://github.com/slevithan/emoji-regex-xs) v1.0.0 (MIT license).\n*\n* Hint: We decided against the newer `/^\\p{RGI_Emoji}+$/v` regex because it is\n* not supported in older runtimes and does not match all emoji.\n*/\nconst EMOJI_REGEX = /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation}))*)+$/u;\n/**\n* [Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\n/**\n* [Hex color](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\n/**\n* [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity) regex.\n*/\nconst IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\n/**\n* [IPv4](https://en.wikipedia.org/wiki/IPv4) regex.\n*/\nconst IPV4_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\n/**\n* [IPv6](https://en.wikipedia.org/wiki/IPv6) regex.\n*/\nconst IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [IP](https://en.wikipedia.org/wiki/IP_address) regex.\n*/\nconst IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date regex.\n*/\nconst ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time regex.\n*/\nconst ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time regex.\n*/\nconst ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time with seconds regex.\n*/\nconst ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp regex.\n*/\nconst ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) week regex.\n*/\nconst ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 48 bit regex.\n*/\nconst MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 64 bit regex.\n*/\nconst MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) regex.\n*/\nconst MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [Nano ID](https://github.com/ai/nanoid) regex.\n*/\nconst NANO_ID_REGEX = /^[\\w-]+$/u;\n/**\n* [Octal](https://en.wikipedia.org/wiki/Octal) regex.\n*/\nconst OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\n/**\n* [RFC 5322 email address](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1) regex.\n*\n* Hint: This regex was taken from the [HTML Living Standard Specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) and does not perfectly represent RFC 5322.\n*/\nconst RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/**\n* [Slug](https://en.wikipedia.org/wiki/Clean_URL#Slug) regex.\n*/\nconst SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\n/**\n* [ULID](https://github.com/ulid/spec) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\n/**\n* [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) regex.\n*/\nconst UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n//#endregion\n//#region src/actions/base64/base64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction base64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"base64\",\n\t\treference: base64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BASE64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Base64\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bic/bic.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bic(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bic\",\n\t\treference: bic,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BIC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"BIC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/brand/brand.ts\n/**\n* Creates a brand transformation action.\n*\n* @param name The brand name.\n*\n* @returns A brand action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction brand(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"brand\",\n\t\treference: brand,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bytes/bytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bytes\",\n\t\treference: bytes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 !== this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/check.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction check(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: check,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/checkAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: checkAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItems(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItems,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) for (let index = 0; index < dataset.value.length; index++) {\n\t\t\t\tconst item = dataset.value[index];\n\t\t\t\tif (!this.requirement(item, index, dataset.value)) _addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\tinput: item,\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\tvalue: item\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItemsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItemsAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItemsAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst requirementResults = await Promise.all(dataset.value.map(this.requirement));\n\t\t\t\tfor (let index = 0; index < dataset.value.length; index++) if (!requirementResults[index]) {\n\t\t\t\t\tconst item = dataset.value[index];\n\t\t\t\t\t_addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\t\tinput: item,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\t\tvalue: item\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/creditCard/creditCard.ts\n/**\n* Credit card regex.\n*/\nconst CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\n/**\n* Sanitize regex.\n*/\nconst SANITIZE_REGEX = /[- ]/gu;\n/**\n* Provider regex list.\n*/\nconst PROVIDER_REGEX_LIST = [\n\t/^3[47]\\d{13}$/u,\n\t/^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n\t/^6(?:011|5\\d{2})\\d{12,15}$/u,\n\t/^(?:2131|1800|35\\d{3})\\d{11}$/u,\n\t/^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n\t/^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n\t/^4\\d{12}(?:\\d{3,6})?$/u\n];\n/* @__NO_SIDE_EFFECTS__ */\nfunction creditCard(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"credit_card\",\n\t\treference: creditCard,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\tlet sanitized;\n\t\t\treturn CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, \"\")) && PROVIDER_REGEX_LIST.some((regex$1) => regex$1.test(sanitized)) && /* @__PURE__ */ _isLuhnAlgo(sanitized);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"credit card\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/cuid2/cuid2.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction cuid2(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"cuid2\",\n\t\treference: cuid2,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: CUID2_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Cuid2\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/decimal/decimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction decimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"decimal\",\n\t\treference: decimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"decimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/description/description.ts\n/**\n* Creates a description metadata action.\n*\n* @param description_ The description text.\n*\n* @returns A description action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction description(description_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"description\",\n\t\treference: description,\n\t\tdescription: description_\n\t};\n}\n\n//#endregion\n//#region src/actions/digits/digits.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction digits(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"digits\",\n\t\treference: digits,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DIGITS_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"digits\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/email/email.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction email(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"email\",\n\t\treference: email,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/emoji/emoji.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction emoji(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"emoji\",\n\t\treference: emoji,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: EMOJI_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"emoji\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/empty/empty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction empty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"empty\",\n\t\treference: empty,\n\t\tasync: false,\n\t\texpects: \"0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > 0) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/endsWith/endsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction endsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ends_with\",\n\t\treference: endsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, \"end\", dataset, config$1, { received: `\"${dataset.value.slice(-this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/entries/entries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"entries\",\n\t\treference: entries,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count !== this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/everyItem/everyItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction everyItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"every_item\",\n\t\treference: everyItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/examples/examples.ts\n/**\n* Creates an examples metadata action.\n*\n* @param examples_ The examples.\n*\n* @returns An examples action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction examples(examples_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"examples\",\n\t\treference: examples,\n\t\texamples: examples_\n\t};\n}\n\n//#endregion\n//#region src/actions/excludes/excludes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction excludes(requirement, message$1) {\n\tconst received = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"excludes\",\n\t\treference: excludes,\n\t\tasync: false,\n\t\texpects: `!${received}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/filterItems/filterItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction filterItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"filter_items\",\n\t\treference: filterItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.filter(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/findItem/findItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction findItem(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"find_item\",\n\t\treference: findItem,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.find(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/finite/finite.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction finite(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"finite\",\n\t\treference: finite,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isFinite,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"finite\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/flavor/flavor.ts\n/**\n* Creates a flavor transformation action.\n*\n* @param name The flavor name.\n*\n* @returns A flavor action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction flavor(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"flavor\",\n\t\treference: flavor,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/graphemes/graphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction graphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"graphemes\",\n\t\treference: graphemes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/gtValue/gtValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction gtValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"gt_value\",\n\t\treference: gtValue,\n\t\tasync: false,\n\t\texpects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hash/hash.ts\n/**\n* Hash lengths object.\n*/\nconst HASH_LENGTHS = {\n\tmd4: 32,\n\tmd5: 32,\n\tsha1: 40,\n\tsha256: 64,\n\tsha384: 96,\n\tsha512: 128,\n\tripemd128: 32,\n\tripemd160: 40,\n\ttiger128: 32,\n\ttiger160: 40,\n\ttiger192: 48,\n\tcrc32: 8,\n\tcrc32b: 8,\n\tadler32: 8\n};\n/* @__NO_SIDE_EFFECTS__ */\nfunction hash(types, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hash\",\n\t\treference: hash,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RegExp(types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hash\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexadecimal/hexadecimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexadecimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hexadecimal\",\n\t\treference: hexadecimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEXADECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hexadecimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexColor/hexColor.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexColor(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hex_color\",\n\t\treference: hexColor,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEX_COLOR_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hex color\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/imei/imei.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction imei(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"imei\",\n\t\treference: imei,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\treturn IMEI_REGEX.test(input) && /* @__PURE__ */ _isLuhnAlgo(input);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"IMEI\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/includes/includes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction includes(requirement, message$1) {\n\tconst expects = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"includes\",\n\t\treference: includes,\n\t\tasync: false,\n\t\texpects,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received: `!${expects}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/integer/integer.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction integer(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"integer\",\n\t\treference: integer,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ip/ip.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ip(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ip\",\n\t\treference: ip,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IP\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv4/ipv4.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv4(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv4\",\n\t\treference: ipv4,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV4_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv4\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv6/ipv6.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv6(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv6\",\n\t\treference: ipv6,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV6_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv6\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDate/isoDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDate(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date\",\n\t\treference: isoDate,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDateTime/isoDateTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDateTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date_time\",\n\t\treference: isoDateTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date-time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTime/isoTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time\",\n\t\treference: isoTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimeSecond/isoTimeSecond.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimeSecond(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time_second\",\n\t\treference: isoTimeSecond,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_SECOND_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time-second\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimestamp/isoTimestamp.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimestamp(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_timestamp\",\n\t\treference: isoTimestamp,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIMESTAMP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"timestamp\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoWeek/isoWeek.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoWeek(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_week\",\n\t\treference: isoWeek,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_WEEK_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"week\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/length/length.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction length(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"length\",\n\t\treference: length,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ltValue/ltValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ltValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"lt_value\",\n\t\treference: ltValue,\n\t\tasync: false,\n\t\texpects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac/mac.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac\",\n\t\treference: mac,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac48/mac48.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac48(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac48\",\n\t\treference: mac48,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC48_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"48-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac64/mac64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac64\",\n\t\treference: mac64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"64-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mapItems/mapItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"map_items\",\n\t\treference: mapItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.map(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxBytes/maxBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_bytes\",\n\t\treference: maxBytes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 > this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxEntries/maxEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_entries\",\n\t\treference: maxEntries,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count > this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxGraphemes/maxGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_graphemes\",\n\t\treference: maxGraphemes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxLength/maxLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_length\",\n\t\treference: maxLength,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxSize/maxSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_size\",\n\t\treference: maxSize,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxValue/maxValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_value\",\n\t\treference: maxValue,\n\t\tasync: false,\n\t\texpects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxWords/maxWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_words\",\n\t\treference: maxWords,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/metadata/metadata.ts\n/**\n* Creates a custom metadata action.\n*\n* @param metadata_ The metadata object.\n*\n* @returns A metadata action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction metadata(metadata_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"metadata\",\n\t\treference: metadata,\n\t\tmetadata: metadata_\n\t};\n}\n\n//#endregion\n//#region src/actions/mimeType/mimeType.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mimeType(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mime_type\",\n\t\treference: mimeType,\n\t\tasync: false,\n\t\texpects: /* @__PURE__ */ _joinExpects(requirement.map((option) => `\"${option}\"`), \"|\"),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, \"MIME type\", dataset, config$1, { received: `\"${dataset.value.type}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minBytes/minBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_bytes\",\n\t\treference: minBytes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 < this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minEntries/minEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_entries\",\n\t\treference: minEntries,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count < this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minGraphemes/minGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_graphemes\",\n\t\treference: minGraphemes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minLength/minLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_length\",\n\t\treference: minLength,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minSize/minSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_size\",\n\t\treference: minSize,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minValue/minValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_value\",\n\t\treference: minValue,\n\t\tasync: false,\n\t\texpects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minWords/minWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_words\",\n\t\treference: minWords,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/multipleOf/multipleOf.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction multipleOf(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"multiple_of\",\n\t\treference: multipleOf,\n\t\tasync: false,\n\t\texpects: `%${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, \"multiple\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nanoid/nanoid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nanoid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"nanoid\",\n\t\treference: nanoid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: NANO_ID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Nano ID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nonEmpty/nonEmpty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonEmpty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"non_empty\",\n\t\treference: nonEmpty,\n\t\tasync: false,\n\t\texpects: \"!0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === 0) _addIssue(this, \"length\", dataset, config$1, { received: \"0\" });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/normalize/normalize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction normalize(form) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"normalize\",\n\t\treference: normalize,\n\t\tasync: false,\n\t\tform,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.normalize(this.form);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notBytes/notBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_bytes\",\n\t\treference: notBytes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 === this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notEntries/notEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_entries\",\n\t\treference: notEntries,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count === this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notGraphemes/notGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_graphemes\",\n\t\treference: notGraphemes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notLength/notLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_length\",\n\t\treference: notLength,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notSize/notSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_size\",\n\t\treference: notSize,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValue/notValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_value\",\n\t\treference: notValue,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValues/notValues.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValues(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_values\",\n\t\treference: notValues,\n\t\tasync: false,\n\t\texpects: `!${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notWords/notWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_words\",\n\t\treference: notWords,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/octal/octal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction octal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"octal\",\n\t\treference: octal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: OCTAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"octal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/parseJson/parseJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parseJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"parse_json\",\n\t\treference: parseJson,\n\t\tconfig: config$1,\n\t\tmessage: message$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tdataset.value = JSON.parse(dataset.value, this.config?.reviver);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n/**\n* Checks if a dataset is partially typed.\n*\n* @param dataset The dataset to check.\n* @param paths The paths to check.\n*\n* @returns Whether it is partially typed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isPartiallyTyped(dataset, paths) {\n\tif (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {\n\t\tlet typed = false;\n\t\tconst bound = Math.min(path.length, issue.path?.length ?? 0);\n\t\tfor (let index = 0; index < bound; index++) if (path[index] !== issue.path[index].key && (path[index] !== \"$\" || issue.path[index].type !== \"array\")) {\n\t\t\ttyped = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!typed) return false;\n\t}\n\treturn true;\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheck.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheck(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheckAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheckAsync(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheck.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheck(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\taction({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheckAsync.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheckAsync(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tawait action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransform.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransform(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransform,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst output = action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransformAsync.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransformAsync(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransformAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst output = await action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/readonly/readonly.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction readonly() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"readonly\",\n\t\treference: readonly,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/reduceItems/reduceItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction reduceItems(operation, initial) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"reduce_items\",\n\t\treference: reduceItems,\n\t\tasync: false,\n\t\toperation,\n\t\tinitial,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.reduce(this.operation, this.initial);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/regex/regex.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction regex(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"regex\",\n\t\treference: regex,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"format\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returns.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returns(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returns,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst returnsDataset = this.schema[\"~run\"]({ value: func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returnsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returnsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returnsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args_) => {\n\t\t\t\tconst returnsDataset = await this.schema[\"~run\"]({ value: await func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rfcEmail/rfcEmail.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction rfcEmail(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"rfc_email\",\n\t\treference: rfcEmail,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RFC_EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/safeInteger/safeInteger.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeInteger(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"safe_integer\",\n\t\treference: safeInteger,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isSafeInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"safe integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/size/size.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction size(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"size\",\n\t\treference: size,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/slug/slug.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction slug(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"slug\",\n\t\treference: slug,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: SLUG_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"slug\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/someItem/someItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction someItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"some_item\",\n\t\treference: someItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/sortItems/sortItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction sortItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"sort_items\",\n\t\treference: sortItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.sort(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/startsWith/startsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction startsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"starts_with\",\n\t\treference: startsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, \"start\", dataset, config$1, { received: `\"${dataset.value.slice(0, this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/stringifyJson/stringifyJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction stringifyJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"stringify_json\",\n\t\treference: stringifyJson,\n\t\tmessage: message$1,\n\t\tconfig: config$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tconst output = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);\n\t\t\t\tif (output === void 0) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t\tdataset.value = output;\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/title/title.ts\n/**\n* Creates a title metadata action.\n*\n* @param title_ The title text.\n*\n* @returns A title action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction title(title_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"title\",\n\t\treference: title,\n\t\ttitle: title_\n\t};\n}\n\n//#endregion\n//#region src/actions/toBigint/toBigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBigint(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_bigint\",\n\t\treference: toBigint,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = BigInt(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"bigint\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toBoolean/toBoolean.ts\n/**\n* Creates a to boolean transformation action.\n*\n* @returns A to boolean action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBoolean() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_boolean\",\n\t\treference: toBoolean,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = Boolean(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toDate/toDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toDate(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_date\",\n\t\treference: toDate,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = new Date(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"date\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"date\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toLowerCase/toLowerCase.ts\n/**\n* Creates a to lower case transformation action.\n*\n* @returns A to lower case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toLowerCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_lower_case\",\n\t\treference: toLowerCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toLowerCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMaxValue/toMaxValue.ts\n/**\n* Creates a to max value transformation action.\n*\n* @param requirement The maximum value.\n*\n* @returns A to max value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMaxValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_max_value\",\n\t\treference: toMaxValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMinValue/toMinValue.ts\n/**\n* Creates a to min value transformation action.\n*\n* @param requirement The minimum value.\n*\n* @returns A to min value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMinValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_min_value\",\n\t\treference: toMinValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toNumber/toNumber.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toNumber(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_number\",\n\t\treference: toNumber,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = Number(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toString/toString.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toString(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_string\",\n\t\treference: toString,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = String(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"string\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toUpperCase/toUpperCase.ts\n/**\n* Creates a to upper case transformation action.\n*\n* @returns A to upper case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toUpperCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_upper_case\",\n\t\treference: toUpperCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toUpperCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transform.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transform(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transform,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transformAsync.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transformAsync(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transformAsync,\n\t\tasync: true,\n\t\toperation,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trim/trim.ts\n/**\n* Creates a trim transformation action.\n*\n* @returns A trim action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trim() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim\",\n\t\treference: trim,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trim();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimEnd/trimEnd.ts\n/**\n* Creates a trim end transformation action.\n*\n* @returns A trim end action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimEnd() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_end\",\n\t\treference: trimEnd,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimEnd();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimStart/trimStart.ts\n/**\n* Creates a trim start transformation action.\n*\n* @returns A trim start action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimStart() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_start\",\n\t\treference: trimStart,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimStart();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ulid/ulid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ulid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ulid\",\n\t\treference: ulid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ULID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"ULID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/url/url.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction url(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"url\",\n\t\treference: url,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\ttry {\n\t\t\t\tnew URL(input);\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"URL\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/uuid/uuid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction uuid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"uuid\",\n\t\treference: uuid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: UUID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"UUID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/value/value.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction value(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"value\",\n\t\treference: value,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/values/values.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction values(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"values\",\n\t\treference: values,\n\t\tasync: false,\n\t\texpects: `${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/words/words.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction words(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"words\",\n\t\treference: words,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/assert/assert.ts\n/**\n* Checks if the input matches the schema. As this is an assertion function, it\n* can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*/\nfunction assert(schema, input) {\n\tconst issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n\tif (issues) throw new ValiError(issues);\n}\n\n//#endregion\n//#region src/methods/config/config.ts\n/**\n* Changes the local configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param config The parse configuration.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction config(schema, config$1) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config_) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config_,\n\t\t\t\t...config$1\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getFallback/getFallback.ts\n/**\n* Returns the fallback value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The output dataset if available.\n* @param config The config if available.\n*\n* @returns The fallback value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallback(schema, dataset, config$1) {\n\treturn typeof schema.fallback === \"function\" ? schema.fallback(dataset, config$1) : schema.fallback;\n}\n\n//#endregion\n//#region src/methods/fallback/fallback.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallback(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/fallback/fallbackAsync.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallbackAsync(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = await schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: await /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/flatten/flatten.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction flatten(issues) {\n\tconst flatErrors = {};\n\tfor (const issue of issues) if (issue.path) {\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) {\n\t\t\tif (!flatErrors.nested) flatErrors.nested = {};\n\t\t\tif (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);\n\t\t\telse flatErrors.nested[dotPath] = [issue.message];\n\t\t} else if (flatErrors.other) flatErrors.other.push(issue.message);\n\t\telse flatErrors.other = [issue.message];\n\t} else if (flatErrors.root) flatErrors.root.push(issue.message);\n\telse flatErrors.root = [issue.message];\n\treturn flatErrors;\n}\n\n//#endregion\n//#region src/methods/forward/forward.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forward(action, path) {\n\treturn {\n\t\t...action,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/forward/forwardAsync.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forwardAsync(action, path) {\n\treturn {\n\t\t...action,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = await action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getDefault/getDefault.ts\n/**\n* Returns the default value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The input dataset if available.\n* @param config The config if available.\n*\n* @returns The default value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefault(schema, dataset, config$1) {\n\treturn typeof schema.default === \"function\" ? schema.default(dataset, config$1) : schema.default;\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaults.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefaults(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getDefaults);\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaultsAsync.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getDefaultsAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getDefaultsAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getDefaultsAsync));\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDescription/getDescription.ts\n/**\n* Returns the description of the schema.\n*\n* If multiple descriptions are defined, the last one of the highest level is\n* returned. If no description is defined, `undefined` is returned.\n*\n* @param schema The schema to get the description from.\n*\n* @returns The description, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDescription(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"description\");\n}\n\n//#endregion\n//#region src/methods/getExamples/getExamples.ts\n/**\n* Returns the examples of a schema.\n*\n* If multiple examples are defined, it concatenates them using depth-first\n* search. If no examples are defined, an empty array is returned.\n*\n* @param schema The schema to get the examples from.\n*\n* @returns The examples, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getExamples(schema) {\n\tconst examples$1 = [];\n\tfunction depthFirstCollect(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstCollect(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"examples\") examples$1.push(...item.examples);\n\t\t}\n\t}\n\tdepthFirstCollect(schema);\n\treturn examples$1;\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacks.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallbacks(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getFallbacks);\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacksAsync.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getFallbacksAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getFallbacksAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getFallbacksAsync));\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getMetadata/getMetadata.ts\n/**\n* Returns the metadata of a schema.\n*\n* If multiple metadata are defined, it shallowly merges them using depth-first\n* search. If no metadata is defined, an empty object is returned.\n*\n* @param schema Schema to get the metadata from.\n*\n* @returns The metadata, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getMetadata(schema) {\n\tconst result = {};\n\tfunction depthFirstMerge(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstMerge(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"metadata\") Object.assign(result, item.metadata);\n\t\t}\n\t}\n\tdepthFirstMerge(schema);\n\treturn result;\n}\n\n//#endregion\n//#region src/methods/getTitle/getTitle.ts\n/**\n* Returns the title of the schema.\n*\n* If multiple titles are defined, the last one of the highest level is\n* returned. If no title is defined, `undefined` is returned.\n*\n* @param schema The schema to get the title from.\n*\n* @returns The title, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getTitle(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"title\");\n}\n\n//#endregion\n//#region src/methods/is/is.ts\n/**\n* Checks if the input matches the schema. By using a type predicate, this\n* function can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*\n* @returns Whether the input matches the schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction is(schema, input) {\n\treturn !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n//#endregion\n//#region src/schemas/any/any.ts\n/**\n* Creates an any schema.\n*\n* Hint: This schema function exists only for completeness and is not\n* recommended in practice. Instead, `unknown` should be used to accept\n* unknown data.\n*\n* @returns An any schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction any() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"any\",\n\t\treference: any,\n\t\texpects: \"any\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/array.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction array(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: array,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.item[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/arrayAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction arrayAsync(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: arrayAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(input.map((value$1) => this.item[\"~run\"]({ value: value$1 }, config$1)));\n\t\t\t\tfor (let key = 0; key < itemDatasets.length; key++) {\n\t\t\t\t\tconst itemDataset = itemDatasets[key];\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/bigint/bigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bigint(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"bigint\",\n\t\treference: bigint,\n\t\texpects: \"bigint\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"bigint\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/blob/blob.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction blob(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"blob\",\n\t\treference: blob,\n\t\texpects: \"Blob\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Blob) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/boolean/boolean.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction boolean(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"boolean\",\n\t\treference: boolean,\n\t\texpects: \"boolean\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"boolean\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/custom.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction custom(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: custom,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/customAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction customAsync(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: customAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (await this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/date/date.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction date(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"date\",\n\t\treference: date,\n\t\texpects: \"Date\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/enum/enum.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction enum_(enum__, message$1) {\n\tconst options = [];\n\tfor (const key in enum__) if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) options.push(enum__[key]);\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"enum\",\n\t\treference: enum_,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\tenum: enum__,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptional,\n\t\texpects: wrapped.expects,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptionalAsync,\n\t\texpects: wrapped.expects,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/file/file.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction file(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"file\",\n\t\treference: file,\n\t\texpects: \"File\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof File) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/function/function.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction function_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"function\",\n\t\treference: function_,\n\t\texpects: \"Function\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"function\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/instance/instance.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction instance(class_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"instance\",\n\t\treference: instance,\n\t\texpects: class_.name,\n\t\tasync: false,\n\t\tclass: class_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof this.class) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/utils/_merge/_merge.ts\n/**\n* Merges two values into one single output.\n*\n* @param value1 First value.\n* @param value2 Second value.\n*\n* @returns The merge dataset.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _merge(value1, value2) {\n\tif (typeof value1 === typeof value2) {\n\t\tif (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return { value: value1 };\n\t\tif (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n\t\t\tfor (const key in value2) if (key in value1) {\n\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\tvalue1[key] = dataset.value;\n\t\t\t} else value1[key] = value2[key];\n\t\t\treturn { value: value1 };\n\t\t}\n\t\tif (Array.isArray(value1) && Array.isArray(value2)) {\n\t\t\tif (value1.length === value2.length) {\n\t\t\t\tfor (let index = 0; index < value1.length; index++) {\n\t\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n\t\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\t\tvalue1[index] = dataset.value;\n\t\t\t\t}\n\t\t\t\treturn { value: value1 };\n\t\t\t}\n\t\t}\n\t}\n\treturn { issue: true };\n}\n\n//#endregion\n//#region src/schemas/intersect/intersect.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersect(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersect,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tfor (const schema of this.options) {\n\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/intersectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersectAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersectAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tconst optionDatasets = await Promise.all(this.options.map((schema) => schema[\"~run\"]({ value: input }, config$1)));\n\t\t\t\tfor (const optionDataset of optionDatasets) {\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazy.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazy(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazy,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.getter(dataset.value)[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazyAsync.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazyAsync(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazyAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn (await this.getter(dataset.value))[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/literal/literal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction literal(literal_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"literal\",\n\t\treference: literal,\n\t\texpects: /* @__PURE__ */ _stringify(literal_),\n\t\tasync: false,\n\t\tliteral: literal_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === this.literal) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/map.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction map(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: map,\n\t\texpects: \"Map\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tfor (const [inputKey, inputValue] of input) {\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: inputKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/mapAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: mapAsync,\n\t\texpects: \"Map\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tconst datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([\n\t\t\t\t\tinputKey,\n\t\t\t\t\tinputValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: inputKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: inputValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nan/nan.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nan(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nan\",\n\t\treference: nan,\n\t\texpects: \"NaN\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (Number.isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/never/never.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction never(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"never\",\n\t\treference: never,\n\t\texpects: \"never\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\t_addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullable(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullable,\n\t\texpects: \"!null\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullableAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullableAsync,\n\t\texpects: \"!null\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullish(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullish,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullishAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullishAsync,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptional(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptional,\n\t\texpects: \"!undefined\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptionalAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptionalAsync,\n\t\texpects: \"!undefined\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/null/null.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction null_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"null\",\n\t\treference: null_,\n\t\texpects: \"null\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullable,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullableAsync,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullish(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullish,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullishAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullishAsync,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/number/number.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction number(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"number\",\n\t\treference: number,\n\t\texpects: \"number\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"number\" && !isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/object.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction object(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: object,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/objectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: objectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRest(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRest,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) {\n\t\t\t\t\t\tconst valueDataset = this.rest[\"~run\"]({ value: input[key] }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRestAsync(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRestAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(Object.entries(input).filter(([key]) => /* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value$1]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue$1,\n\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t]))]);\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, valueDataset] of restDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optional,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optionalAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/picklist/picklist.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction picklist(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"picklist\",\n\t\treference: picklist,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/promise/promise.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction promise(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"promise\",\n\t\treference: promise,\n\t\texpects: \"Promise\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Promise) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/record.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction record(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: record,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const entryKey in input) if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {\n\t\t\t\t\tconst entryValue = input[entryKey];\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: entryKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: entryValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/recordAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction recordAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: recordAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst datasets = await Promise.all(Object.entries(input).filter(([key$1]) => /* @__PURE__ */ _isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([\n\t\t\t\t\tentryKey,\n\t\t\t\t\tentryValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: entryKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: entryValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/set.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction set(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: set,\n\t\texpects: \"Set\",\n\t\tasync: false,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tfor (const inputValue of input) {\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/setAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction setAsync(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: setAsync,\n\t\texpects: \"Set\",\n\t\tasync: true,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tconst valueDatasets = await Promise.all([...input].map(async (inputValue) => [inputValue, await this.value[\"~run\"]({ value: inputValue }, config$1)]));\n\t\t\t\tfor (const [inputValue, valueDataset] of valueDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/string/string.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction string(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"string\",\n\t\treference: string,\n\t\texpects: \"string\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"string\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/symbol/symbol.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction symbol(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"symbol\",\n\t\treference: symbol,\n\t\texpects: \"symbol\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"symbol\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRest(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRest,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.rest[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRestAsync(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRestAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(input.slice(this.items.length).map(async (value$1, key) => {\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey + this.items.length,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}))]);\n\t\t\t\tfor (const [key, value$1, itemDataset] of normalDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, itemDataset] of restDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefined/undefined.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefined_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefined\",\n\t\treference: undefined_,\n\t\texpects: \"undefined\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedable,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedableAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/utils/_subIssues/_subIssues.ts\n/**\n* Returns the sub issues of the provided datasets for the union issue.\n*\n* @param datasets The datasets.\n*\n* @returns The sub issues.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _subIssues(datasets) {\n\tlet issues;\n\tif (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);\n\telse issues = dataset.issues;\n\treturn issues;\n}\n\n//#endregion\n//#region src/schemas/union/union.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction union(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: union,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/unionAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction unionAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: unionAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/unknown/unknown.ts\n/**\n* Creates a unknown schema.\n*\n* @returns A unknown schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unknown() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"unknown\",\n\t\treference: unknown,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variant.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variant(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variant,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true }).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tparseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variantAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variantAsync(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variantAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = async (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") await parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? (await discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true })).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tawait parseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/void/void.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction void_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"void\",\n\t\treference: void_,\n\t\texpects: \"void\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/keyof/keyof.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction keyof(schema, message$1) {\n\treturn /* @__PURE__ */ picklist(Object.keys(schema.entries), message$1);\n}\n\n//#endregion\n//#region src/methods/message/message.ts\n/**\n* Changes the local message configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param message_ The error message.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction message(schema, message_) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config$1,\n\t\t\t\tmessage: message_\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/omit/omit.ts\n/**\n* Creates a modified copy of an object schema that does not contain the\n* selected entries.\n*\n* @param schema The schema to omit from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction omit(schema, keys) {\n\tconst entries$1 = { ...schema.entries };\n\tfor (const key of keys) delete entries$1[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/parse/parse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nfunction parse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parse/parseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nasync function parseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parser/parser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parser(schema, config$1) {\n\tconst func = (input) => parse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/parser/parserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parserAsync(schema, config$1) {\n\tconst func = (input) => parseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/partial/partial.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partial(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optional(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/partial/partialAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialAsync(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optionalAsync(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pick/pick.ts\n/**\n* Creates a modified copy of an object schema that contains only the selected\n* entries.\n*\n* @param schema The schema to pick from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction pick(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key of keys) entries$1[key] = schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipe.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipe(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipeAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipeAsync(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/required.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction required(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptional(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/requiredAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction requiredAsync(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptionalAsync(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function safeParseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParser(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParserAsync(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/summarize/summarize.ts\n/**\n* Summarize the error messages of issues in a pretty-printable multi-line string.\n*\n* @param issues The list of issues.\n*\n* @returns A summary of the issues.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction summarize(issues) {\n\tlet summary = \"\";\n\tfor (const issue of issues) {\n\t\tif (summary) summary += \"\\n\";\n\t\tsummary += `\u00D7 ${issue.message}`;\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) summary += `\\n  \u2192 at ${dotPath}`;\n\t}\n\treturn summary;\n}\n\n//#endregion\n//#region src/methods/unwrap/unwrap.ts\n/**\n* Unwraps the wrapped schema.\n*\n* @param schema The schema to be unwrapped.\n*\n* @returns The unwrapped schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unwrap(schema) {\n\treturn schema.wrapped;\n}\n\n//#endregion\nexport { BASE64_REGEX, BIC_REGEX, CUID2_REGEX, DECIMAL_REGEX, DIGITS_REGEX, EMAIL_REGEX, EMOJI_REGEX, HEXADECIMAL_REGEX, HEX_COLOR_REGEX, IMEI_REGEX, IPV4_REGEX, IPV6_REGEX, IP_REGEX, ISO_DATE_REGEX, ISO_DATE_TIME_REGEX, ISO_TIMESTAMP_REGEX, ISO_TIME_REGEX, ISO_TIME_SECOND_REGEX, ISO_WEEK_REGEX, MAC48_REGEX, MAC64_REGEX, MAC_REGEX, NANO_ID_REGEX, OCTAL_REGEX, RFC_EMAIL_REGEX, SLUG_REGEX, ULID_REGEX, UUID_REGEX, ValiError, _addIssue, _getByteCount, _getGraphemeCount, _getLastMetadata, _getStandardProps, _getWordCount, _isLuhnAlgo, _isValidObjectKey, _joinExpects, _stringify, any, args, argsAsync, array, arrayAsync, assert, awaitAsync, base64, bic, bigint, blob, boolean, brand, bytes, check, checkAsync, checkItems, checkItemsAsync, config, creditCard, cuid2, custom, customAsync, date, decimal, deleteGlobalConfig, deleteGlobalMessage, deleteSchemaMessage, deleteSpecificMessage, description, digits, email, emoji, empty, endsWith, entries, entriesFromList, entriesFromObjects, enum_ as enum, enum_, everyItem, exactOptional, exactOptionalAsync, examples, excludes, fallback, fallbackAsync, file, filterItems, findItem, finite, flatten, flavor, forward, forwardAsync, function_ as function, function_, getDefault, getDefaults, getDefaultsAsync, getDescription, getDotPath, getExamples, getFallback, getFallbacks, getFallbacksAsync, getGlobalConfig, getGlobalMessage, getMetadata, getSchemaMessage, getSpecificMessage, getTitle, graphemes, gtValue, hash, hexColor, hexadecimal, imei, includes, instance, integer, intersect, intersectAsync, ip, ipv4, ipv6, is, isOfKind, isOfType, isValiError, isoDate, isoDateTime, isoTime, isoTimeSecond, isoTimestamp, isoWeek, keyof, lazy, lazyAsync, length, literal, looseObject, looseObjectAsync, looseTuple, looseTupleAsync, ltValue, mac, mac48, mac64, map, mapAsync, mapItems, maxBytes, maxEntries, maxGraphemes, maxLength, maxSize, maxValue, maxWords, message, metadata, mimeType, minBytes, minEntries, minGraphemes, minLength, minSize, minValue, minWords, multipleOf, nan, nanoid, never, nonEmpty, nonNullable, nonNullableAsync, nonNullish, nonNullishAsync, nonOptional, nonOptionalAsync, normalize, notBytes, notEntries, notGraphemes, notLength, notSize, notValue, notValues, notWords, null_ as null, null_, nullable, nullableAsync, nullish, nullishAsync, number, object, objectAsync, objectWithRest, objectWithRestAsync, octal, omit, optional, optionalAsync, parse, parseAsync, parseJson, parser, parserAsync, partial, partialAsync, partialCheck, partialCheckAsync, pick, picklist, pipe, pipeAsync, promise, rawCheck, rawCheckAsync, rawTransform, rawTransformAsync, readonly, record, recordAsync, reduceItems, regex, required, requiredAsync, returns, returnsAsync, rfcEmail, safeInteger, safeParse, safeParseAsync, safeParser, safeParserAsync, set, setAsync, setGlobalConfig, setGlobalMessage, setSchemaMessage, setSpecificMessage, size, slug, someItem, sortItems, startsWith, strictObject, strictObjectAsync, strictTuple, strictTupleAsync, string, stringifyJson, summarize, symbol, title, toBigint, toBoolean, toDate, toLowerCase, toMaxValue, toMinValue, toNumber, toString, toUpperCase, transform, transformAsync, trim, trimEnd, trimStart, tuple, tupleAsync, tupleWithRest, tupleWithRestAsync, ulid, undefined_ as undefined, undefined_, undefinedable, undefinedableAsync, union, unionAsync, unknown, unwrap, url, uuid, value, values, variant, variantAsync, void_ as void, void_, words };", "import m from \"mithril\";\nimport { asUrn, TribbleDB } from \"@rgrannell1/tribbledb\";\nimport type { TripleObject } from \"@rgrannell1/tribbledb\";\nimport { ThingLink } from \"../components/thing-link.ts\";\nimport type { ThingLinkAttrs } from \"../components/thing-link.ts\";\nimport { one } from \"../commons/arrays.ts\";\n\n/*\n * Read a thing as an undifferentiated TripleObject\n * by URN\n */\nexport function readThing(\n  tdb: TribbleDB,\n  urn: string,\n): TripleObject | undefined {\n  const { id, type } = asUrn(urn);\n\n  return tdb.search({\n    source: { id, type },\n  }).firstObject();\n}\n\n/*\n * Read and parse a thing by URN\n */\nexport function readParsedThing<T>(\n  parser: (tdb: TribbleDB, thing: TripleObject) => T | undefined,\n  tdb: TribbleDB,\n  id: string,\n): T | undefined {\n  const thing = readThing(tdb, id);\n  if (!thing) {\n    return undefined;\n  }\n\n  return parser(tdb, thing);\n}\n\n/*\n * Read an array of things by URN\n *\n * @param tdb TribbleDB instance\n * @param urns Set of URNs to read\n */\nexport function readThings(\n  tdb: TribbleDB,\n  urns: Set<string>,\n): TripleObject[] {\n  const things: TripleObject[] = [];\n\n  for (const urn of urns) {\n    const thing = readThing(tdb, urn);\n    if (thing) {\n      things.push(thing);\n    }\n  }\n\n  return things;\n}\n\n/*\n * Read an array of parsed things by URNs\n */\nexport const readParsedThings = function <T>(\n  parser: (tdb: TribbleDB, thing: TripleObject) => T | undefined,\n  tdb: TribbleDB,\n  urns: Set<string>,\n): T[] {\n  if (typeof parser !== \"function\") {\n    throw new Error(\"Parser must be a function\");\n  }\n\n  const parsedThings: T[] = [];\n\n  for (const urn of urns) {\n    const thing = readThing(tdb, urn);\n    if (!thing) {\n      continue;\n    }\n\n    const parsed = parser(tdb, thing);\n    if (parsed) {\n      parsedThings.push(parsed);\n    }\n  }\n\n  return parsedThings;\n};\n\n/*\n * Read all things of a given type that have a name\n */\nexport function readNamedTypeThings<T>(\n  tdb: TribbleDB,\n  type: string,\n): TripleObject[] {\n  const things = tdb.search({\n    source: { type },\n  }).objects();\n\n  return things\n    .filter((thing) => {\n      return Object.prototype.hasOwnProperty.call(thing, \"name\");\n    })\n    .sort((thinga, thingb) => {\n      const firstName = thinga.name;\n      const secondName = thingb.name;\n\n      const first = one(firstName) as string;\n      const second = one(secondName) as string;\n\n      return first.localeCompare(second);\n    });\n}\n\n// TODO: remove mithril, move to presenter folder!!\nexport function toThingLinks(\n  tdb: TribbleDB,\n  urns: (string | undefined)[],\n): m.Vnode<ThingLinkAttrs, {}>[] {\n  return urns.flatMap((urn) => {\n    if (!urn) {\n      return [];\n    }\n    const thing = readThing(tdb, urn);\n\n    if (!thing || !thing.name) {\n      return [];\n    }\n\n    return [m(ThingLink, { urn, thing })];\n  });\n}\n", "import m from \"mithril\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport { navigate } from \"../commons/events.ts\";\n\nimport { one } from \"../commons/arrays.ts\";\nimport { thingEmoji } from \"../services/emoji.ts\";\nimport type { Thing } from \"../types.ts\";\n\nexport type ThingLinkAttrs = {\n  urn: string;\n  thing: Thing;\n};\n\n/* */\nexport function ThingLink() {\n  return {\n    view(vnode: m.Vnode<ThingLinkAttrs>) {\n      const { urn, thing } = vnode.attrs;\n      const { type, id } = asUrn(urn);\n\n      let name = id;\n      if (Object.prototype.hasOwnProperty.call(thing, \"name\")) {\n        const candidate = one((thing as { name: string | string[] }).name);\n        if (candidate) {\n          name = candidate;\n        }\n      }\n\n      const emoji = thingEmoji(urn, name, thing);\n\n      return m(\"a\", {\n        href: urn,\n        onclick: navigate(`/thing/${type}:${id}`),\n        class: [\"thing-link\", `${type}-link`].join(\" \"),\n      }, `${emoji}\\t${name}`);\n    },\n  };\n}\n", "/*\n * Given a value, array of values, or undefined, return an array.\n * This is often required when dealing with relations that may have multiple values.\n */\nexport function arrayify<T>(value: T | T[] | undefined): T[] {\n  if (value === undefined) {\n    return [];\n  }\n\n  return Array.isArray(value) ? value : [value];\n}\n\n/*\n * Return the first value, or undefined. Often needed in cases where\n * a triple object theoretically could have multiple or missing values (e.g name)\n * but won't in practice.\n */\nexport function one<T>(value: T | T[] | undefined): T | undefined {\n  return Array.isArray(value) ? value[0] : value;\n}\n", "import { asUrn } from \"@rgrannell1/tribbledb\";\nimport { one } from \"../commons/arrays.ts\";\nimport {\n  CAMERA_MODELS,\n  KnownTypes,\n  PHONE_MODELS,\n  PLACE_FEATURES_TO_EMOJI,\n} from \"../constants.ts\";\nimport type { Thing } from \"../types.ts\";\n\n/*\n * Pick an emoji based on the place feature\n *\n * @param thing The place\n */\nexport function placeEmoji(thing: any): string {\n  const feature = one(thing.features);\n  const { id: featureId } = asUrn(feature);\n\n  if (\n    Object.prototype.hasOwnProperty.call(PLACE_FEATURES_TO_EMOJI, featureId)\n  ) {\n    return PLACE_FEATURES_TO_EMOJI[\n      featureId as keyof typeof PLACE_FEATURES_TO_EMOJI\n    ];\n  }\n\n  return \"\uD83D\uDCCD\";\n}\n\n/*\n * Load an emoji relating to a place (e.g church emoji for religious sites)\n */\nexport function placeFeatureEmoji(featureUrn: string): string {\n  const { id: featureId } = asUrn(featureUrn);\n\n  if (\n    Object.prototype.hasOwnProperty.call(PLACE_FEATURES_TO_EMOJI, featureId)\n  ) {\n    return PLACE_FEATURES_TO_EMOJI[\n      featureId as keyof typeof PLACE_FEATURES_TO_EMOJI\n    ];\n  }\n\n  return \"\uD83D\uDCCD\";\n}\n\n/*\n * Pick an flag based on the country definition\n *\n * @param thing The country thing\n */\nexport function countryEmoji(thing: any): string {\n  const flag = one(thing.flag);\n  return flag; //?? \"\uD83C\uDFF3\uFE0F\";\n}\n\n/*\n * Pick a bird emoji\n */\nfunction birdEmoji(): string {\n  return \"\uD83D\uDC24\";\n}\n\n/*\n * Pick an emoji for the camera\n *\n * @param thing The thing to get the emoji for, based on id\n */\nfunction cameraEmoji(thing: Thing): string {\n  const { id } = asUrn(thing.id);\n\n  if (CAMERA_MODELS.has(id)) {\n    return \"\uD83D\uDCF7\";\n  } else if (PHONE_MODELS.has(id)) {\n    return \"\uD83D\uDCF1\";\n  }\n\n  return \"\uD83D\uDCF7\";\n}\n\n/* */\nexport function thingEmoji(urn: string, _: string, thing: Thing): string {\n  const { type } = asUrn(urn);\n\n  switch (type) {\n    case KnownTypes.PLACE:\n      return placeEmoji(thing);\n    case KnownTypes.COUNTRY:\n      return countryEmoji(thing);\n    case KnownTypes.BIRD:\n      return birdEmoji();\n    case KnownTypes.CAMERA:\n      return cameraEmoji(thing);\n    case KnownTypes.PLACE_FEATURE:\n      return placeFeatureEmoji(urn);\n    default:\n      return \"\";\n  }\n}\n", "import {\n  asUrn,\n  type TribbleDB,\n  type TripleObject,\n} from \"@rgrannell1/tribbledb\";\nimport { logParseWarning } from \"../commons/logger.ts\";\nimport { type BaseSchema, type InferOutput, safeParse } from \"valibot\";\nimport { readParsedThing, readParsedThings } from \"./things.ts\";\nimport { one } from \"../commons/arrays.ts\";\n\ntype Parser<T> = (tdb: TribbleDB, thing: TripleObject) => T | undefined;\n\n/*\n * Create a parser for a specific schema.\n */\nexport function parseObject<\n  TSchema extends BaseSchema<unknown, unknown, any>,\n  TType extends string,\n>(\n  schema: TSchema,\n  type: TType,\n): (\n  _: TribbleDB,\n  object: TripleObject,\n) => (InferOutput<TSchema> & { type: TType }) | undefined {\n  return (_: TribbleDB, object: TripleObject) => {\n    const result = safeParse(schema, object);\n\n    if (!result.success) {\n      logParseWarning(result.issues);\n      return;\n    }\n\n    return { ...result.output as any, type } as InferOutput<TSchema> & {\n      type: TType;\n    };\n  };\n}\n\n/*\n * Create a parser that selects the appropriate parser based on the type of the object.\n */\nexport function parseByType<T>(\n  typeParsers: Record<string, Parser<T>>,\n): Parser<T> {\n  return (tdb: TribbleDB, thing: TripleObject) => {\n    const { type } = asUrn(one(thing.id)!);\n\n    const parser = typeParsers[type] ?? typeParsers[\"default\"];\n    if (!parser) {\n      return undefined;\n    }\n\n    return parser(tdb, thing);\n  };\n}\n\n/*\n * Create a one-item reader for a specific parser.\n */\nexport function readOne<T>(parser: Parser<T>) {\n  return (tdb: TribbleDB, id: string) => {\n    return readParsedThing(parser, tdb, id);\n  };\n}\n\n/*\n * Create a many-item reader for a specific parser.\n */\nexport function readMany<T>(parser: Parser<T>) {\n  if (typeof parser !== \"function\") {\n    throw new Error(\"Parser must be a function\");\n  }\n\n  return (tdb: TribbleDB, urns: Set<string>) => {\n    return readParsedThings(parser, tdb, urns);\n  };\n}\n\n/*\n * Create both one-item and many-item readers for a specific parser.\n */\nexport function readers<T>(parser: Parser<T>) {\n  return {\n    one: readOne(parser),\n    many: readMany(parser),\n  };\n}\n", "/*\n * Defines Zod schemas that we use to convert Tribble objects into something\n * with actual type-safety.\n */\n\nimport {\n  any,\n  array,\n  integer,\n  number,\n  object,\n  optional,\n  pipe,\n  string,\n  transform,\n  union,\n  url,\n} from \"valibot\";\n\nconst v = {\n  string,\n  array,\n  object,\n  optional,\n  union,\n  any,\n  pipe,\n  url,\n  integer,\n  number,\n  transform,\n};\n\nexport const AlbumSchema = v.object({\n  name: v.string(),\n  id: v.string(),\n  trip: v.optional(v.string()),\n  minDate: v.pipe(v.string(), v.transform(Number)),\n  maxDate: v.pipe(v.string(), v.transform(Number)),\n  thumbnailUrl: v.string(),\n  // TODO this is silly\n  mosaic: v.string(),\n  photosCount: v.pipe(v.string(), v.transform(Number)),\n  videosCount: v.pipe(v.string(), v.transform(Number)),\n  country: v.union([v.string(), v.array(v.string())]),\n  description: v.optional(v.string()),\n\n  // 200ms to compute on the client, so now it's precomputed\n  dateRange: v.string(),\n  shortDateRange: v.string(),\n});\n\nexport const CountrySchema = v.object({\n  id: v.string(),\n  flag: v.optional(v.string()),\n  name: v.string(),\n  contains: v.optional(v.union([v.string(), v.array(v.string())])),\n  in: v.optional(v.union([v.string(), v.array(v.string())])),\n});\n\nexport const UnescoSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  longitude: v.optional(v.string()),\n  latitude: v.optional(v.string()),\n});\n\nexport const PlaceSchema = v.object({\n  id: v.string(),\n  name: v.string(),\n  features: v.optional(v.union([v.string(), v.array(v.string())])),\n  in: v.optional(v.union([v.string(), v.array(v.string())])),\n  shortName: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n  unescoId: v.optional(v.string()),\n});\n\nexport const PhotoSchema = v.object({\n  albumId: v.string(),\n  country: v.optional(v.union([v.string(), v.array(v.string())])),\n  createdAt: v.string(),\n  subject: v.optional(v.union([v.string(), v.array(v.string())])),\n  exposureTime: v.optional(v.string()),\n  fStop: v.optional(v.string()),\n  focalLength: v.optional(v.string()),\n  fullImage: v.string(),\n  height: v.optional(v.string()),\n  id: v.string(),\n  iso: v.optional(v.string()),\n  location: v.optional(v.union([v.string(), v.array(v.string())])),\n  midImageLossyUrl: v.string(),\n  model: v.optional(v.string()),\n  mosaicColours: v.string(),\n  pngUrl: v.string(),\n  rating: v.string(),\n  style: v.optional(v.string()),\n  thumbnailUrl: v.string(),\n  width: v.optional(v.string()),\n  description: v.optional(v.string()),\n  summary: v.optional(v.string()),\n  contrastingGrey: v.string(),\n});\n\nexport const MammalSchema = v.object({\n  id: v.string(),\n  name: v.string(),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const ReptileSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const FishSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const AmphibianSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const InsectSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const SubjectSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const BirdSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n  birdwatchUrl: v.optional(v.union([v.string(), v.array(v.string())])),\n});\n\nexport const VideoSchema = v.object({\n  id: v.string(),\n  albumId: v.string(),\n  description: v.string(),\n  posterUrl: v.pipe(v.string(), v.url()),\n  videoUrl1080p: v.pipe(v.string(), v.url()),\n  videoUrl480p: v.pipe(v.string(), v.url()),\n  videoUrl720p: v.pipe(v.string(), v.url()),\n  videoUrlUnscaled: v.pipe(v.string(), v.url()),\n});\n\nexport const StatsSchema = v.object({\n  photos: v.pipe(v.number(), v.integer()),\n  videos: v.pipe(v.number(), v.integer()),\n  albums: v.pipe(v.number(), v.integer()),\n  years: v.pipe(v.number(), v.integer()),\n  countries: v.pipe(v.number(), v.integer()),\n  bird_species: v.pipe(v.number(), v.integer()),\n  mammal_species: v.pipe(v.number(), v.integer()),\n  amphibian_species: v.pipe(v.number(), v.integer()),\n  reptile_species: v.pipe(v.number(), v.integer()),\n  unesco_sites: v.pipe(v.number(), v.integer()),\n});\n\nexport const FeatureSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n});\n", "import { KnownTypes } from \"../constants.ts\";\nimport type {\n  Amphibian,\n  Bird,\n  Fish,\n  Insect,\n  Mammal,\n  Reptile,\n  Stats,\n} from \"../types.ts\";\nimport { parseByType, parseObject } from \"../commons/parser.ts\";\nimport {\n  AlbumSchema,\n  AmphibianSchema,\n  BirdSchema,\n  CountrySchema,\n  FeatureSchema,\n  FishSchema,\n  InsectSchema,\n  MammalSchema,\n  PhotoSchema,\n  PlaceSchema,\n  ReptileSchema,\n  StatsSchema,\n  UnescoSchema,\n  VideoSchema,\n} from \"../schemas.ts\";\nimport { safeParse } from \"valibot\";\nimport type { TribbleDB } from \"@rgrannell1/tribbledb\";\n\nexport const parseFeature = parseObject(FeatureSchema, \"feature\");\nexport const parseCountry = parseObject(CountrySchema, \"country\");\nexport const parseUnesco = parseObject(UnescoSchema, \"unesco\");\nexport const parsePhoto = parseObject(PhotoSchema, \"photo\");\nexport const parseBird = parseObject(BirdSchema, \"bird\");\nexport const parseMammal = parseObject(MammalSchema, \"mammal\");\nexport const parseReptile = parseObject(ReptileSchema, \"reptile\");\nexport const parseAmphibian = parseObject(AmphibianSchema, \"amphibian\");\nexport const parseInsect = parseObject(InsectSchema, \"insect\");\nexport const parseFish = parseObject(FishSchema, \"fish\");\nexport const parseVideo = parseObject(VideoSchema, \"video\");\nexport const parsePlace = parseObject(PlaceSchema, \"place\");\nexport const parseAlbum = parseObject(AlbumSchema, \"album\");\n\n/*\n * Parse known subject types\n */\nexport const parseSubject = parseByType<\n  Bird | Mammal | Reptile | Amphibian | Insect | Fish\n>({\n  [KnownTypes.BIRD]: parseBird,\n  [KnownTypes.MAMMAL]: parseMammal,\n  [KnownTypes.REPTILE]: parseReptile,\n  [KnownTypes.AMPHIBIAN]: parseAmphibian,\n  [KnownTypes.INSECT]: parseInsect,\n  [KnownTypes.FISH]: parseFish,\n});\n\n/*\n * Parse on object identified by a location relation\n */\nexport const parseLocation = parseByType<any>({\n  [KnownTypes.PLACE]: parsePlace,\n  [KnownTypes.COUNTRY]: parseCountry,\n  [KnownTypes.UNESCO]: parseUnesco,\n});\n\n/*\n * Parse stats object\n */\nexport function parseStats(stats: unknown): Stats | undefined {\n  return safeParse(StatsSchema, stats).success ? (stats as Stats) : undefined;\n}\n", "import { TribbleDB } from \"@rgrannell1/tribbledb\";\nimport { readers } from \"../commons/parser.ts\";\n\nimport {\n  parseAlbum,\n  parseAmphibian,\n  parseCountry,\n  parseFeature,\n  parseFish,\n  parseInsect,\n  parseLocation,\n  parseMammal,\n  parsePhoto,\n  parsePlace,\n  parseReptile,\n  parseSubject,\n  parseUnesco,\n  parseVideo,\n} from \"./parsers.ts\";\n\nexport const { one: readCountry, many: readCountries } = readers(parseCountry);\nexport const { one: readPlace, many: readPlaces } = readers(parsePlace);\nexport const { one: readLocation, many: readLocations } = readers(\n  parseLocation,\n);\nexport const { one: readUnesco, many: readUnescos } = readers(parseUnesco);\nexport const { one: readAlbum, many: readAlbums } = readers(parseAlbum);\nexport const { one: readMammal, many: readMammals } = readers(parseMammal);\nexport const { one: readReptile, many: readReptiles } = readers(parseReptile);\nexport const { one: readInsect, many: readInsects } = readers(parseInsect);\n// Thank you, english.\nexport const { one: readFish, many: readFishes } = readers(parseFish);\nexport const { one: readSubject, many: readSubjects } = readers(parseSubject);\nexport const { one: readAmphibian, many: readAmphibians } = readers(\n  parseAmphibian,\n);\nexport const { one: readVideo, many: readVideos } = readers(parseVideo);\nexport const { one: readPhoto, many: readPhotos } = readers(parsePhoto);\nexport const { one: readFeature, many: readFeatures } = readers(parseFeature);\n", "import { KnownRelations, PHOTO_WIDTH } from \"../constants.ts\";\nimport { asUrn, TribbleDB } from \"@rgrannell1/tribbledb\";\nimport type { Location, Photo, Subject } from \"../types.ts\";\nimport {\n  readLocations,\n  readPhoto,\n  readPhotos,\n  readSubjects,\n} from \"./readers.ts\";\n\n/*\n * Determine whether a photo should be eagerly or lazily loaded\n * depending on page position\n */\nexport function loadingMode(idx: number): \"eager\" | \"lazy\" {\n  const viewportWidth = (globalThis as any).innerWidth;\n  const viewportHeight = (globalThis as any).innerHeight;\n\n  const imageDimension = PHOTO_WIDTH;\n  const maxImagesPerRow = Math.floor(viewportWidth / imageDimension);\n  const maxRowsInFold = Math.floor(viewportHeight / imageDimension);\n\n  return idx > (maxImagesPerRow * maxRowsInFold) + 1 ? \"lazy\" : \"eager\";\n}\n\nconst COLOURS_CACHE: Map<string, string> = new Map();\n\n/*\n * Convert a mosaic colour string into a bitmap data URL\n *\n * This is extremely slow and blocking! 110ms\n */\nexport function encodeBitmapDataURL(colours: string): string {\n  if (COLOURS_CACHE.has(colours)) {\n    return COLOURS_CACHE.get(colours) as string;\n  }\n\n  const coloursList = colours.split(\"#\").map((colour: string) => `#${colour}`);\n  const canvas = (window as any).document.createElement(\"canvas\");\n  canvas.width = 2;\n  canvas.height = 2;\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    throw new Error(\"context missing\");\n  }\n  ctx.fillStyle = coloursList[1];\n  ctx.fillRect(0, 0, 1, 1);\n  ctx.fillStyle = coloursList[2];\n  ctx.fillRect(1, 0, 1, 1);\n  ctx.fillStyle = coloursList[3];\n  ctx.fillRect(0, 1, 1, 1);\n  ctx.fillStyle = coloursList[4];\n  ctx.fillRect(1, 1, 1, 1);\n\n  COLOURS_CACHE.set(colours, canvas.toDataURL(\"image/png\"));\n  return COLOURS_CACHE.get(colours) as string;\n}\n\n/*\n * Read all photos, sorted by date\n */\nexport function readAllPhotos(tdb: TribbleDB): Photo[] {\n  const photos = tdb.search({\n    source: { type: \"photo\" },\n  }).sources();\n\n  return readPhotos(tdb, photos).sort((photoa, photob) => {\n    return parseInt(photob.createdAt) - parseInt(photoa.createdAt);\n  });\n}\n\n/*\n * Read the locations and subjects associated with a set of photo ids\n */\nexport function readThingsByPhotoIds(tdb: TribbleDB, photoIds: Set<string>): {\n  locations: Location[];\n  subjects: Subject[];\n} {\n  const locations = new Set<string>();\n  const subjects = new Set<string>();\n\n  for (const photoId of photoIds) {\n    const pid = asUrn(photoId);\n\n    const obj = tdb.search({\n      source: { type: pid.type, id: pid.id },\n      relation: [KnownRelations.LOCATION, KnownRelations.SUBJECT],\n    }).firstObject(true);\n\n    if (!obj) {\n      continue;\n    }\n\n    const location = obj?.location ?? [];\n    const subject = obj?.subject ?? [];\n\n    for (const loc of location) {\n      locations.add(loc);\n    }\n    for (const subj of subject) {\n      subjects.add(subj);\n    }\n  }\n\n  return {\n    subjects: readSubjects(tdb, subjects),\n    locations: readLocations(tdb, locations),\n  };\n}\n\n/* */\nexport function readPhotosByThingIds(\n  tdb: TribbleDB,\n  thingsUrns: Set<string>,\n): Photo[] {\n  const photoIds = new Set<string>();\n\n  for (const thingUrn of thingsUrns) {\n    const { type, id } = asUrn(thingUrn);\n\n    const results = tdb.search({\n      source: { type: \"photo\" },\n      //relation: KnownRelations.SUBJECT, TODO\n      target: { type, id },\n    }).sources();\n\n    for (const result of results) {\n      photoIds.add(result);\n    }\n  }\n\n  return readPhotos(tdb, photoIds).sort((photoa, photob) => {\n    return parseInt(photob.createdAt) - parseInt(photoa.createdAt);\n  });\n}\n\nexport function readThingCover(\n  tdb: TribbleDB,\n  thingUrn: string,\n): Photo | undefined {\n  const { type, id } = asUrn(thingUrn);\n\n  const source = tdb.search({\n    source: { type: \"photo\" },\n    relation: \"cover\",\n    target: { type, id },\n  }).firstSource();\n\n  return source ? readPhoto(tdb, source) : undefined;\n}\n\nfunction sortByRating(photoa: Photo, photob: Photo) {\n  const ratingA = photoa.rating;\n  const ratingB = photob.rating;\n\n  return ratingB.toLocaleString().localeCompare(ratingA.toLocaleString());\n}\n\n/*\n * Read a cover image for a thing\n */\nexport function chooseThingCover(\n  tdb: TribbleDB,\n  thingUrn: string,\n) {\n  const { type, id } = asUrn(thingUrn);\n\n  const cover = readThingCover(tdb, thingUrn);\n  if (cover) {\n    return cover;\n  }\n\n  const results = tdb.search({\n    source: { type: \"photo\" },\n    target: { type, id },\n  }).sources();\n\n  const photos = readPhotos(tdb, new Set(results)).sort(sortByRating);\n\n  return photos.length > 0 ? photos[0] : null;\n}\n", "import { asUrn, TribbleDB } from \"@rgrannell1/tribbledb\";\nimport type { Album } from \"../types.ts\";\nimport type { Photo, Video } from \"../types.ts\";\nimport { readThingsByPhotoIds } from \"./photos.ts\";\nimport { readPhotos } from \"./readers.ts\";\nimport { KnownRelations, KnownTypes } from \"../constants.ts\";\nimport { readAlbums, readVideos } from \"./readers.ts\";\n\n/*\n * Get the album date\n */\nexport function albumYear(album: Album): number {\n  return new Date(album.minDate).getFullYear();\n}\n\n/*\n * Read albums from the TribbleDB\n */\nexport function readAllAlbums(tdb: TribbleDB): Album[] {\n  const ids = tdb.search({\n    source: { type: KnownTypes.ALBUM },\n  }).sources();\n\n  return (readAlbums(tdb, ids) as Album[])\n    .sort((album0: Album, album1: Album) => {\n      return album1.minDate - album0.minDate;\n    });\n}\n\n/*\n * Get the photo IDs associated with an album ID\n *\n * @param tdb TribbleDB instance\n * @param id Album URN\n */\nexport function readAlbumPhotoIds(tdb: TribbleDB, id: string): Set<string> {\n  return tdb.search({\n    source: { type: KnownTypes.PHOTO },\n    relation: KnownRelations.ALBUM_ID,\n    target: { id: asUrn(id).id },\n  }).sources();\n}\n\n/*\n * Read photos associated with an album\n *\n * @param tdb TribbleDB instance\n * @param id Album URN\n */\nexport function readAlbumPhotosByAlbumId(tdb: TribbleDB, id: string): Photo[] {\n  return readPhotos(tdb, readAlbumPhotoIds(tdb, id));\n}\n\n/*\n * Read videos associated with an album\n *\n * @param tdb TribbleDB instance\n * @param id Album URN\n */\nexport function readAlbumVideoIds(tdb: TribbleDB, id: string): Set<string> {\n  return tdb.search({\n    source: { type: KnownTypes.VIDEO },\n    relation: KnownRelations.ALBUM_ID,\n    target: { id: asUrn(id).id },\n  }).sources();\n}\n\n/*\n * Read videos associated with an album\n *\n * @param tdb TribbleDB instance\n * @param id Album URN\n */\nexport function readAlbumVideosByAlbumId(tdb: TribbleDB, id: string): Video[] {\n  return readVideos(tdb, readAlbumVideoIds(tdb, id));\n}\n\n/*\n * Photos in an album are associated with places (`location` relation) and\n * with subjects (`subject` relation). This function enumerates information on all of the\n * things in an album via the relation\n *\n * (x) -> [:subject|:location] -> (:photo) - [:albumId] -> (id:album)\n */\nexport function readThingsByAlbumId(tdb: TribbleDB, id: string) {\n  return readThingsByPhotoIds(tdb, readAlbumPhotoIds(tdb, id));\n}\n\n/*\n * Read albums associated with a set of thing IDs\n */\nexport function readAlbumsByThingIds(\n  tdb: TribbleDB,\n  thingsUrns: Set<string>,\n) {\n  const photoIds = new Set<string>();\n\n  // first, collect photo-ids associated with the things\n  for (const thingUrn of thingsUrns) {\n    const { type, id } = asUrn(thingUrn);\n\n    const results = tdb.search({ target: { type, id } }).sources();\n\n    for (const result of results) {\n      photoIds.add(result);\n    }\n  }\n\n  const albumIds = new Set<string>();\n\n  // next, collect album-ids associated with the photos\n  for (const photoId of photoIds) {\n    const pid = asUrn(photoId);\n\n    const albums = tdb.search({\n      source: { type: pid.type, id: pid.id },\n      relation: KnownRelations.ALBUM_ID,\n    }).targets();\n\n    for (const id of albums) {\n      albumIds.add(`urn:r\u00F3:album:${id}`);\n    }\n  }\n\n  return readAlbums(tdb, albumIds);\n}\n", "/*\n * Handle name lookups\n */\n\nimport { TribbleDB } from \"@rgrannell1/tribbledb\";\nimport { KnownRelations } from \"../constants.ts\";\n\nconst NAME_TO_URN_CACHE: Map<string, string> = new Map();\n\n/*\n * Convert names to tribble URNs\n *\n * @param tdb - The TribbleDB instance\n * @param names - A set of names to convert\n *\n * @returns A set of corresponding URNs\n */\nexport function namesToUrns(tdb: TribbleDB, names: Set<string>): Set<string> {\n  const urns: Set<string> = new Set();\n  if (names.size === 0) {\n    return urns;\n  }\n\n  // lookup cached names first\n  for (const name of names) {\n    if (NAME_TO_URN_CACHE.has(name)) {\n      const cachedUrn = NAME_TO_URN_CACHE.get(name);\n      if (cachedUrn) {\n        urns.add(cachedUrn);\n      }\n    }\n  }\n\n  // if all names are cached, don't query TDB at all,\n  // since this method is slow\n  if (urns.size === names.size) {\n    return urns;\n  }\n\n  const namesCursor = tdb.search({\n    relation: KnownRelations.NAME,\n    target: Array.from(names),\n  });\n\n  for (const [urn, _, name] of namesCursor.triples()) {\n    if (names.has(name as string)) {\n      urns.add(urn as string);\n    }\n  }\n\n  return urns;\n}\n", "import type { AppWindow, State } from \"./types.ts\";\nimport * as DarkMode from \"./services/dark-mode.ts\";\nimport { loadTriples } from \"./semantic/data.ts\";\nimport {\n  deriveTriples,\n  HARD_CODED_TRIPLES,\n  postIndexing,\n} from \"./semantic/derive.ts\";\nimport { TribbleDB } from \"@rgrannell1/tribbledb\";\n\nimport { readAlbumsByThingIds } from \"./services/albums.ts\";\nimport {\n  readAlbum,\n  readAmphibian,\n  readCountries,\n  readCountry,\n  readFeatures,\n  readInsect,\n  readLocation,\n  readLocations,\n  readMammal,\n  readPhoto,\n  readPhotos,\n  readPlace,\n  readReptile,\n  readUnesco,\n  readUnescos,\n  readVideo,\n} from \"./services/readers.ts\";\nimport { chooseThingCover, readPhotosByThingIds } from \"./services/photos.ts\";\nimport { readThings, toThingLinks } from \"./commons/things.ts\";\nimport { namesToUrns } from \"./services/names.ts\";\n\n/*\n * Load data from the tribbles file.\n * This is ccurrently done in a single blocking load which is not efficient.\n */\nasync function loadData() {\n  const schema = {};\n  const tdb = await loadTriples(\n    `/manifest/tribbles.${(window as AppWindow).envConfig.publication_id}.txt`,\n    schema,\n    deriveTriples,\n  );\n\n  postIndexing(tdb);\n\n  tdb.add(HARD_CODED_TRIPLES);\n\n  return tdb;\n}\n\n/*\n * Commonly used services that depend on state\n *\n * This is not pleasant, though I don't see a simpler method.\n */\nexport function loadServices(tdb: TribbleDB) {\n  return {\n    readThing: tdb.readThing,\n    readAlbum: readAlbum.bind(null, tdb),\n    readCountry: readCountry.bind(null, tdb),\n    readPlace: readPlace.bind(null, tdb),\n    readPhoto: readPhoto.bind(null, tdb),\n    readMammal: readMammal.bind(null, tdb),\n    readReptile: readReptile.bind(null, tdb),\n    readAmphibian: readAmphibian.bind(null, tdb),\n    readInsect: readInsect.bind(null, tdb),\n    readVideo: readVideo.bind(null, tdb),\n    readLocation: readLocation.bind(null, tdb),\n    readUnesco: readUnesco.bind(null, tdb),\n    readLocations: readLocations.bind(null, tdb),\n    readFeatures: readFeatures.bind(null, tdb),\n    readPhotos: readPhotos.bind(null, tdb),\n    readUnescos: readUnescos.bind(null, tdb),\n    readThings: readThings.bind(null, tdb),\n    readCountries: readCountries.bind(null, tdb),\n    namesToUrns: namesToUrns.bind(null, tdb),\n    readThingCover: chooseThingCover.bind(null, tdb),\n    readPhotosByThingIds: readPhotosByThingIds.bind(null, tdb),\n    readAlbumsByThingIds: readAlbumsByThingIds.bind(null, tdb),\n    toThingLinks: toThingLinks.bind(null, tdb),\n  };\n}\n\n/*\n * Load the application state from localStorage or return defaults.\n */\nexport async function loadState(): Promise<State> {\n  const data = await loadData();\n\n  return {\n    currentAlbum: undefined,\n    currentPhoto: undefined,\n    currentUrn: undefined,\n    currentType: undefined,\n    data,\n    darkMode: DarkMode.load(),\n    sidebarVisible: false,\n    services: loadServices(data),\n  };\n}\n", "import m from \"mithril\";\nimport { navigate } from \"../commons/events.ts\";\n\ntype SidebarItemAttrs = {\n  name: string;\n  route: string;\n};\n\ntype SidebarAttrs = {\n  visible: boolean;\n};\n\n/*\n * Defines each item in the sidebar\n */\nfunction SidebarItem() {\n  return {\n    view(vnode: m.Vnode<SidebarItemAttrs>) {\n      return m(\"li\", {\n        class: \"sidebar-item\",\n        onclick: navigate(vnode.attrs.route),\n      }, vnode.attrs.name);\n    },\n  };\n}\n\n/*\n * Defines the app sidebar\n */\nexport function Sidebar() {\n  function classes(visible: boolean) {\n    const cls = [\"photo-sidebar\"];\n    if (visible) {\n      cls.push(\"sidebar-visible\");\n    }\n    return cls.join(\" \");\n  }\n\n  return {\n    view(vnode: m.Vnode<SidebarAttrs>) {\n      return m(\"aside\", { class: classes(vnode.attrs.visible) }, [\n        m(\"nav\", [\n          m(\"ul\", [\n            m(SidebarItem, { name: \"PHOTOS\", route: \"/photos\" }),\n            m(SidebarItem, { name: \"VIDEOS\", route: \"/videos\" }),\n            m(SidebarItem, { name: \"ALBUMS\", route: \"/albums\" }),\n            m(SidebarItem, { name: \"LISTINGS\", route: \"/listings\" }),\n            m(SidebarItem, { name: \"ABOUT\", route: \"/about\" }),\n          ]),\n        ]),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { AlbumStats } from \"../components/album-stats.ts\";\nimport type { Album, Services } from \"../types.ts\";\nimport { encodeBitmapDataURL, loadingMode } from \"../services/photos.ts\";\nimport { PhotoAlbumMetadata } from \"../components/photo-album-metadata.ts\";\nimport { PhotoAlbum } from \"../components/photo-album.ts\";\nimport { setTitle } from \"../services/window.ts\";\nimport { CountryLink } from \"../components/place-links.ts\";\nimport { block, broadcast } from \"../commons/events.ts\";\nimport { albumYear } from \"../services/albums.ts\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport { setify } from \"../commons/sets.ts\";\n\ntype AlbumsListAttrs = {\n  albums: Album[];\n  services: Services;\n  visible: boolean;\n};\n\nfunction onAlbumClick(id: string, title: string, event: Event) {\n  const parsed = asUrn(id);\n\n  broadcast(\"navigate\", { route: `/album/${parsed.id}`, title });\n  block(event);\n}\n\nfunction drawAlbum(\n  state: { year: number },\n  album: Album,\n  idx: number,\n  services: Services,\n) {\n  const loading = loadingMode(idx);\n\n  const $albumComponents: m.Vnode<\n    unknown,\n    unknown\n  >[] = [];\n\n  // push year header if a new year\n  if (state.year !== albumYear(album)) {\n    state.year = albumYear(album);\n\n    if (state.year !== new Date().getFullYear()) {\n      const $h2 = m(\n        \"h2.album-year-heading\",\n        { key: `year-${state.year}` },\n        state.year.toString(),\n      );\n      $albumComponents.push($h2);\n    }\n  }\n\n  const $countryLinks = services.readCountries(setify(album.country)).map(\n    (country) => {\n      return m(CountryLink, {\n        country,\n        key: `album-country-${album.id}-${country.id}`,\n        mode: \"flag\",\n      });\n    },\n  );\n\n  const $md = m(PhotoAlbumMetadata, {\n    title: album.name,\n    minDate: album.minDate,\n    maxDate: album.maxDate,\n    count: album.photosCount,\n    countryLinks: $countryLinks,\n    services,\n    dateRange: album.dateRange,\n    shortDateRange: album.shortDateRange,\n  });\n\n  const $album = m(PhotoAlbum, {\n    trip: album.trip,\n    imageUrl: album.thumbnailUrl,\n    thumbnailUrl: album.thumbnailUrl,\n    thumbnailDataUrl: encodeBitmapDataURL(album.mosaic),\n    loading: loading,\n    minDate: album.minDate,\n    onclick: onAlbumClick.bind(null, album.id, album.name),\n  });\n\n  $albumComponents.push(\n    m(\"div\", {\n      key: `album-${album.id}`,\n    }, [\n      $album,\n      $md,\n    ]),\n  );\n\n  return $albumComponents;\n}\n\n/*\n * Construct a list of albums\n */\nfunction AlbumsList() {\n  return {\n    view(vnode: m.Vnode<AlbumsListAttrs>) {\n      const state = { year: 2005 };\n      const { albums, services } = vnode.attrs;\n\n      const $albumComponents: m.Vnode<\n        unknown,\n        unknown\n      >[] = [];\n\n      // TODO this blocks render too long\n      for (let idx = 0; idx < albums.length; idx++) {\n        $albumComponents.push(...drawAlbum(state, albums[idx], idx, services));\n      }\n\n      return m(\"section.album-container\", $albumComponents);\n    },\n  };\n}\n\ntype AlbumsPageAttrs = {\n  albums: Album[];\n  services: Services;\n  visible: boolean;\n};\n\n/* */\nexport function AlbumsPage() {\n  return {\n    oninit() {\n      setTitle(\"Albums - photos\");\n    },\n    view(vnode: m.Vnode<AlbumsPageAttrs>) {\n      const { albums, services, visible } = vnode.attrs;\n\n      const $md = m(\"section.album-metadata\", [\n        m(\"h1.albums-header\", \"Albums\"),\n        m(AlbumStats),\n      ]);\n\n      return m(\"div\", {\n        class: visible ? \"page sidebar-visible\" : \"page\",\n      }, [\n        $md,\n        //m(YearCursor),\n        m(AlbumsList, { albums, services, visible }),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { AppWindow } from \"../types.ts\";\nimport { parseStats } from \"../services/parsers.ts\";\n\n/*\n * Show statistics and links for the album pages\n */\nexport function AlbumStats() {\n  const stats = parseStats((window as AppWindow).stats);\n\n  return {\n    view() {\n      if (!stats) {\n        return m(\"p\");\n      }\n\n      return m(\"p.photo-stats\", [\n        `${stats.photos} `,\n        m(\"a\", { href: \"#/photos\" }, \"photos\"),\n        \" \u00B7 \",\n        `${stats.videos} `,\n        m(\"a\", { href: \"#/videos\" }, \"videos\"),\n        \" \u00B7 \",\n        `${stats.albums} albums \u00B7 ${stats.years} years \u00B7 `,\n        `${stats.countries} `,\n        m(\"a\", { href: \"#/listing/country\" }, \"countries\"),\n        \" \u00B7 \",\n        `${stats.bird_species} `,\n        m(\"a\", { href: \"#/listing/bird\" }, \"bird species\"),\n        \" \u00B7 \",\n        `${stats.mammal_species} `,\n        m(\"a\", { href: \"#/listing/mammal\" }, \"mammal species\"),\n        \" \u00B7 a few \",\n        m(\"a\", { href: \"#/listing/amphibian\" }, \"amphibians\"),\n        \" and \",\n        m(\"a\", { href: \"#/listing/reptile\" }, \"reptiles\"),\n        \" \u00B7 \",\n        `${stats.unesco_sites} `,\n        m(\"a\", { href: \"#/thing/unesco:*\" }, \"UNESCO sites\"),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { isSmallerThan } from \"../services/window.ts\";\nimport type { CountryLinkAttrs } from \"./place-links.ts\";\nimport { SMALL_DEVICE_WIDTH } from \"../constants.ts\";\nimport type { Services } from \"../types.ts\";\n\nexport type PhotoAlbumMetadataAttrs = {\n  title: string;\n  minDate?: number;\n  maxDate?: number;\n  count: number;\n  countryLinks: m.Vnode<CountryLinkAttrs, unknown>[];\n  dateRange: string;\n  shortDateRange: string;\n};\n\n/* */\nexport function PhotoAlbumMetadata() {\n  return {\n    view(vnode: m.Vnode<PhotoAlbumMetadataAttrs>) {\n      const {\n        title,\n        minDate,\n        maxDate,\n        count,\n        countryLinks,\n        dateRange,\n        shortDateRange,\n      } = vnode.attrs;\n      const text = count === 1 ? \"photo\" : \"photos\";\n      const isSmall = isSmallerThan(SMALL_DEVICE_WIDTH);\n\n      const dateRangeText = isSmall ? shortDateRange : dateRange;\n\n      return m(\"div.photo-album-metadata\", [\n        m(\"p.photo-album-title\", title),\n        m(\"p.photo-album-date\", [\n          m(\"time\", dateRangeText),\n        ]),\n        m(\"div.photo-metadata-inline\", [\n          m(\"p.photo-album-count\", `${count} ${text}`),\n          m(\"p.photo-album-countries\", countryLinks),\n        ]),\n      ]);\n    },\n  };\n}\n", "/*\n * Window lookup\n */\n\nimport { SMALL_DEVICE_WIDTH } from \"../constants\";\n\n/*\n * Check if the window is smaller than a given width\n * used to detect a mobile device\n */\nexport function isSmallerThan(width: number = SMALL_DEVICE_WIDTH): boolean {\n  return globalThis.matchMedia(`(max-width: ${width}px)`).matches;\n}\n\n/*\n * Set the page's title\n */\nexport function setTitle(title: string) {\n  document.title = title;\n}\n", "import m from \"mithril\";\nimport { ImagePair } from \"./photo.ts\";\n\n// use this to keep track of trips, to assign each a\n// colour distinct from the adjacent ones\nconst TRIPS: string[] = [];\n\nfunction TripTag() {\n  return {\n    view(vnode: m.Vnode<{ trip: string | undefined }>) {\n      const { trip } = vnode.attrs;\n\n      if (!trip) {\n        return null;\n      }\n\n      if (!TRIPS.includes(trip)) {\n        TRIPS.push(trip);\n      }\n\n      // two colours supported\n      const tripIndex = TRIPS.indexOf(trip);\n      return m(\"div.trip-tag .trip-color-\" + (tripIndex % 2));\n    },\n  };\n}\n\nexport type PhotoAlbumAttrs = {\n  trip: string | undefined;\n  imageUrl: string;\n  thumbnailUrl: string;\n  thumbnailDataUrl: string;\n  loading: \"eager\" | \"lazy\";\n  child?: m.Children;\n  onclick?: (e: Event) => void;\n  minDate?: number;\n};\n\n/* */\nexport function PhotoAlbum() {\n  return {\n    view(vnode: m.Vnode<PhotoAlbumAttrs>) {\n      const {\n        imageUrl,\n        thumbnailUrl,\n        thumbnailDataUrl,\n        loading,\n        child,\n        minDate,\n        onclick,\n        trip,\n      } = vnode.attrs;\n\n      return m(\"div.photo-album\", { \"data-min-date\": minDate }, [\n        m(TripTag, { trip }),\n        m(ImagePair, {\n          imageUrl,\n          thumbnailUrl,\n          thumbnailDataUrl,\n          loading,\n          onclick,\n        }),\n        // NODE this might be broken\n        child,\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { parseUrn } from \"@rgrannell1/tribbledb\";\n\nimport { block, broadcast } from \"../commons/events.ts\";\nimport { MetadataIcon } from \"./metadata-icon.ts\";\nimport { PHOTO_HEIGHT, PHOTO_WIDTH } from \"../constants.ts\";\nimport { encodeBitmapDataURL } from \"../services/photos.ts\";\nimport type { Photo as PhotoType } from \"../types.ts\";\n\n/*\n * Broadcast an event when a photo loads, and swap out the placeholder\n */\nfunction loadImage(url: string, event: Event) {\n  broadcast(\"photo_loaded\", { url });\n\n  const $placeholder = (event.target as HTMLElement)?.parentNode\n    ?.querySelector(\n      \".thumbnail-placeholder\",\n    ) as HTMLElement;\n\n  if (!$placeholder) {\n    return;\n  }\n\n  $placeholder.style.zIndex = \"-1\";\n}\n\ntype ImageAttrs = {\n  thumbnailUrl: string;\n  loading: \"eager\" | \"lazy\";\n  onclick: ((e: Event) => void) | undefined;\n};\n\n/*\n * The thumbnail image itself\n */\nfunction Image() {\n  return {\n    view(vnode: m.Vnode<ImageAttrs>) {\n      const { thumbnailUrl, loading, onclick } = vnode.attrs;\n\n      return m(\"img.thumbnail-image\", {\n        onload: loadImage.bind(null, thumbnailUrl),\n        width: PHOTO_WIDTH,\n        height: PHOTO_HEIGHT,\n        src: thumbnailUrl,\n        loading: loading,\n        onclick,\n      });\n    },\n  };\n}\n\ntype PlaceholderImageAttrs = {\n  thumbnailDataUrl: string;\n};\n\n/*\n * The placeholder data URL\n */\nfunction PlaceholderImage() {\n  return {\n    view(vnode: m.Vnode<PlaceholderImageAttrs>) {\n      const { thumbnailDataUrl } = vnode.attrs;\n\n      return m(\"img.u-photo.thumbnail-image.thumbnail-placeholder\", {\n        width: PHOTO_WIDTH,\n        height: PHOTO_HEIGHT,\n        src: thumbnailDataUrl,\n      });\n    },\n  };\n}\n\ntype ImagePairAttrs = {\n  imageUrl: string;\n  thumbnailUrl: string;\n  thumbnailDataUrl: string;\n  loading: \"eager\" | \"lazy\";\n  onclick: ((e: Event) => void) | undefined;\n};\n\n/*\n * The underlying pair of images. One is the actual thumbnail, which\n * takes time to load. The other will be a grid data URL that instantly loads.\n */\nexport function ImagePair() {\n  return {\n    view(vnode: m.Vnode<ImagePairAttrs>) {\n      const {\n        imageUrl,\n        thumbnailUrl,\n        thumbnailDataUrl,\n        loading,\n        onclick,\n      } = vnode.attrs;\n\n      return m(\"a\", {\n        href: imageUrl,\n        target: \"_blank\",\n        rel: \"external\",\n      }, [\n        m(PlaceholderImage, { thumbnailDataUrl }),\n        m(Image, { thumbnailUrl, loading, onclick }),\n      ]);\n    },\n  };\n}\n\n/* */\nfunction formatId(id: string): string {\n  return id.startsWith(\"urn:\") ? parseUrn(id).id : id;\n}\n\nexport type PhotoAttrs = {\n  photo: PhotoType;\n  loading: \"eager\" | \"lazy\";\n  interactive?: boolean;\n};\n\n/*\n * Represents a photo, with a metadata link and the fake-progressive-loading\n * features (https://rgrannell.xyz/replacing-google-photos) to make images appear blank for\n * less time.\n */\nexport function Photo() {\n  return {\n    view(vnode: m.Vnode<PhotoAttrs>) {\n      const { photo, loading, interactive } = vnode.attrs;\n      const id = formatId(photo.id);\n      const {\n        fullImage,\n        thumbnailUrl,\n        mosaicColours,\n      } = photo;\n\n      // encode a grid of colours into a data URL\n      const thumbnailDataUrl = encodeBitmapDataURL(mosaicColours);\n\n      const $mdIcon = m(MetadataIcon, { id, colour: photo.contrastingGrey });\n      const $imagePair = m(ImagePair, {\n        imageUrl: photo.fullImage,\n        thumbnailUrl,\n        thumbnailDataUrl,\n        loading,\n        onclick: () => {\n          window.location.href = fullImage;\n        },\n      });\n\n      return m(\n        \"div\",\n        m(\"div.photo\", {}, [\n          m(\n            \"a\",\n            { onclick: block },\n            interactive\n              ? [\n                $mdIcon,\n                $imagePair,\n              ]\n              : [$imagePair],\n          ),\n        ]),\n      );\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { broadcast } from \"../commons/events.ts\";\n\n/* */\nfunction InfoSVG() {\n  return {\n    view(vnode: m.Vnode<{ colour: string }>) {\n      const { colour } = vnode.attrs;\n\n      return m(\"svg.photo-icon\", {\n        height: 40,\n        width: 40,\n        preserveAspectRatio: \"xMinYMin\",\n        viewBox: \"-2 -2 24 24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n      }, [\n        m(\"path\", {\n          d: \"m10 20c-5.523 0-10-4.477-10-10s4.477-10 10-10 10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm0-10a1 1 0 0 1 1 1v5a1 1 0 0 1 -2 0v-5a1 1 0 0 1 1-1zm0-1a1 1 0 1 1 0-2 1 1 0 0 1 0 2z\",\n          fill: colour,\n        }),\n      ]);\n    },\n  };\n}\n\ntype MetadataIconAttrs = {\n  id: string;\n  colour: string;\n};\n\n/* */\nexport function MetadataIcon() {\n  return {\n    view(vnode: m.Vnode<MetadataIconAttrs>) {\n      const { id, colour } = vnode.attrs;\n\n      return m(\"div.photo-metadata-popover\", {\n        onclick: () => broadcast(\"navigate\", { route: `/photo/${id}` }),\n      }, m(InfoSVG, { colour }));\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { urnToUrl } from \"../models/urn.ts\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport { navigate } from \"../commons/events.ts\";\nimport { isACountry } from \"../types.ts\";\nimport type { Country, Place } from \"../types.ts\";\nimport { one } from \"../commons/arrays.ts\";\nimport { countryEmoji, placeEmoji } from \"../services/emoji.ts\";\n\nexport type CountryLinkAttrs = {\n  country: Country;\n  mode: \"flag\" | \"name\";\n};\n\n/*\n * Construct a link to a country. Reuse existing emoji lookup logic\n */\nexport function CountryLink() {\n  return {\n    view(vnode: m.Vnode<CountryLinkAttrs>) {\n      const { country, mode } = vnode.attrs;\n      const { id, name } = country;\n\n      if (!id) {\n        return m(\"p\");\n      }\n\n      const flag = countryEmoji(country);\n\n      const parsed = asUrn(id);\n      const onclick = navigate(`/thing/${parsed.type}:${parsed.id}`);\n\n      if (mode === \"flag\") {\n        return m(\"a.country-link-short\", { href: urnToUrl(id), onclick }, flag);\n      }\n\n      return m(\n        \"a.country-link\",\n        { href: urnToUrl(id), onclick },\n        `${flag} ${name}`,\n      );\n    },\n  };\n}\n\n/*\n * Create a link to a place. Reuse existing emoji lookup logic\n */\nexport function PlaceLink() {\n  return {\n    view(vnode: m.Vnode<{ location: Place; mode: \"flag\" | \"name\" }>) {\n      const { location, mode } = vnode.attrs;\n\n      let text = \"\";\n      if (mode === \"flag\") {\n        text = placeEmoji(location);\n      }\n\n      text = `${placeEmoji(location)} ${one(location.name) || \"Unknown Place\"}`;\n\n      return m(\"a.place-link\", {\n        href: urnToUrl(location.id),\n        onclick: navigate(`/thing/place:${location.id}`),\n      }, text);\n    },\n  };\n}\n\n/*\n * Create a link to a country / place\n */\nexport function LocationLink() {\n  return {\n    view(vnode: m.Vnode<{ location: Country | Place; mode: \"flag\" | \"name\" }>) {\n      const { location, mode } = vnode.attrs;\n\n      if (isACountry(location)) {\n        return m(CountryLink, { country: location, mode });\n      }\n\n      return m(PlaceLink, { location, mode });\n    },\n  };\n}\n", "import { asUrn } from \"@rgrannell1/tribbledb\";\n\n/*\n * Convert a URN into a URL for the thing page.\n */\nexport function urnToUrl(urn: string) {\n  const { type, id } = asUrn(urn);\n  return `#/thing/${type}:${id}`;\n}\n", "import type { TripleObject } from \"@rgrannell1/tribbledb\";\n\n/*\n * Given a value, array of values, or undefined, return a set.\n */\nexport function setify<T>(value: T | T[] | undefined): Set<T> {\n  if (value === undefined) {\n    return new Set();\n  }\n\n  return new Set(Array.isArray(value) ? value : [value]);\n}\n\n/*\n * Collect a set of property values from a list of triple objects.\n */\nexport function setOf<T>(property: string, objects: TripleObject[]): Set<T> {\n  const result = new Set<T>();\n\n  for (const obj of objects) {\n    if (property in obj) {\n      const value = obj[property] as T | T[] | undefined;\n      if (value === undefined) {\n        continue;\n      }\n\n      if (Array.isArray(value)) {\n        for (const elem of value) {\n          result.add(elem);\n        }\n      } else {\n        result.add(value);\n      }\n    }\n  }\n\n  return result;\n}\n", "import m from \"mithril\";\n\nimport { setTitle } from \"../services/window.ts\";\nimport { navigate } from \"../commons/events.ts\";\n\ntype AboutPageAttrs = {\n  visible: boolean;\n};\n\n/* */\nexport function AboutPage() {\n  return {\n    oninit() {\n      setTitle(\"About - photos\");\n    },\n    view(vnode: m.Vnode<AboutPageAttrs>) {\n      const { visible } = vnode.attrs;\n      const years = new Date().getFullYear() - 2012;\n\n      return m(\"div\", {\n        class: visible ? \"page sidebar-visible\" : \"page\",\n      }, [\n        m(\"section.about-page\", [\n          m(\"h1\", \"About\"),\n          m(\"br\"),\n          m(\n            \"p\",\n            `I started taking photos ${years} years ago, and have taken a lot of photos since. I've become, in my opinion, a reasonable wildlife photographer (though hit-or-miss at other styles of photography). I built this website to share the things`,\n            m(\"a\", {\n              href: \"https://photos.rgrannell.xyz/#/thing/rating:4\",\n              onclick: navigate(`/thing/rating:4`),\n            }, \" I found beautiful in this world.\"),\n          ),\n          m(\"h2\", \"Can I use the photos on this site?\"),\n          m(\n            \"p\",\n            \"You may use this website and its content for personal, non-commerical purposes only. For example, using photos as a desktop wallpaper is fine, selling these photos is not.\",\n          ),\n          m(\"h2\", \"Can I use data from this site to train AI?\"),\n          m(\n            \"p\",\n            \"No, absolutely not. The \",\n            m(\n              \"a\",\n              { href: \"http://photos.rgrannell.xyz/robots.txt\" },\n              \"robots.txt\",\n            ),\n            \" file for this site explicitly prohibits this.\",\n          ),\n          m(\"h2\", \"What is your contact information?\"),\n          m(\n            \"p\",\n            \"See \",\n            m(\"a\", { href: \"https://rgrannell.xyz/\" }, \"my personal site\"),\n            \" for contact details.\",\n          ),\n        ]),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Video as VideoType } from \"../types.ts\";\nimport { Video } from \"../components/video.ts\";\nimport type { VideoAttrs } from \"../components/video.ts\";\n\ntype VideosPageAttrs = {\n  videos: VideoType[];\n  visible: boolean;\n};\n\n/* */\nexport function VideosPage() {\n  return {\n    view(vnode: m.Vnode<VideosPageAttrs>) {\n      const { videos, visible } = vnode.attrs;\n      const videoLengthText = videos.length === 1\n        ? \"1 video\"\n        : `${videos.length} videos`;\n\n      const $videosList = videos.map((video) => {\n        return m(Video, { video, preload: \"auto\" } satisfies VideoAttrs);\n      });\n\n      return m(\n        \"div\",\n        {\n          class: visible ? \"page sidebar-visible\" : \"page\",\n        },\n        m(\"section.photos-metadata\", [\n          m(\"h1\", \"Videos\"),\n          m(\"p.photo-album-count\", videoLengthText),\n        ]),\n        m(\"section.photo-container\", $videosList),\n      );\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Video } from \"../types.ts\";\n\nexport type VideoAttrs = {\n  preload: string;\n  video: Video;\n};\n\n/* */\nexport function Video() {\n  return {\n    view(vnode: m.Vnode<VideoAttrs>) {\n      const {\n        preload,\n        video,\n      } = vnode.attrs;\n\n      if (!video) {\n        return m(\"div\", \"No video\");\n      }\n\n      const {\n        posterUrl,\n        videoUrl1080p,\n        videoUrl480p,\n        videoUrl720p,\n        videoUrlUnscaled,\n      } = video;\n\n      const $source = m(\"source\", {\n        src: videoUrl480p,\n        type: \"video/mp4\",\n      });\n\n      const $resolutionLinks = m(\"ul\", [\n        m(\"a\", { href: videoUrlUnscaled }, \"[L]\"),\n        m(\"a\", { href: videoUrl1080p }, \"[M]\"),\n        m(\"a\", { href: videoUrl720p }, \"[S]\"),\n        m(\"a\", { href: videoUrl480p }, \"[XS]\"),\n      ]);\n\n      return m(\"div\", { key: `video-${video.id}` }, [\n        m(\"video.thumbnail-video\", {\n          controls: true,\n          preload,\n          poster: posterUrl,\n        }, $source),\n        $resolutionLinks,\n      ]);\n    },\n  };\n}\n", "import { TribbleDB } from \"@rgrannell1/tribbledb\";\nimport type { Video } from \"../types.ts\";\nimport { readVideos } from \"./readers.ts\";\n\n/*\n * Read and parse a video by URNs\n *\n * @param tdb The TribbleDB instance\n *\n * @return The parsed videos\n */\nexport function readAllVideos(tdb: TribbleDB): Video[] {\n  const videos = tdb.search({\n    source: { type: \"video\" },\n  }).sources();\n\n  return readVideos(tdb, videos);\n}\n", "import m from \"mithril\";\nimport { isSmallerThan, setTitle } from \"../services/window.ts\";\nimport * as Dates from \"../services/dates.ts\";\nimport { AlbumShareButton } from \"../components/album-share-button.ts\";\nimport { CountryLink } from \"../components/place-links.ts\";\nimport { Video } from \"../components/video.ts\";\nimport type { VideoAttrs } from \"../components/video.ts\";\nimport { loadingMode } from \"../services/photos.ts\";\n\nimport type {\n  Album,\n  Country,\n  Photo as PhotoType,\n  Services,\n  Thing,\n  Video as VideoType,\n} from \"../types.ts\";\nimport { Photo } from \"../components/photo.ts\";\nimport type { PhotoAttrs } from \"../components/photo.ts\";\nimport { AlbumsButton } from \"../components/albums-button.ts\";\nimport { preprocessDescription } from \"../commons/strings.ts\";\nimport { setify } from \"../commons/sets.ts\";\nimport { SMALL_DEVICE_WIDTH } from \"../constants.ts\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\n\ntype AlbumAttrs = {\n  album: Album;\n  subjects: Thing[];\n  locations: Location[];\n  country: Country[];\n  photos: PhotoType[];\n  videos: VideoType[];\n  services: Services;\n  visible: boolean;\n};\n\n/* */\nexport function AlbumPage() {\n  return {\n    oninit() {\n      setTitle(\"Album - photos\");\n    },\n    view(vnode: m.Vnode<AlbumAttrs>) {\n      const {\n        album,\n        photos,\n        videos,\n        services,\n        visible,\n      } = vnode.attrs;\n\n      const {\n        name,\n        minDate,\n        maxDate,\n        photosCount,\n        description,\n        country,\n        dateRange,\n        shortDateRange,\n      } = album;\n\n      const dateRangeText = isSmallerThan(SMALL_DEVICE_WIDTH)\n        ? shortDateRange\n        : dateRange;\n\n      const photoCountMessage = photosCount === 1\n        ? \"1 photo\"\n        : `${photosCount} photos`;\n\n      const $countryLinks = services.readCountries(\n        services.namesToUrns(setify(country)),\n      ).map((country) => {\n        return m(CountryLink, {\n          country,\n          mode: \"flag\",\n        });\n      });\n\n      const { id } = asUrn(album.id);\n      const url = `https://sharephoto.rgrannell.xyz/album/${id}`;\n\n      const $albumMetadata = m(\"section.photos-metadata\", [\n        m(\"h1\", name),\n        m(\"p.photo-album-date\", m(\"time\", dateRangeText)),\n        m(\"p.photo-album-count\", photoCountMessage),\n        m(\"p.photo-album-countries\", $countryLinks),\n        m(\n          \"p.photo-album-description\",\n          m.trust(preprocessDescription(description ?? \"\") ?? \"\"),\n        ),\n        m(AlbumShareButton, { url, name }),\n        \" \",\n        m(AlbumsButton),\n        \" \",\n      ]);\n\n      const $photosList = photos.map((photo, idx) => {\n        return m(\n          Photo,\n          {\n            photo,\n            loading: loadingMode(idx),\n            interactive: true,\n          } satisfies PhotoAttrs,\n        );\n      });\n      const $videosList = videos.map((video) => {\n        return m(Video, { video, preload: \"auto\" } satisfies VideoAttrs);\n      });\n\n      return m(\n        \"div\",\n        {\n          class: visible ? \"page sidebar-visible\" : \"page\",\n        },\n        $albumMetadata,\n        m(\"section.photo-container\", $photosList),\n        m(\"section.video-container\", $videosList),\n      );\n    },\n  };\n}\n", "/* Parse an image datetime to a JS date */\nexport function parse(dateTime: string): Date {\n  let [date, time] = dateTime.split(\" \");\n  date = date.replace(/:/g, \"-\");\n\n  return new Date(`${date} ${time}`);\n}\n\n/* Format an exif date as a normal datestring */\nexport function formatExifDate(dateTime: string): string {\n  if (!dateTime) {\n    return dateTime;\n  }\n\n  const createdAt = new Date(dateTime).toISOString();\n  const [date, time] = createdAt.split(\"T\")[0].replace(/\\:/g, \"-\");\n\n  return `${date.replace(/\\:/g, \"/\")} ${time}`;\n}\n\n/* Format the created-at timestamp to a human-readable date */\nexport function formatCreatedAt(dateTime: string): string {\n  const date = new Date(parseInt(dateTime));\n  const options: Intl.DateTimeFormatOptions = {\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"numeric\",\n  };\n\n  return date.toLocaleDateString(\"en-US\", options);\n}\n", "import m from \"mithril\";\n\ntype AlbumShareButtonAttrs = {\n  url: string;\n  name: string;\n};\n\n/* */\nfunction handleError(message: string) {\n  if (message.includes(\"Shared canceled\")) {\n    return;\n  }\n  alert(message);\n}\n\n/* */\nasync function shareAlbum(\n  state: { sharing: boolean },\n  url: string,\n  name: string,\n) {\n  if (!navigator.share) {\n    handleError(\"navigator.share not available\");\n    return;\n  }\n\n  try {\n    await navigator.share({\n      title: `${name} - photos.rgrannell.xyz`,\n      url,\n    });\n  } catch (error) {\n    console.error(\"Error sharing:\", error);\n  } finally {\n    state.sharing = false;\n  }\n}\n\n/* */\nfunction buttonText(state: { sharing: boolean }) {\n  return state.sharing ? \"[sharing...]\" : \"[share]\";\n}\n\n/* */\nexport function AlbumShareButton() {\n  const localState = {\n    sharing: false,\n  };\n\n  return {\n    view(vnode: m.Vnode<AlbumShareButtonAttrs>) {\n      const { url, name } = vnode.attrs;\n\n      return m(\"button.photo-share-button\", {\n        disabled: !navigator.share,\n        onclick: shareAlbum.bind(null, localState, url, name),\n      }, buttonText(localState));\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { navigate } from \"../commons/events.ts\";\n\n/*\n * Links back to the albums page\n */\nexport function AlbumsButton() {\n  return {\n    view() {\n      return m(\n        \"a\",\n        { href: \"/albums\", onclick: navigate(`/albums`) },\n        \"[albums]\",\n      );\n    },\n  };\n}\n", "/* String Utilities */\n\nimport { PLURALS } from \"../constants.ts\";\n\nexport function capitalise(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function pluralise(str: string): string {\n  if (PLURALS.has(str)) {\n    return PLURALS.get(str)!;\n  }\n\n  return str + \"s\";\n}\n\nconst CAMEL_CASE_CACHE = new Map<string, string>();\n\nexport function camelCase(str: string): string {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n\n  // Caching this since it took about 10ms at load time, so why not eliminate that?\n  if (CAMEL_CASE_CACHE.has(str)) {\n    return CAMEL_CASE_CACHE.get(str)!;\n  }\n\n  const result = str.replace(\n    /[-_ ]+([a-z0-9])/g,\n    (_, char) => char.toUpperCase(),\n  );\n\n  CAMEL_CASE_CACHE.set(str, result);\n  return result;\n}\n\nexport function binomial(binomial: string) {\n  const pretty = binomial.replace(/-/g, \" \");\n  return capitalise(pretty);\n}\n\n/*\n * Markdown renderer is mangling descriptions.\n */\nexport function preprocessDescription(description: string): string {\n  return description.replace(/\\\\\"/g, '\"');\n}\n", "import m from \"mithril\";\nimport type { Photo as PhotoType } from \"../types.ts\";\nimport { Photo } from \"../components/photo.ts\";\nimport { loadingMode } from \"../services/photos.ts\";\n\n/* */\nfunction PhotosList() {\n  return {\n    view(vnode: m.Vnode<PhotosPageAttrs>) {\n      const { photos } = vnode.attrs;\n\n      // TODO: load photos lazily\n      return m(\n        \"section.photo-container\",\n        photos.map((photo, idx) => {\n          const loading = loadingMode(idx);\n\n          return m(Photo, {\n            key: `photo-${photo.id}`,\n            photo,\n            loading,\n            interactive: true,\n          });\n        }),\n      );\n    },\n  };\n}\n\ntype PhotosPageAttrs = {\n  photos: PhotoType[];\n  visible: boolean;\n};\n\n/* */\nexport function PhotosPage() {\n  return {\n    view(vnode: m.Vnode<PhotosPageAttrs>) {\n      const { photos, visible } = vnode.attrs;\n\n      const countText = `${photos.length} photo${\n        photos.length === 1 ? \"\" : \"s\"\n      }`;\n\n      const $md = m(\"section.photos-metadata\", [\n        m(\"h1\", \"Photos\"),\n        m(\"p.photo-album-count\", countText),\n      ]);\n\n      return m(\"div\", {\n        class: visible ? \"page sidebar-visible\" : \"page\",\n      }, [$md, m(PhotosList, { photos, visible })]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { Photo } from \"../components/photo.ts\";\nimport type { Photo as PhotoType, Services } from \"../types.ts\";\nimport { AlbumButton } from \"../components/album-button.ts\";\nimport { ExifData } from \"../components/exif-data.ts\";\nimport { PhotoInfo } from \"../components/photo-info.ts\";\n\ntype PhotoPageAttrs = {\n  photo: PhotoType;\n  services: Services;\n  visible: boolean;\n};\n\n/* */\nexport function PhotoPage() {\n  return {\n    view(vnode: m.Vnode<PhotoPageAttrs>) {\n      const { photo, services, visible } = vnode.attrs;\n\n      // TODO this should be a ul\n      const $links = m(\"li.link-list\", [\n        m(\"a\", { href: photo.fullImage, rel: \"noreferrer\" }, \"[webp]\"),\n        \" \",\n        m(\"a\", { href: photo.pngUrl, rel: \"noreferrer\" }, \"[png]\"),\n        \" \",\n        // [share]\n        m(AlbumButton, { id: photo.albumId }),\n      ]);\n\n      const $exif = m(ExifData, { photo, services });\n      const $photoInfo = m(PhotoInfo, { photo, services });\n\n      return m(\"section\", [\n        m(\"h1\", \"Photo\"),\n        m(Photo, {\n          photo,\n          loading: \"eager\",\n          interactive: false,\n        }),\n        $links,\n        m(\n          \"div\",\n          {\n            class: visible ? \"page sidebar-visible\" : \"page\",\n          },\n          m(\"h3\", \"Photo Information\"),\n          $photoInfo,\n          m(\"h3\", \"Exif Data\"),\n          $exif,\n        ),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { navigate } from \"../commons/events.ts\";\n\ntype AlbumButtonAttrs = {\n  id: string;\n};\n\n/*\n * Links back to the last album page\n */\nexport function AlbumButton() {\n  return {\n    view(vnode: m.Vnode<AlbumButtonAttrs>) {\n      const { id } = vnode.attrs;\n\n      return m(\"a\", {\n        href: `#/album/${id}`,\n        onclick: navigate(`/album/${id}`),\n      }, \"[album]\");\n    },\n  };\n}\n", "import m from \"mithril\";\nimport * as Dates from \"../services/dates.ts\";\nimport type { Photo as PhotoType, Services } from \"../types.ts\";\n\ntype ExifDataAttrs = {\n  photo: PhotoType;\n  services: Services;\n};\n\ntype HeadingAttrs = {\n  text: string;\n};\n\n/* */\nfunction Heading() {\n  return {\n    view(vnode: m.Vnode<HeadingAttrs>) {\n      const { text } = vnode.attrs;\n      return m(\"th.exif-heading\", text);\n    },\n  };\n}\n\n/*\n * Display the camera model\n */\nfunction CameraModel() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $model = services.toThingLinks([photo.model]);\n      if ($model.length > 0) {\n        return m(\"td\", $model);\n      }\n\n      return m(\"td\", \"Unknown\");\n    },\n  };\n}\n\n/*\n * Display the image dimensions\n */\nfunction ExifDimensions() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo } = vnode.attrs;\n\n      if (typeof photo.width === \"string\" && typeof photo.height === \"string\") {\n        return m(\"td\", `${photo.width} x ${photo.height}`);\n      }\n\n      return m(\"td\", \"Unknown\");\n    },\n  };\n}\n\n/*\n * Display the lens focal length\n */\nfunction FocalLength() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo } = vnode.attrs;\n      if (photo.focalLength === \"Unknown\") {\n        return m(\"td\", \"Unknown\");\n      } else if (photo.focalLength === \"0\") {\n        return m(\"td\", \"Manual lens\");\n      } else if (!photo.focalLength) {\n        return m(\"td\", \"Unknown\");\n      } else {\n        return m(\"td\", `${photo.focalLength}mm`);\n      }\n    },\n  };\n}\n\n/*\n * Display the shutter speed\n */\nfunction ShutterSpeed() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo } = vnode.attrs;\n      const { exposureTime } = photo;\n\n      if (typeof exposureTime === \"string\") {\n        const parsed = parseFloat(exposureTime);\n        if (isNaN(parsed)) {\n          return m(\"td\", \"Unknown\");\n        } else if (parsed >= 1) {\n          return m(\"td\", `${parsed} s`);\n        } else {\n          return m(\"td\", `1/${Math.round(1 / parsed)} s`);\n        }\n      }\n\n      return m(\"td\", \"Unknown\");\n    },\n  };\n}\n\n/*\n * Display the aperture (f-stop)\n */\nfunction Aperture() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo } = vnode.attrs;\n\n      if (photo.fStop === \"Unknown\") {\n        return m(\"td\", \"Unknown\");\n      } else if (photo.fStop === \"0.0\") {\n        return m(\"td\", \"Manual aperture control\");\n      } else if (!photo.fStop) {\n        return m(\"td\", \"Unknown\");\n      }\n\n      return m(\"td\", `\u0192/${photo.fStop}`);\n    },\n  };\n}\n\nexport function ExifData() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $dateTime = m(\"tr\", [\n        m(Heading, { text: \"Date-Time\" }),\n        m(\"td\", m(\"time\", Dates.formatCreatedAt(photo.createdAt))),\n      ]);\n\n      const $model = m(\"tr\", [\n        m(Heading, { text: \"Camera Model\" }),\n        m(CameraModel, { photo, services }),\n      ]);\n\n      const $dimensions = m(\"tr\", [\n        m(Heading, { text: \"Dimensions\" }),\n        m(ExifDimensions, { photo, services }),\n      ]);\n\n      const $focalLength = m(\"tr\", [\n        m(Heading, { text: \"Focal Length\" }),\n        m(FocalLength, { photo, services }),\n      ]);\n\n      const $shutterSpeed = m(\"tr\", [\n        m(Heading, { text: \"Shutter Speed\" }),\n        m(ShutterSpeed, { photo, services }),\n      ]);\n\n      const $aperture = m(\"tr\", [\n        m(Heading, { text: \"Aperture\" }),\n        m(Aperture, { photo, services }),\n      ]);\n\n      const $iso = m(\"tr\", [\n        m(Heading, { text: \"ISO\" }),\n        m(\"td\", photo.iso ?? \"Unknown\"),\n      ]);\n\n      return m(\"table.metadata-table\", [\n        $dateTime,\n        $model,\n        $dimensions,\n        $focalLength,\n        $shutterSpeed,\n        $aperture,\n        $iso,\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Photo as PhotoType, Services } from \"../types.ts\";\nimport { arrayify } from \"../commons/arrays.ts\";\nimport { preprocessDescription } from \"../commons/strings.ts\";\n\ntype HeadingAttrs = {\n  text: string;\n};\n\n/* */\nfunction Heading() {\n  return {\n    view(vnode: m.Vnode<HeadingAttrs>) {\n      const { text } = vnode.attrs;\n      return m(\"th.exif-heading\", text);\n    },\n  };\n}\n\ntype PhotoComponentAttrs = {\n  photo: PhotoType;\n  services: Services;\n};\n\n/* */\nfunction Description() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo } = vnode.attrs;\n\n      const html = preprocessDescription(\n        photo.description ?? photo.summary ?? \"\",\n      );\n      if (html) {\n        return m(\"td\", m.trust(html));\n      }\n\n      return m(\"td\", \"\u2014\");\n    },\n  };\n}\n\n/* */\nfunction Location() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $locations = services.toThingLinks(arrayify(photo.location));\n      return m(\"td\", $locations.length > 0 ? $locations : \"\u2014\");\n    },\n  };\n}\n\n/* */\nfunction Rating() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $rating = services.toThingLinks([photo.rating]);\n      return m(\"td\", $rating.length > 0 ? $rating : \"\u2014\");\n    },\n  };\n}\n\n/* */\nfunction Style() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $style = services.toThingLinks([photo.style]);\n      return m(\"td\", $style.length > 0 ? $style : \"\u2014\");\n    },\n  };\n}\n\n/* */\nfunction Subject() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $subject = services.toThingLinks(arrayify(photo.subject));\n      return m(\"td\", $subject.length > 0 ? $subject : \"\u2014\");\n    },\n  };\n}\n\n/* */\nfunction Country() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $countries = services.toThingLinks(arrayify(photo.country));\n      return m(\"td\", $countries.length > 0 ? $countries : \"\u2014\");\n    },\n  };\n}\n\ntype PhotoInfoAttrs = {\n  photo: PhotoType;\n  services: Services;\n};\n\n/* */\nexport function PhotoInfo() {\n  return {\n    view(vnode: m.Vnode<PhotoInfoAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const infoItems = [];\n\n      if (photo.description || photo.summary) {\n        infoItems.push(m(\"tr\", [\n          m(Heading, { text: \"Description\" }),\n          m(Description, { photo, services }),\n        ]));\n      }\n\n      infoItems.push(\n        m(\"tr\", [\n          m(Heading, { text: \"Country\" }),\n          m(Country, { photo, services }),\n        ]),\n        m(\"tr\", [\n          m(Heading, { text: \"Location\" }),\n          m(Location, { photo, services }),\n        ]),\n        m(\"tr\", [\n          m(Heading, { text: \"Rating\" }),\n          m(Rating, { photo, services }),\n        ]),\n        m(\"tr\", [\n          m(Heading, { text: \"Style\" }),\n          m(Style, { photo, services }),\n        ]),\n        m(\"tr\", [\n          m(Heading, { text: \"Subject\" }),\n          m(Subject, { photo, services }),\n        ]),\n      );\n\n      return m(\"table.metadata-table\", infoItems);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { NonListableTypes } from \"../constants.ts\";\nimport { capitalise, pluralise } from \"../commons/strings.ts\";\nimport { asUrn, type TripleObject } from \"@rgrannell1/tribbledb\";\nimport { navigate } from \"../commons/events.ts\";\nimport type { Services } from \"../types.ts\";\nimport { PhotoAlbum } from \"../components/photo-album.ts\";\nimport { encodeBitmapDataURL, loadingMode } from \"../services/photos.ts\";\nimport { one } from \"../commons/arrays.ts\";\nimport { ThingMetadata } from \"../components/thing-metadata.ts\";\n\n/*\n * Draw an album for a single thing\n */\nfunction drawThingAlbum(services: Services, thing: TripleObject, idx: number) {\n  const id = one(thing.id);\n\n  if (!id) {\n    return [];\n  }\n\n  const coverPhoto = services.readThingCover(id);\n  if (!coverPhoto) {\n    return [];\n  }\n\n  const $md = m(ThingMetadata, { thing });\n\n  const { id: thingId, type } = asUrn(id);\n\n  // Placeholder implementation\n  return [m(PhotoAlbum, {\n    imageUrl: coverPhoto.fullImage,\n    thumbnailUrl: coverPhoto.thumbnailUrl,\n    thumbnailDataUrl: encodeBitmapDataURL(coverPhoto?.mosaicColours),\n    loading: loadingMode(idx),\n    trip: undefined,\n    child: $md,\n    onclick: navigate(`/thing/${type}:${thingId}`),\n  })];\n}\n\n/*\n * Display the component albums and metadata\n * in the listing page\n */\nfunction AlbumsList() {\n  return {\n    view(vnode: m.Vnode<{ services: Services; things: TripleObject[] }>) {\n      const { services, things } = vnode.attrs;\n\n      const $albumComponents = things.flatMap((thing, idx) => {\n        console.log(\"Drawing album for thing:\", thing);\n        return drawThingAlbum(services, thing, idx);\n      });\n\n      return m(\"section.album-container\", $albumComponents);\n    },\n  };\n}\n\n/*\n * Display a pluralised title for the listing page,\n * e.g \"Countries\"\n */\nfunction ListingTitle() {\n  return {\n    view(vnode: m.Vnode<{ type: string }>) {\n      const { type } = vnode.attrs;\n      return m(\n        \"h1.albums-header\",\n        `${capitalise(pluralise(type))}`,\n      );\n    },\n  };\n}\n\n/*\n * Link to the things page for this type (wildcard)\n */\nfunction ListingThingsButton() {\n  return {\n    view(vnode: m.Vnode<{ type: string }>) {\n      const { type } = vnode.attrs;\n      return m(\"a\", {\n        href: `#/thing/${type}:*`,\n        onclick: navigate(`/thing/${type}:*`),\n      }, `See all ${type} photos`);\n    },\n  };\n}\n\ntype ListingPageAttrs = {\n  type: string;\n  things: TripleObject[];\n  services: Services;\n  visible: boolean;\n};\n\n/*\n * Render the listing page. It shows\n * each member of a category (e.g countries)\n */\nexport function ListingPage() {\n  return {\n    view(vnode: m.Vnode<ListingPageAttrs>) {\n      const { type, things, services, visible } = vnode.attrs;\n\n      const $md = [\n        m(ListingTitle, { type }),\n      ];\n\n      if (!NonListableTypes.has(type)) {\n        $md.push(\n          m(\"section.album-metadata\", [\n            m(ListingThingsButton, { type }),\n          ]),\n        );\n      }\n\n      return m(\"div\", {\n        class: visible ? \"page sidebar-visible\" : \"page\",\n      }, [\n        m(\"section.album-metadata\", $md),\n        m(AlbumsList, { services, things }),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { asUrn, type TripleObject } from \"@rgrannell1/tribbledb\";\nimport { one } from \"../commons/arrays.ts\";\nimport { KnownTypes } from \"../constants.ts\";\nimport { countryEmoji } from \"../services/emoji.ts\";\nimport { ThingUrls } from \"./thing-urls.ts\";\n\nexport function ThingMetadata() {\n  // excluding birds\n  const animals = new Set([\n    KnownTypes.AMPHIBIAN,\n    KnownTypes.REPTILE,\n    KnownTypes.INSECT,\n    KnownTypes.FISH,\n    KnownTypes.MAMMAL,\n  ]);\n\n  return {\n    view(vnode: m.Vnode<{ thing: TripleObject }>) {\n      const { thing } = vnode.attrs;\n      const { type } = asUrn(one(thing.id) as string);\n\n      const $links = m(ThingUrls, { things: [thing] });\n      const title = type === KnownTypes.COUNTRY\n        ? `${countryEmoji(thing)} ${one(thing.name)}`\n        : one(thing.name);\n\n      return m(\"div.photo-album-metadata\", [\n        m(\"p.photo-album-title\", title),\n        $links,\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { TripleObject } from \"@rgrannell1/tribbledb\";\nimport { one } from \"../commons/arrays.ts\";\nimport { ExternalLink } from \"./external-link.ts\";\n\n/*\n * Links to external sites about the thing\n */\nexport function ThingUrls() {\n  return {\n    view(vnode: m.Vnode<{ things: TripleObject[] }>) {\n      const { things } = vnode.attrs;\n\n      if (things.length !== 1) {\n        return m(\"ul\");\n      }\n\n      const [thing] = things;\n      const $links = [];\n\n      const wikipedia = one(thing.wikipedia);\n      if (wikipedia) {\n        $links.push(\n          m(\"li\", m(ExternalLink, { href: wikipedia, text: \"[wikipedia]\" })),\n        );\n      }\n\n      const birdwatch = one(thing.birdwatchUrl);\n      if (birdwatch) {\n        $links.push(\n          m(\"li\", m(ExternalLink, { href: birdwatch, text: \"[birdwatch]\" })),\n        );\n      }\n\n      // -- add google maps URL\n      return m(\"ul.link-list\", $links);\n    },\n  };\n}\n", "import m from \"mithril\";\n\nexport function ExternalLink() {\n  return {\n    view(vnode: m.Vnode<{ href: string; text: string }>) {\n      const { href, text } = vnode.attrs;\n      return m(\"a\", {\n        href,\n        target: \"_blank\",\n        rel: \"noopener\",\n      }, text);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { navigate } from \"../commons/events.ts\";\n\ntype ListingItemAttrs = {\n  name: string;\n  route: string;\n};\n\nfunction ListingItem() {\n  return {\n    view(vnode: m.Vnode<ListingItemAttrs>) {\n      return m(\n        \"li\",\n        m(\"a\", {\n          class: \"listing-item\",\n          onclick: navigate(vnode.attrs.route),\n        }, vnode.attrs.name),\n      );\n    },\n  };\n}\n\ntype ListingsPageAttrs = {\n  visible: boolean;\n};\n\nexport function ListingsPage() {\n  return {\n    view(vnode: m.Vnode<ListingsPageAttrs>) {\n      const { visible } = vnode.attrs;\n\n      return m(\"div\", {\n        class: visible ? \"page sidebar-visible\" : \"page\",\n      }, [\n        m(\"h1\", \"Listings\"),\n        m(\"br\"),\n        m(\"p\", \"Collections of all places, countries, and animals\"),\n        m(\"br\"),\n        m(\n          \"section\",\n          m(\"ul\", [\n            m(ListingItem, { route: \"/listing/place\", name: \"Places\" }),\n            m(ListingItem, { route: \"/listing/country\", name: \"Countries\" }),\n            m(ListingItem, { route: \"/listing/bird\", name: \"Birds\" }),\n            m(ListingItem, { route: \"/listing/mammal\", name: \"Mammals\" }),\n            m(ListingItem, { route: \"/listing/reptile\", name: \"Reptiles\" }),\n            m(ListingItem, { route: \"/listing/amphibian\", name: \"Amphibians\" }),\n            m(ListingItem, { route: \"/listing/insect\", name: \"Insects\" }),\n          ]),\n        ),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { ThingSubtitle, ThingTitle } from \"../components/thing-title.ts\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport type { TripleObject } from \"@rgrannell1/tribbledb\";\nimport { arrayify } from \"../commons/arrays.ts\";\nimport type { Services } from \"../types.ts\";\nimport { CountryLink } from \"../components/place-links.ts\";\nimport { Photo } from \"../components/photo.ts\";\nimport { encodeBitmapDataURL } from \"../services/photos.ts\";\nimport { PhotoAlbumMetadata } from \"../components/photo-album-metadata.ts\";\nimport { PhotoAlbum } from \"../components/photo-album.ts\";\nimport { block, broadcast } from \"../commons/events.ts\";\nimport { PlacesList } from \"../components/places-list.ts\";\nimport { setify, setOf } from \"../commons/sets.ts\";\nimport { KnownRelations } from \"../constants.ts\";\nimport { ListingLink } from \"../components/listing-link.ts\";\nimport { FeaturesList } from \"../components/features-list.ts\";\nimport { UnescoList } from \"../components/unesco-list.ts\";\nimport { loadingMode } from \"../services/photos.ts\";\nimport { ThingUrls } from \"../components/thing-urls.ts\";\nimport { readCountries } from \"../services/readers.ts\";\n\ntype ThingPageAttrs = {\n  urn: string;\n  things: TripleObject[];\n  services: Services;\n  visible: boolean;\n};\n\nfunction _ThingPlaces() {\n  return {\n    view() {\n    },\n  };\n}\n\nfunction _ThingTypeLink() {\n  return {\n    view() {\n    },\n  };\n}\n\nfunction ThingMetadata() {\n  return {\n    view(vnode: m.Vnode<ThingPageAttrs>) {\n      const metadata: Record<string, m.Children> = {};\n      const { urn, things, services } = vnode.attrs;\n\n      metadata.Classification = m(ListingLink, { urn });\n\n      const locatedIn = setOf<string>(KnownRelations.IN, things);\n\n      if (locatedIn.size > 0) {\n        metadata[\"Located In\"] = m(PlacesList, { services, urns: locatedIn });\n      }\n\n      if (things.length !== 1) {\n        return;\n      }\n\n      const [thing] = things;\n      // The non-wildcard case\n\n      if (thing.features) {\n        metadata[\"Place Type\"] = m(FeaturesList, {\n          urns: setify(thing.features),\n          services,\n        });\n      }\n\n      if (thing.contains) {\n        metadata[\"Contains\"] = m(PlacesList, {\n          services,\n          urns: setify(thing.contains),\n        });\n      }\n\n      if (thing.unescoId) {\n        metadata[\"UNESCO\"] = m(UnescoList, {\n          urns: new Set(arrayify(thing.unescoId)),\n          services,\n        });\n      }\n\n      // TODO add `seen in`, first photographed\n\n      // convert the metadaTa to a table\n\n      const $rows = Object.entries(metadata).map(([key, value]) => {\n        return m(\"tr\", [\n          m(\"th.exif-heading\", key),\n          m(\"td\", value),\n        ]);\n      });\n\n      return m(\"div\", [\n        m(\"h3\", \"Details\"),\n        m(\"table.metadata-table\", $rows),\n      ]);\n    },\n  };\n}\n\nfunction onAlbumClick(id: string, title: string, event: Event) {\n  const parsed = asUrn(id);\n\n  broadcast(\"navigate\", { route: `/album/${parsed.id}`, title });\n  block(event);\n}\n\nfunction AlbumSection() {\n  return {\n    view(vnode: m.Vnode<ThingPageAttrs>) {\n      const { things, services } = vnode.attrs;\n\n      const urns = setOf<string>(\"id\", things);\n      const albums = services.readAlbumsByThingIds(new Set(urns));\n\n      const $albums = albums.map((album) => {\n        const countries = services.readCountries(setify(album.country));\n\n        // duplicated model. move to render(model) code\n        const $countryLinks = countries.map((country) => {\n          return m(CountryLink, {\n            country,\n            key: `album-country-${album.id}-${country.id}`,\n            mode: \"flag\",\n          });\n        });\n\n        const $md = m(PhotoAlbumMetadata, {\n          title: album.name,\n          minDate: album.minDate,\n          maxDate: album.maxDate,\n          count: album.photosCount,\n          countryLinks: $countryLinks,\n          dateRange: album.dateRange,\n          shortDateRange: album.shortDateRange,\n        });\n\n        const $album = m(PhotoAlbum, {\n          imageUrl: album.thumbnailUrl,\n          thumbnailUrl: album.thumbnailUrl,\n          thumbnailDataUrl: encodeBitmapDataURL(album.mosaic),\n          loading: \"lazy\",\n          minDate: album.minDate,\n          onclick: onAlbumClick.bind(null, album.id, album.name),\n          trip: undefined,\n          child: m(\"p\"),\n        });\n\n        return m(\n          \"div\",\n          $album,\n          $md,\n        );\n      });\n\n      return m(\n        \"section.album-container\",\n        $albums,\n      );\n    },\n  };\n}\n\nfunction PhotoSection() {\n  return {\n    view(vnode: m.Vnode<ThingPageAttrs>) {\n      const { things, services } = vnode.attrs;\n\n      const urns = setOf<string>(\"id\", things);\n      const photos = services.readPhotosByThingIds(urns);\n\n      return m(\n        \"section.photo-container\",\n        photos.map((photo, idx) => {\n          const loading = loadingMode(idx);\n\n          return m(Photo, {\n            key: `photo-${photo.id}`,\n            photo,\n            loading,\n            interactive: true,\n          });\n        }),\n      );\n    },\n  };\n}\n\nexport function ThingPage() {\n  return {\n    view(vnode: m.Vnode<ThingPageAttrs>) {\n      const { urn, things, services, visible } = vnode.attrs;\n\n      return m(\"div\", {\n        class: visible ? \"page sidebar-visible\" : \"page\",\n      }, [\n        m(\"section.thing-page\", [\n          m(ThingTitle, { urn, things }),\n          m(ThingSubtitle, { urn }),\n          m(\"br\"),\n          m(ThingUrls, { things }),\n          m(ThingMetadata, { urn, things, services, visible }),\n          m(\"h3\", \"Photos\"),\n          m(PhotoSection, { urn, things, services, visible }),\n          m(\"h3\", \"Albums\"),\n          m(AlbumSection, { urn, things, services, visible }),\n        ]),\n      ]);\n    },\n  };\n}\n", "import { asUrn, parseUrn } from \"@rgrannell1/tribbledb\";\nimport type { TripleObject } from \"@rgrannell1/tribbledb\";\nimport m from \"mithril\";\nimport { binomial, capitalise, pluralise } from \"../commons/strings.ts\";\nimport { BinomialTypes, KnownTypes } from \"../constants.ts\";\nimport { one } from \"../commons/arrays.ts\";\nimport { countryEmoji, placeEmoji } from \"../services/emoji.ts\";\nimport { setTitle } from \"../services/window.ts\";\n\nfunction computeTitle(urn: string, things: TripleObject[]): string {\n  const parsed = parseUrn(urn);\n\n  // if type:*, fall back to pretty render of type information\n  if (parsed.id === \"*\") {\n    return capitalise(pluralise(parsed.type));\n  }\n\n  if (things.length === 0) {\n    return urn;\n  }\n\n  const [thing] = things;\n  const name = one(thing.name) ?? parsed.id;\n\n  if (parsed.type === KnownTypes.COUNTRY) {\n    return `${countryEmoji(thing)} ${name}`;\n  } else if (parsed.type === KnownTypes.PLACE) {\n    return `${placeEmoji(thing)} ${name}`;\n  }\n\n  return name;\n}\n\ntype ThingTitleAttrs = {\n  urn: string;\n  things: TripleObject[];\n};\n\nexport function ThingTitle() {\n  return {\n    view(vnode: m.Vnode<ThingTitleAttrs>) {\n      const { urn, things } = vnode.attrs;\n      const title = computeTitle(urn, things);\n\n      setTitle(title);\n\n      return m(\"h1\", title);\n    },\n  };\n}\n\nexport function ThingSubtitle() {\n  return {\n    view(vnode: m.Vnode<{ urn: string }>) {\n      const parsed = asUrn(vnode.attrs.urn);\n\n      return BinomialTypes.has(parsed.type) && parsed.id !== \"*\"\n        ? m(\n          \"span\",\n          { class: `thing-binomial ${parsed.type}-binomial` },\n          binomial(parsed.id),\n        )\n        : m(\"span\");\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { one } from \"../commons/arrays.ts\";\nimport type { Services } from \"../types.ts\";\nimport { ThingLink } from \"./thing-link.ts\";\n\ntype PlacesListAttrs = {\n  urns: Set<string>;\n  services: Services;\n};\n\nexport function PlacesList() {\n  return {\n    view(vnode: m.Vnode<PlacesListAttrs>) {\n      const { urns, services } = vnode.attrs;\n      const locations = services.readLocations(urns).sort(\n        (loca, locb) => {\n          return (one(loca.name) ?? \"\").localeCompare(one(locb.name) ?? \"\");\n        },\n      );\n\n      const $places = locations.map((location) => {\n        const $link = m(ThingLink, {\n          urn: one(location.id)!,\n          thing: location,\n        });\n        return m(\"li\", { key: `place-${location.id}` }, $link);\n      });\n\n      return m(\"ul\", $places);\n    },\n  };\n}\n", "import { asUrn } from \"@rgrannell1/tribbledb\";\nimport m from \"mithril\";\nimport { capitalise } from \"../commons/strings.ts\";\nimport { block, broadcast } from \"../commons/events.ts\";\n\nfunction onListingClick(type: string, event: Event) {\n  broadcast(\"navigate\", {\n    route: `/listing/${type}`,\n  });\n  block(event);\n}\n\ntype ListingLinkAttrs = { urn: string } | { type: string };\n\nexport function ListingLink() {\n  return {\n    view(vnode: m.Vnode<ListingLinkAttrs>) {\n      let type = \"\";\n      if (\"type\" in vnode.attrs) {\n        type = vnode.attrs.type;\n      } else {\n        const parsed = asUrn(vnode.attrs.urn);\n        type = parsed.type;\n      }\n\n      return m(\"a\", {\n        href: `#/listing/${type}`,\n        onclick: onListingClick.bind(null, type),\n      }, capitalise(type));\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Services } from \"../types.ts\";\nimport { one } from \"../commons/arrays.ts\";\nimport { FeatureLink } from \"./feature-link.ts\";\n\ntype FeaturesListAttrs = {\n  urns: Set<string>;\n  services: Services;\n};\n\n/*\n * A list of place features. For the moment, things-links cannot be used\n */\nexport function FeaturesList() {\n  return {\n    view(vnode: m.Vnode<FeaturesListAttrs>) {\n      const { urns, services } = vnode.attrs;\n      const features = services.readFeatures(urns);\n\n      const $features = features.map((feature) => {\n        const id = one(feature.id)!;\n\n        return m(\"li\", {\n          key: `feature-${id}`,\n        }, m(FeatureLink, { urn: id, thing: feature }));\n      });\n\n      return m(\"ul\", $features);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\n\nimport { one } from \"../commons/arrays.ts\";\nimport { thingEmoji } from \"../services/emoji.ts\";\n\nexport type FeatureLinkAttrs = {\n  urn: string;\n  thing: any;\n};\n\n/*\n * Ideally, we'll extend the `thing` system to support more complex queries, which would\n * be needed here. The query would be \"show all photos / videos\" where the place has feature X, which\n * is more complex than the current system of \"show all photos / videos\" where the place is Y.\n */\nexport function FeatureLink() {\n  return {\n    view(vnode: m.Vnode<FeatureLinkAttrs>) {\n      const { urn, thing } = vnode.attrs;\n      const { type, id } = asUrn(urn);\n\n      const name = one(thing.name) ?? id;\n      const emoji = thingEmoji(urn, name, thing);\n      const text = `${emoji}\\t${name}`;\n\n      return m(\"p\", {\n        class: [\"thing-link\", `${type}-link`].join(\" \"),\n      }, text);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Services } from \"../types.ts\";\nimport { UnescoLink } from \"./unesco-link.ts\";\nimport { one } from \"../commons/arrays.ts\";\n\ntype UnescoListAttrs = {\n  urns: Set<string>;\n  services: Services;\n};\n\nexport function UnescoList() {\n  return {\n    view(vnode: m.Vnode<UnescoListAttrs>) {\n      const { urns, services } = vnode.attrs;\n\n      const unescos = services.readUnescos(urns);\n      const $unescos = unescos.map((unesco) => {\n        const urn = one(unesco.id)!;\n\n        return m(\"li\", m(UnescoLink, { urn, thing: unesco }));\n      });\n\n      return m(\"ul\", $unescos);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport { one } from \"../commons/arrays.ts\";\n\nexport type UnescoLinkAttrs = {\n  urn: string;\n  thing: any;\n};\n\n/* */\nexport function UnescoLink() {\n  return {\n    view(vnode: m.Vnode<UnescoLinkAttrs>) {\n      const { urn, thing } = vnode.attrs;\n      const { type, id } = asUrn(urn);\n\n      const name = one(thing.name) ?? id;\n\n      return m(\"a\", {\n        href: `https://whc.unesco.org/en/list/${id}`,\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        class: [\"thing-link\", `${type}-link`].join(\" \"),\n      }, name);\n    },\n  };\n}\n"],
  "mappings": "whBAAA,IAAAA,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,SAASC,GAAMC,EAAKC,EAAKC,EAAOC,EAAUC,EAAMC,EAAK,CACpD,MAAO,CAAC,IAAKL,EAAK,IAAKC,EAAK,MAAOC,EAAO,SAAUC,EAAU,KAAMC,EAAM,IAAKC,EAAK,GAAI,OAAW,QAAS,OAAW,MAAO,OAAW,OAAQ,OAAW,SAAU,MAAS,CAChL,CACAN,GAAM,UAAY,SAASO,EAAM,CAChC,OAAI,MAAM,QAAQA,CAAI,EAAUP,GAAM,IAAK,OAAW,OAAWA,GAAM,kBAAkBO,CAAI,EAAG,OAAW,MAAS,EAChHA,GAAQ,MAAQ,OAAOA,GAAS,UAAkB,KAClD,OAAOA,GAAS,SAAiBA,EAC9BP,GAAM,IAAK,OAAW,OAAW,OAAOO,CAAI,EAAG,OAAW,MAAS,CAC3E,EACAP,GAAM,kBAAoB,SAASQ,EAAO,CASzC,QANIJ,EAAW,IAAI,MAAMI,EAAM,MAAM,EAKjCC,EAAW,EACNC,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IACjCN,EAASM,CAAC,EAAIV,GAAM,UAAUQ,EAAME,CAAC,CAAC,EAClCN,EAASM,CAAC,IAAM,MAAQN,EAASM,CAAC,EAAE,KAAO,MAAMD,IAEtD,GAAIA,IAAa,GAAKA,IAAaD,EAAM,OACxC,MAAM,IAAI,UAAUJ,EAAS,SAAS,IAAI,EACvC,gLACA,mEACH,EAED,OAAOA,CACR,EAEAL,GAAO,QAAUC,KCjCjB,IAAAW,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAQ,KAWZD,GAAO,QAAU,SAASE,EAAOC,EAAU,CAC1C,OAAID,GAAS,MAAQ,OAAOA,GAAU,UAAYA,EAAM,KAAO,MAAQ,CAAC,MAAM,QAAQA,CAAK,EACtFC,EAAS,SAAW,GAAK,MAAM,QAAQA,EAAS,CAAC,CAAC,IAAGA,EAAWA,EAAS,CAAC,IAE9EA,EAAWA,EAAS,SAAW,GAAK,MAAM,QAAQD,CAAK,EAAIA,EAAQ,CAACA,EAAO,GAAGC,CAAQ,EACtFD,EAAQ,QAGFD,GAAM,GAAIC,GAASA,EAAM,IAAKA,EAAOC,CAAQ,CACrD,ICtBA,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAGAA,GAAO,QAAU,CAAC,EAAE,iBCHpB,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAGAA,GAAO,QAAU,CAAC,ICHlB,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAa,KASjBD,GAAO,QAAU,IAAI,IAAI,CAAC,CAACC,GAAY,EAAI,CAAC,CAAC,ICX7C,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAQ,KACRC,GAAmB,KACnBC,GAAS,KACTC,GAAa,KACbC,GAAyB,KAEzBC,GAAiB,+EACjBC,GAAgB,OAAO,OAAO,IAAI,EAEtC,SAASC,GAAQC,EAAQ,CACxB,QAASC,KAAOD,EAAQ,GAAIN,GAAO,KAAKM,EAAQC,CAAG,EAAG,MAAO,GAC7D,MAAO,EACR,CAEA,SAASC,GAAmBD,EAAK,CAChC,OAAOA,IAAQ,SAAWA,IAAQ,WAAaA,IAAQ,iBAAmBA,IAAQ,UACnF,CAEA,SAASE,GAAgBC,EAAU,CAElC,QADIC,EAAOC,EAAM,MAAOC,EAAU,CAAC,EAAGC,EAAQ,CAAC,EAAGC,EAAW,GACtDJ,EAAQR,GAAe,KAAKO,CAAQ,GAAG,CAC7C,IAAIM,EAAOL,EAAM,CAAC,EAAGM,EAAQN,EAAM,CAAC,EACpC,GAAIK,IAAS,IAAMC,IAAU,GAAIL,EAAMK,UAC9BD,IAAS,IAAKF,EAAM,GAAKG,UACzBD,IAAS,IAAKH,EAAQ,KAAKI,CAAK,UAChCN,EAAM,CAAC,EAAE,CAAC,IAAM,IAAK,CAC7B,IAAIO,EAAYP,EAAM,CAAC,EACnBO,IAAWA,EAAYA,EAAU,QAAQ,YAAa,IAAI,EAAE,QAAQ,QAAS,IAAI,GACjFP,EAAM,CAAC,IAAM,QAASE,EAAQ,KAAKK,CAAS,GAE/CJ,EAAMH,EAAM,CAAC,CAAC,EAAIO,IAAc,GAAKA,EAAYA,GAAa,GAC1DV,GAAmBG,EAAM,CAAC,CAAC,IAAGI,EAAW,IAE/C,CACD,CACA,OAAIF,EAAQ,OAAS,IAAGC,EAAM,UAAYD,EAAQ,KAAK,GAAG,GACtDR,GAAQS,CAAK,EAAGA,EAAQb,GACvBC,GAAuB,IAAIY,EAAOC,CAAQ,EACxCX,GAAcM,CAAQ,EAAI,CAAC,IAAKE,EAAK,MAAOE,EAAO,GAAIA,EAAM,EAAE,CACvE,CAEA,SAASK,GAAaC,EAAOC,EAAO,CACnCA,EAAM,IAAMD,EAAM,IAElB,IAAIN,EAAQO,EAAM,MAClB,GAAIP,GAAS,KACZ,OAAAO,EAAM,MAAQD,EAAM,MACpBC,EAAM,GAAKD,EAAM,GACVC,EAQR,GALIrB,GAAO,KAAKc,EAAO,OAAO,IACzBA,EAAM,OAAS,OAAMA,EAAM,UAAYA,EAAM,OACjDA,EAAM,MAAQ,MAGXM,EAAM,QAAUnB,GAAY,CAC/B,IAAIqB,EAAYR,EAAM,UACtBA,EAAQ,OAAO,OAAO,CAAC,EAAGM,EAAM,MAAON,CAAK,EAExCM,EAAM,MAAM,WAAa,OAAMN,EAAM,UACxCQ,GAAa,KACV,OAAOF,EAAM,MAAM,SAAS,EAAI,IAAM,OAAOE,CAAS,EACtDF,EAAM,MAAM,UACjB,CAKA,OAAIA,EAAM,MAAQ,SAAWpB,GAAO,KAAKc,EAAO,MAAM,IACrDA,EAAQ,OAAO,OAAO,CAAC,KAAMA,EAAM,IAAI,EAAGA,CAAK,GAIhDO,EAAM,GAAKP,EAAM,GAEjBO,EAAM,MAAQP,EAEPO,CACR,CAEA,SAASE,GAAYb,EAAUI,KAAUU,EAAU,CAClD,GAAId,GAAY,MAAQ,OAAOA,GAAa,UAAY,OAAOA,GAAa,YAAc,OAAOA,EAAS,MAAS,WAClH,MAAM,MAAM,sDAAsD,EAGnE,IAAIW,EAAQtB,GAAiBe,EAAOU,CAAQ,EAE5C,OAAI,OAAOd,GAAa,WACvBW,EAAM,SAAWvB,GAAM,kBAAkBuB,EAAM,QAAQ,EACnDX,IAAa,KAAYS,GAAaf,GAAcM,CAAQ,GAAKD,GAAgBC,CAAQ,EAAGW,CAAK,GAGlGA,EAAM,OAAS,OAAMA,EAAM,MAAQ,CAAC,GACxCA,EAAM,IAAMX,EACLW,EACR,CAEAxB,GAAO,QAAU0B,KCpGjB,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAQ,KAEZD,GAAO,QAAU,SAASE,EAAM,CAC/B,OAAIA,GAAQ,OAAMA,EAAO,IAClBD,GAAM,IAAK,OAAW,OAAWC,EAAM,OAAW,MAAS,CACnE,ICPA,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAQ,KACRC,GAAmB,KAEvBF,GAAO,QAAU,SAASG,KAAUC,EAAU,CAC7C,IAAIC,EAAQH,GAAiBC,EAAOC,CAAQ,EAE5C,OAAIC,EAAM,OAAS,OAAMA,EAAM,MAAQ,CAAC,GACxCA,EAAM,IAAM,IACZA,EAAM,SAAWJ,GAAM,kBAAkBI,EAAM,QAAQ,EAChDA,CACR,ICZA,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAc,KAElBA,GAAY,MAAQ,KACpBA,GAAY,SAAW,KAEvBD,GAAO,QAAUC,KCPjB,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEAA,GAAO,QAAU,IAAI,UCFrB,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAiB,KAErB,SAAUC,GAAOC,EAAO,CAGvB,IAAIC,EAAMD,EAAM,IACZE,EAAUF,EAAM,QAChBG,EAAaL,GAAe,IAAIG,CAAG,EACvC,GAAIA,GAAO,KAAM,EAAG,CACnB,IAAIG,EAAcH,EAAI,YAElBH,GAAe,IAAIG,CAAG,IAAME,IAC/B,MAAMF,EACNC,KAGDD,EAAMG,CACP,OACOF,EACR,CAEAL,GAAO,QAAUE,KCvBjB,IAAAM,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAQ,KACRC,GAAiB,KACjBC,GAAS,KACTC,GAAyB,KAE7BJ,GAAO,QAAU,UAAW,CAC3B,IAAIK,EAAY,CACf,IAAK,6BACL,KAAM,oCACP,EAEIC,EACAC,EAEJ,SAASC,EAAYC,EAAK,CACzB,OAAOA,EAAI,aACZ,CAEA,SAASC,EAAaC,EAAO,CAC5B,OAAOA,EAAM,OAASA,EAAM,MAAM,OAASN,EAAUM,EAAM,GAAG,CAC/D,CAGA,SAASC,EAAWD,EAAOE,EAAU,CACpC,GAAIF,EAAM,QAAUE,EAAU,MAAM,IAAI,MAAM,qCAAqC,CACpF,CAMA,SAASC,EAASH,EAAO,CACxB,IAAIE,EAAWF,EAAM,MACrB,GAAI,CACH,OAAO,KAAK,MAAME,EAAU,SAAS,CACtC,QAAE,CACDD,EAAWD,EAAOE,CAAQ,CAC3B,CACD,CAIA,SAASE,EAAcN,EAAK,CAC3B,GAAI,CACH,OAAOD,EAAYC,CAAG,EAAE,aACzB,MAAY,CACX,OAAO,IACR,CACD,CAEA,SAASO,EAAYC,EAAQC,EAAQC,EAAOC,EAAKC,EAAOC,EAAaC,EAAI,CACxE,QAASC,EAAIL,EAAOK,EAAIJ,EAAKI,IAAK,CACjC,IAAIb,EAAQO,EAAOM,CAAC,EAChBb,GAAS,MACZc,EAAWR,EAAQN,EAAOU,EAAOE,EAAID,CAAW,CAElD,CACD,CACA,SAASG,EAAWR,EAAQN,EAAOU,EAAOE,EAAID,EAAa,CAC1D,IAAII,EAAMf,EAAM,IAChB,GAAI,OAAOe,GAAQ,SAGlB,OAFAf,EAAM,MAAQ,CAAC,EACXA,EAAM,OAAS,MAAMgB,GAAchB,EAAM,MAAOA,EAAOU,CAAK,EACxDK,EAAK,CACZ,IAAK,IAAKE,EAAWX,EAAQN,EAAOW,CAAW,EAAG,MAClD,IAAK,IAAKO,EAAWZ,EAAQN,EAAOY,EAAID,CAAW,EAAG,MACtD,IAAK,IAAKQ,EAAeb,EAAQN,EAAOU,EAAOE,EAAID,CAAW,EAAG,MACjE,QAASS,EAAcd,EAAQN,EAAOU,EAAOE,EAAID,CAAW,CAC7D,MAEIU,EAAgBf,EAAQN,EAAOU,EAAOE,EAAID,CAAW,CAC3D,CACA,SAASM,EAAWX,EAAQN,EAAOW,EAAa,CAC/CX,EAAM,IAAMH,EAAYS,CAAM,EAAE,eAAeN,EAAM,QAAQ,EAC7DsB,GAAUhB,EAAQN,EAAM,IAAKW,CAAW,CACzC,CACA,IAAIY,EAAkB,CAAC,QAAS,QAAS,MAAO,QAAS,MAAO,QAAS,MAAO,QAAS,GAAI,QAAS,GAAI,KAAM,GAAI,KAAM,SAAU,QAAS,IAAK,UAAU,EAC5J,SAASL,EAAWZ,EAAQN,EAAOY,EAAID,EAAa,CACnD,IAAIa,EAAQxB,EAAM,SAAS,MAAM,eAAe,GAAK,CAAC,EAMlDyB,EAAO5B,EAAYS,CAAM,EAAE,cAAciB,EAAgBC,EAAM,CAAC,CAAC,GAAK,KAAK,EAC3EZ,IAAO,8BACVa,EAAK,UAAY,2CAA+CzB,EAAM,SAAW,SACjFyB,EAAOA,EAAK,YAEZA,EAAK,UAAYzB,EAAM,SAExBA,EAAM,IAAMyB,EAAK,WACjBzB,EAAM,QAAUyB,EAAK,WAAW,OAGhC,QAFIC,EAAW7B,EAAYS,CAAM,EAAE,uBAAuB,EACtDqB,EACGA,EAAQF,EAAK,YACnBC,EAAS,YAAYC,CAAK,EAE3BL,GAAUhB,EAAQoB,EAAUf,CAAW,CACxC,CACA,SAASQ,EAAeb,EAAQN,EAAOU,EAAOE,EAAID,EAAa,CAC9D,IAAIe,EAAW7B,EAAYS,CAAM,EAAE,uBAAuB,EAC1D,GAAIN,EAAM,UAAY,KAAM,CAC3B,IAAI4B,EAAW5B,EAAM,SACrBK,EAAYqB,EAAUE,EAAU,EAAGA,EAAS,OAAQlB,EAAO,KAAME,CAAE,CACpE,CACAZ,EAAM,IAAM0B,EAAS,WACrB1B,EAAM,QAAU0B,EAAS,WAAW,OACpCJ,GAAUhB,EAAQoB,EAAUf,CAAW,CACxC,CACA,SAASS,EAAcd,EAAQN,EAAOU,EAAOE,EAAID,EAAa,CAC7D,IAAII,EAAMf,EAAM,IACZ6B,EAAQ7B,EAAM,MACd8B,EAAK9B,EAAM,GAEfY,EAAKb,EAAaC,CAAK,GAAKY,EAE5B,IAAImB,EAAUnB,EACbkB,EAAKjC,EAAYS,CAAM,EAAE,gBAAgBM,EAAIG,EAAK,CAAC,GAAIe,CAAE,CAAC,EAAIjC,EAAYS,CAAM,EAAE,gBAAgBM,EAAIG,CAAG,EACzGe,EAAKjC,EAAYS,CAAM,EAAE,cAAcS,EAAK,CAAC,GAAIe,CAAE,CAAC,EAAIjC,EAAYS,CAAM,EAAE,cAAcS,CAAG,EAS9F,GARAf,EAAM,IAAM+B,EAERF,GAAS,MACZG,GAAShC,EAAO6B,EAAOjB,CAAE,EAG1BU,GAAUhB,EAAQyB,EAASpB,CAAW,EAElC,CAACsB,GAAwBjC,CAAK,GAC7BA,EAAM,UAAY,KAAM,CAC3B,IAAI4B,EAAW5B,EAAM,SACrBK,EAAY0B,EAASH,EAAU,EAAGA,EAAS,OAAQlB,EAAO,KAAME,CAAE,EAC9DZ,EAAM,MAAQ,UAAY6B,GAAS,MAAMK,GAAmBlC,EAAO6B,CAAK,CAC7E,CAEF,CACA,SAASM,GAAcnC,EAAOU,EAAO,CACpC,IAAI0B,EACJ,GAAI,OAAOpC,EAAM,IAAI,MAAS,WAAY,CAGzC,GAFAA,EAAM,MAAQ,OAAO,OAAOA,EAAM,GAAG,EACrCoC,EAAWpC,EAAM,MAAM,KACnBoC,EAAS,mBAAqB,KAAM,OACxCA,EAAS,kBAAoB,EAC9B,KAAO,CAGN,GAFApC,EAAM,MAAQ,OACdoC,EAAWpC,EAAM,IACboC,EAAS,mBAAqB,KAAM,OACxCA,EAAS,kBAAoB,GAC7BpC,EAAM,MAASA,EAAM,IAAI,WAAa,MAAQ,OAAOA,EAAM,IAAI,UAAU,MAAS,WAAc,IAAIA,EAAM,IAAIA,CAAK,EAAIA,EAAM,IAAIA,CAAK,CACvI,CAIA,GAHAgB,GAAchB,EAAM,MAAOA,EAAOU,CAAK,EACnCV,EAAM,OAAS,MAAMgB,GAAchB,EAAM,MAAOA,EAAOU,CAAK,EAChEV,EAAM,SAAWV,GAAM,UAAUa,EAAS,KAAKH,EAAM,MAAM,KAAMA,CAAK,CAAC,EACnEA,EAAM,WAAaA,EAAO,MAAM,MAAM,wDAAwD,EAClGoC,EAAS,kBAAoB,IAC9B,CACA,SAASf,EAAgBf,EAAQN,EAAOU,EAAOE,EAAID,EAAa,CAC/DwB,GAAcnC,EAAOU,CAAK,EACtBV,EAAM,UAAY,MACrBc,EAAWR,EAAQN,EAAM,SAAUU,EAAOE,EAAID,CAAW,EACzDX,EAAM,IAAMA,EAAM,SAAS,IAC3BA,EAAM,QAAUA,EAAM,SAAS,SAG/BA,EAAM,QAAU,CAElB,CAqGA,SAASqC,GAAY/B,EAAQgC,EAAK/B,EAAQG,EAAOC,EAAaC,EAAI,CACjE,GAAI,EAAA0B,IAAQ/B,GAAU+B,GAAO,MAAQ/B,GAAU,MAC1C,GAAI+B,GAAO,MAAQA,EAAI,SAAW,EAAGjC,EAAYC,EAAQC,EAAQ,EAAGA,EAAO,OAAQG,EAAOC,EAAaC,CAAE,UACrGL,GAAU,MAAQA,EAAO,SAAW,EAAGgC,GAAYjC,EAAQgC,EAAK,EAAGA,EAAI,MAAM,MACjF,CACJ,IAAIE,EAAaF,EAAI,CAAC,GAAK,MAAQA,EAAI,CAAC,EAAE,KAAO,KAC7CG,EAAUlC,EAAO,CAAC,GAAK,MAAQA,EAAO,CAAC,EAAE,KAAO,KAChDC,EAAQ,EAAGkC,EAAW,EAC1B,GAAI,CAACF,EAAY,KAAOE,EAAWJ,EAAI,QAAUA,EAAII,CAAQ,GAAK,MAAMA,IACxE,GAAI,CAACD,EAAS,KAAOjC,EAAQD,EAAO,QAAUA,EAAOC,CAAK,GAAK,MAAMA,IACrE,GAAIgC,IAAeC,EAClBF,GAAYjC,EAAQgC,EAAKI,EAAUJ,EAAI,MAAM,EAC7CjC,EAAYC,EAAQC,EAAQC,EAAOD,EAAO,OAAQG,EAAOC,EAAaC,CAAE,UAC7D6B,EAiBL,CAKN,QAHIE,GAASL,EAAI,OAAS,EAAG7B,EAAMF,EAAO,OAAS,EAAGqC,GAAKC,GAAGC,EAAGC,GAAIC,EAAIC,GAGlEN,IAAUD,GAAYjC,GAAOD,IACnCuC,GAAKT,EAAIK,EAAM,EACfK,EAAKzC,EAAOE,CAAG,EACXsC,GAAG,MAAQC,EAAG,MACdD,KAAOC,GAAIE,EAAW5C,EAAQyC,GAAIC,EAAItC,EAAOC,EAAaC,CAAE,EAC5DoC,EAAG,KAAO,OAAMrC,EAAcqC,EAAG,KACrCL,KAAUlC,IAGX,KAAOkC,IAAUD,GAAYjC,GAAOD,IACnCqC,GAAIP,EAAII,CAAQ,EAChBI,EAAIvC,EAAOC,CAAK,EACZqC,GAAE,MAAQC,EAAE,MAChBJ,IAAYlC,IACRqC,KAAMC,GAAGI,EAAW5C,EAAQuC,GAAGC,EAAGpC,EAAOyC,GAAeb,EAAKI,EAAU/B,CAAW,EAAGC,CAAE,EAG5F,KAAO+B,IAAUD,GAAYjC,GAAOD,GAC/B,EAAAA,IAAUC,GACVoC,GAAE,MAAQG,EAAG,KAAOD,GAAG,MAAQD,EAAE,MACrCG,GAAaE,GAAeb,EAAKI,EAAU/B,CAAW,EACtDyC,GAAQ9C,EAAQyC,GAAIE,EAAU,EAC1BF,KAAOD,GAAGI,EAAW5C,EAAQyC,GAAID,EAAGpC,EAAOuC,GAAYrC,CAAE,EACzD,EAAEJ,GAAS,EAAEC,GAAK2C,GAAQ9C,EAAQuC,GAAGlC,CAAW,EAChDkC,KAAMG,GAAIE,EAAW5C,EAAQuC,GAAGG,EAAItC,EAAOC,EAAaC,CAAE,EAC1DoC,EAAG,KAAO,OAAMrC,EAAcqC,EAAG,KACrCN,IAAYC,KACZI,GAAKT,EAAIK,EAAM,EACfK,EAAKzC,EAAOE,CAAG,EACfoC,GAAIP,EAAII,CAAQ,EAChBI,EAAIvC,EAAOC,CAAK,EAGjB,KAAOmC,IAAUD,GAAYjC,GAAOD,GAC/BuC,GAAG,MAAQC,EAAG,KACdD,KAAOC,GAAIE,EAAW5C,EAAQyC,GAAIC,EAAItC,EAAOC,EAAaC,CAAE,EAC5DoC,EAAG,KAAO,OAAMrC,EAAcqC,EAAG,KACrCL,KAAUlC,IACVsC,GAAKT,EAAIK,EAAM,EACfK,EAAKzC,EAAOE,CAAG,EAEhB,GAAID,EAAQC,EAAK8B,GAAYjC,EAAQgC,EAAKI,EAAUC,GAAS,CAAC,UACrDD,EAAWC,GAAQtC,EAAYC,EAAQC,EAAQC,EAAOC,EAAM,EAAGC,EAAOC,EAAaC,CAAE,MACzF,CAEJ,IAAIyC,GAAsB1C,EAAa2C,GAAe7C,EAAMD,EAAQ,EAAG+C,GAAa,IAAI,MAAMD,EAAY,EAAGE,GAAG,EAAG3C,EAAE,EAAG4C,GAAM,WAAYC,GAAU,EAAGd,GAAKe,GAC5J,IAAK9C,EAAI,EAAGA,EAAIyC,GAAczC,IAAK0C,GAAW1C,CAAC,EAAI,GACnD,IAAKA,EAAIJ,EAAKI,GAAKL,EAAOK,IAAK,CAC1B+B,IAAO,OAAMA,GAAMgB,EAAUtB,EAAKI,EAAUC,GAAS,CAAC,GAC1DK,EAAKzC,EAAOM,CAAC,EACb,IAAIgD,GAAWjB,GAAII,EAAG,GAAG,EACrBa,IAAY,OACfJ,GAAOI,GAAWJ,GAAOI,GAAW,GACpCN,GAAW1C,EAAEL,CAAK,EAAIqD,GACtBd,GAAKT,EAAIuB,EAAQ,EACjBvB,EAAIuB,EAAQ,EAAI,KACZd,KAAOC,GAAIE,EAAW5C,EAAQyC,GAAIC,EAAItC,EAAOC,EAAaC,CAAE,EAC5DoC,EAAG,KAAO,OAAMrC,EAAcqC,EAAG,KACrCU,KAEF,CAGA,GAFA/C,EAAc0C,GACVK,KAAYf,GAASD,EAAW,GAAGH,GAAYjC,EAAQgC,EAAKI,EAAUC,GAAS,CAAC,EAChFe,KAAY,EAAGrD,EAAYC,EAAQC,EAAQC,EAAOC,EAAM,EAAGC,EAAOC,EAAaC,CAAE,UAEhF6C,KAAQ,GAKX,IAFAE,GAAaG,EAAeP,EAAU,EACtCC,GAAKG,GAAW,OAAS,EACpB9C,EAAIJ,EAAKI,GAAKL,EAAOK,IACzBiC,EAAIvC,EAAOM,CAAC,EACR0C,GAAW1C,EAAEL,CAAK,IAAM,GAAIM,EAAWR,EAAQwC,EAAGpC,EAAOE,EAAID,CAAW,EAEvEgD,GAAWH,EAAE,IAAM3C,EAAIL,EAAOgD,KAC7BJ,GAAQ9C,EAAQwC,EAAGnC,CAAW,EAEhCmC,EAAE,KAAO,OAAMnC,EAAcJ,EAAOM,CAAC,EAAE,SAG5C,KAAKA,EAAIJ,EAAKI,GAAKL,EAAOK,IACzBiC,EAAIvC,EAAOM,CAAC,EACR0C,GAAW1C,EAAEL,CAAK,IAAM,IAAIM,EAAWR,EAAQwC,EAAGpC,EAAOE,EAAID,CAAW,EACxEmC,EAAE,KAAO,OAAMnC,EAAcJ,EAAOM,CAAC,EAAE,IAI/C,CACD,KA9GqB,CAEpB,IAAIkD,GAAezB,EAAI,OAAS/B,EAAO,OAAS+B,EAAI,OAAS/B,EAAO,OAKpE,IADAC,EAAQA,EAAQkC,EAAWlC,EAAQkC,EAC5BlC,EAAQuD,GAAcvD,IAC5BqC,GAAIP,EAAI9B,CAAK,EACbsC,EAAIvC,EAAOC,CAAK,EACZ,EAAAqC,KAAMC,GAAKD,IAAK,MAAQC,GAAK,QACxBD,IAAK,KAAM/B,EAAWR,EAAQwC,EAAGpC,EAAOE,EAAIuC,GAAeb,EAAK9B,EAAQ,EAAGG,CAAW,CAAC,EACvFmC,GAAK,KAAMkB,GAAW1D,EAAQuC,EAAC,EACnCK,EAAW5C,EAAQuC,GAAGC,EAAGpC,EAAOyC,GAAeb,EAAK9B,EAAQ,EAAGG,CAAW,EAAGC,CAAE,GAEjF0B,EAAI,OAASyB,IAAcxB,GAAYjC,EAAQgC,EAAK9B,EAAO8B,EAAI,MAAM,EACrE/B,EAAO,OAASwD,IAAc1D,EAAYC,EAAQC,EAAQC,EAAOD,EAAO,OAAQG,EAAOC,EAAaC,CAAE,CAC3G,CA8FD,CACD,CACA,SAASsC,EAAW5C,EAAQgC,EAAKtC,EAAOU,EAAOC,EAAaC,EAAI,CAC/D,IAAIqD,EAAS3B,EAAI,IAAKvB,EAAMf,EAAM,IAClC,GAAIiE,IAAWlD,GAAOuB,EAAI,KAAOtC,EAAM,GAAI,CAG1C,GAFAA,EAAM,MAAQsC,EAAI,MAClBtC,EAAM,OAASsC,EAAI,OACf4B,GAAgBlE,EAAOsC,CAAG,EAAG,OACjC,GAAI,OAAO2B,GAAW,SAIrB,OAHIjE,EAAM,OAAS,MAClBmE,GAAgBnE,EAAM,MAAOA,EAAOU,CAAK,EAElCuD,EAAQ,CACf,IAAK,IAAKG,EAAW9B,EAAKtC,CAAK,EAAG,MAClC,IAAK,IAAKqE,EAAW/D,EAAQgC,EAAKtC,EAAOY,EAAID,CAAW,EAAG,MAC3D,IAAK,IAAK2D,EAAehE,EAAQgC,EAAKtC,EAAOU,EAAOC,EAAaC,CAAE,EAAG,MACtE,QAAS2D,EAAcjC,EAAKtC,EAAOU,EAAOE,CAAE,CAC7C,MAEI4D,EAAgBlE,EAAQgC,EAAKtC,EAAOU,EAAOC,EAAaC,CAAE,CAChE,MAECoD,GAAW1D,EAAQgC,CAAG,EACtBxB,EAAWR,EAAQN,EAAOU,EAAOE,EAAID,CAAW,CAElD,CACA,SAASyD,EAAW9B,EAAKtC,EAAO,CAC3BsC,EAAI,SAAS,SAAS,IAAMtC,EAAM,SAAS,SAAS,IACvDsC,EAAI,IAAI,UAAYtC,EAAM,UAE3BA,EAAM,IAAMsC,EAAI,GACjB,CACA,SAAS+B,EAAW/D,EAAQgC,EAAKtC,EAAOY,EAAID,EAAa,CACpD2B,EAAI,WAAatC,EAAM,UAC1ByE,GAAUnE,EAAQgC,CAAG,EACrBpB,EAAWZ,EAAQN,EAAOY,EAAID,CAAW,IAGzCX,EAAM,IAAMsC,EAAI,IAChBtC,EAAM,QAAUsC,EAAI,QAEtB,CACA,SAASgC,EAAehE,EAAQgC,EAAKtC,EAAOU,EAAOC,EAAaC,EAAI,CACnEyB,GAAY/B,EAAQgC,EAAI,SAAUtC,EAAM,SAAUU,EAAOC,EAAaC,CAAE,EACxE,IAAI8D,EAAU,EAAG9C,EAAW5B,EAAM,SAElC,GADAA,EAAM,IAAM,KACR4B,GAAY,KACf,QAASf,EAAI,EAAGA,EAAIe,EAAS,OAAQf,IAAK,CACzC,IAAIc,EAAQC,EAASf,CAAC,EAClBc,GAAS,MAAQA,EAAM,KAAO,OAC7B3B,EAAM,KAAO,OAAMA,EAAM,IAAM2B,EAAM,KACzC+C,GAAW/C,EAAM,SAAW,EAE9B,CAED3B,EAAM,QAAU0E,CACjB,CACA,SAASH,EAAcjC,EAAKtC,EAAOU,EAAOE,EAAI,CAC7C,IAAImB,EAAU/B,EAAM,IAAMsC,EAAI,IAC9B1B,EAAKb,EAAaC,CAAK,GAAKY,GAExB0B,EAAI,OAAStC,EAAM,OAAUA,EAAM,OAAS,MAAQ,CAACP,GAAuB,IAAIO,EAAM,KAAK,IAC9F2E,GAAY3E,EAAOsC,EAAI,MAAOtC,EAAM,MAAOY,CAAE,EAEzCqB,GAAwBjC,CAAK,GACjCqC,GAAYN,EAASO,EAAI,SAAUtC,EAAM,SAAUU,EAAO,KAAME,CAAE,CAEpE,CACA,SAAS4D,EAAgBlE,EAAQgC,EAAKtC,EAAOU,EAAOC,EAAaC,EAAI,CAEpE,GADAZ,EAAM,SAAWV,GAAM,UAAUa,EAAS,KAAKH,EAAM,MAAM,KAAMA,CAAK,CAAC,EACnEA,EAAM,WAAaA,EAAO,MAAM,MAAM,wDAAwD,EAClGmE,GAAgBnE,EAAM,MAAOA,EAAOU,CAAK,EACrCV,EAAM,OAAS,MAAMmE,GAAgBnE,EAAM,MAAOA,EAAOU,CAAK,EAC9DV,EAAM,UAAY,MACjBsC,EAAI,UAAY,KAAMxB,EAAWR,EAAQN,EAAM,SAAUU,EAAOE,EAAID,CAAW,EAC9EuC,EAAW5C,EAAQgC,EAAI,SAAUtC,EAAM,SAAUU,EAAOC,EAAaC,CAAE,EAC5EZ,EAAM,IAAMA,EAAM,SAAS,IAC3BA,EAAM,QAAUA,EAAM,SAAS,UAG3BsC,EAAI,UAAY,MAAM0B,GAAW1D,EAAQgC,EAAI,QAAQ,EACzDtC,EAAM,QAAU,EAElB,CACA,SAAS4D,EAAUrD,EAAQC,EAAOC,EAAK,CAEtC,QADImC,EAAM,OAAO,OAAO,IAAI,EACrBpC,EAAQC,EAAKD,IAAS,CAC5B,IAAIR,EAAQO,EAAOC,CAAK,EACxB,GAAIR,GAAS,KAAM,CAClB,IAAI4E,EAAM5E,EAAM,IACZ4E,GAAO,OAAMhC,EAAIgC,CAAG,EAAIpE,EAC7B,CACD,CACA,OAAOoC,CACR,CAMA,IAAIiC,EAAU,CAAC,EACf,SAASf,EAAe,EAAG,CAI1B,QAHIgB,EAAS,CAAC,CAAC,EACXC,EAAI,EAAGjC,EAAI,EAAGjC,EAAI,EAClBmE,EAAKH,EAAQ,OAAS,EAAE,OACnBhE,EAAI,EAAGA,EAAImE,EAAInE,IAAKgE,EAAQhE,CAAC,EAAI,EAAEA,CAAC,EAC7C,QAASA,EAAI,EAAGA,EAAImE,EAAI,EAAEnE,EACzB,GAAI,EAAEA,CAAC,IAAM,GACb,KAAI,EAAIiE,EAAOA,EAAO,OAAS,CAAC,EAChC,GAAI,EAAE,CAAC,EAAI,EAAEjE,CAAC,EAAG,CAChBgE,EAAQhE,CAAC,EAAI,EACbiE,EAAO,KAAKjE,CAAC,EACb,QACD,CAGA,IAFAkE,EAAI,EACJjC,EAAIgC,EAAO,OAAS,EACbC,EAAIjC,GAAG,CAGb,IAAImC,GAAKF,IAAM,IAAMjC,IAAM,IAAMiC,EAAIjC,EAAI,GACrC,EAAEgC,EAAOG,CAAC,CAAC,EAAI,EAAEpE,CAAC,EACrBkE,EAAIE,EAAI,EAGRnC,EAAImC,CAEN,CACI,EAAEpE,CAAC,EAAI,EAAEiE,EAAOC,CAAC,CAAC,IACjBA,EAAI,IAAGF,EAAQhE,CAAC,EAAIiE,EAAOC,EAAI,CAAC,GACpCD,EAAOC,CAAC,EAAIlE,GAKd,IAFAkE,EAAID,EAAO,OACXhC,EAAIgC,EAAOC,EAAI,CAAC,EACTA,KAAM,GACZD,EAAOC,CAAC,EAAIjC,EACZA,EAAI+B,EAAQ/B,CAAC,EAEd,OAAA+B,EAAQ,OAAS,EACVC,CACR,CAEA,SAAS3B,GAAe5C,EAAQM,EAAGF,EAAa,CAC/C,KAAOE,EAAIN,EAAO,OAAQM,IACzB,GAAIN,EAAOM,CAAC,GAAK,MAAQN,EAAOM,CAAC,EAAE,KAAO,KAAM,OAAON,EAAOM,CAAC,EAAE,IAElE,OAAOF,CACR,CAGA,SAASyC,GAAQ9C,EAAQN,EAAOW,EAAa,CAC5C,GAAIX,EAAM,KAAO,KAAM,CACtB,IAAIkF,EACJ,GAAIlF,EAAM,SAAW,MAAQA,EAAM,UAAY,EAE9CkF,EAASlF,EAAM,QACT,CACNkF,EAASrF,EAAYS,CAAM,EAAE,uBAAuB,EACpD,QAASR,KAAON,GAAOQ,CAAK,EAAGkF,EAAO,YAAYpF,CAAG,CACtD,CACAwB,GAAUhB,EAAQ4E,EAAQvE,CAAW,CACtC,CACD,CAEA,SAASW,GAAUhB,EAAQR,EAAKa,EAAa,CACxCA,GAAe,KAAML,EAAO,aAAaR,EAAKa,CAAW,EACxDL,EAAO,YAAYR,CAAG,CAC5B,CAEA,SAASmC,GAAwBjC,EAAO,CACvC,GAAIA,EAAM,OAAS,MAClBA,EAAM,MAAM,iBAAmB,MAC/BA,EAAM,MAAM,iBAAmB,KAC7B,MAAO,GACV,IAAI4B,EAAW5B,EAAM,SACrB,GAAI4B,GAAY,MAAQA,EAAS,SAAW,GAAKA,EAAS,CAAC,EAAE,MAAQ,IAAK,CACzE,IAAIuD,EAAUvD,EAAS,CAAC,EAAE,SACtB5B,EAAM,IAAI,YAAcmF,IAASnF,EAAM,IAAI,UAAYmF,EAC5D,SACSvD,GAAY,MAAQA,EAAS,SAAW,EAAG,MAAM,IAAI,MAAM,kDAAkD,EACtH,MAAO,EACR,CAGA,SAASW,GAAYjC,EAAQC,EAAQC,EAAOC,EAAK,CAChD,QAASI,EAAIL,EAAOK,EAAIJ,EAAKI,IAAK,CACjC,IAAIb,EAAQO,EAAOM,CAAC,EAChBb,GAAS,MAAMgE,GAAW1D,EAAQN,CAAK,CAC5C,CACD,CACA,SAASoF,GAAe9E,EAAQN,EAAOqF,EAAQC,EAAS,CACvD,IAAIpF,EAAWF,EAAM,MACjB8E,EAAS3E,EAAS,KAAKkF,EAAO,eAAgBrF,CAAK,EACvD,GAAI8E,GAAU,KAEd,KAAIS,EAAa3F,EACjB,QAASE,KAAON,GAAOQ,CAAK,EAAGT,GAAe,IAAIO,EAAKyF,CAAU,EACjED,EAAQ,IAER,QAAQ,QAAQR,CAAM,EAAE,QAAQ,UAAY,CAC3C7E,EAAWD,EAAOE,CAAQ,EAC1BsF,GAAgBlF,EAAQN,EAAOsF,CAAO,CACvC,CAAC,EACF,CACA,SAASE,GAAgBlF,EAAQN,EAAOsF,EAAS,CAC5C,EAAEA,EAAQ,IAAM,IACnBG,GAASzF,CAAK,EACdyE,GAAUnE,EAAQN,CAAK,EAEzB,CACA,SAASgE,GAAW1D,EAAQN,EAAO,CAClC,IAAIsF,EAAU,CAAC,EAAG,CAAC,EACf,OAAOtF,EAAM,KAAQ,UAAY,OAAOA,EAAM,MAAM,gBAAmB,YAAYoF,GAAe9E,EAAQN,EAAOA,EAAM,MAAOsF,CAAO,EACrItF,EAAM,OAAS,OAAOA,EAAM,MAAM,gBAAmB,YAAYoF,GAAe9E,EAAQN,EAAOA,EAAM,MAAOsF,CAAO,EACvHE,GAAgBlF,EAAQN,EAAOsF,CAAO,CACvC,CACA,SAASb,GAAUnE,EAAQN,EAAO,CACjC,GAAIA,EAAM,KAAO,KACjB,GAAIA,EAAM,SAAW,MAAQA,EAAM,UAAY,EAC9CM,EAAO,YAAYN,EAAM,GAAG,MAE5B,SAASF,KAAON,GAAOQ,CAAK,EAAGM,EAAO,YAAYR,CAAG,CAEvD,CAEA,SAAS2F,GAASzF,EAAO,CAGxB,GAFI,OAAOA,EAAM,KAAQ,UAAY,OAAOA,EAAM,MAAM,UAAa,YAAYG,EAAS,KAAKH,EAAM,MAAM,SAAUA,CAAK,EACtHA,EAAM,OAAS,OAAOA,EAAM,MAAM,UAAa,YAAYG,EAAS,KAAKH,EAAM,MAAM,SAAUA,CAAK,EACpG,OAAOA,EAAM,KAAQ,SACpBA,EAAM,UAAY,MAAMyF,GAASzF,EAAM,QAAQ,MAC7C,CACFA,EAAM,QAAU,OAAMA,EAAM,OAAO,EAAI,MAC3C,IAAI4B,EAAW5B,EAAM,SACrB,GAAI,MAAM,QAAQ4B,CAAQ,EACzB,QAASf,EAAI,EAAGA,EAAIe,EAAS,OAAQf,IAAK,CACzC,IAAIc,EAAQC,EAASf,CAAC,EAClBc,GAAS,MAAM8D,GAAS9D,CAAK,CAClC,CAEF,CACD,CAGA,SAASK,GAAShC,EAAO6B,EAAOjB,EAAI,CACnC,QAASgE,KAAO/C,EACf6D,GAAQ1F,EAAO4E,EAAK,KAAM/C,EAAM+C,CAAG,EAAGhE,CAAE,CAE1C,CACA,SAAS8E,GAAQ1F,EAAO4E,EAAKtC,EAAKqD,EAAO/E,EAAI,CAC5C,GAAI,EAAAgE,IAAQ,OAASe,GAAS,MAAQC,GAAkBhB,CAAG,GAAMtC,IAAQqD,GAAS,CAACE,GAAgB7F,EAAO4E,CAAG,GAAM,OAAOe,GAAU,UACpI,IAAIf,EAAI,CAAC,IAAM,KAAOA,EAAI,CAAC,IAAM,IAAK,OAAOkB,GAAY9F,EAAO4E,EAAKe,CAAK,EAC1E,GAAIf,EAAI,MAAM,EAAG,CAAC,IAAM,SAAU5E,EAAM,IAAI,eAAe,+BAAgC4E,EAAI,MAAM,CAAC,EAAGe,CAAK,UACrGf,IAAQ,QAASmB,GAAY/F,EAAM,IAAKsC,EAAKqD,CAAK,UAClDK,GAAehG,EAAO4E,EAAKhE,CAAE,EAAG,CACxC,GAAIgE,IAAQ,QAAS,CAUpB,IAJK5E,EAAM,MAAQ,SAAWA,EAAM,MAAQ,aAAeA,EAAM,IAAI,QAAU,GAAK2F,GAEhF3F,EAAM,MAAQ,UAAYsC,IAAQ,MAAQtC,EAAM,IAAI,QAAU,GAAK2F,GAEnE3F,EAAM,MAAQ,UAAYsC,IAAQ,MAAQtC,EAAM,IAAI,QAAU,GAAK2F,EAAO,OAG9E,GAAI3F,EAAM,MAAQ,SAAWA,EAAM,MAAM,OAAS,QAAU,GAAK2F,GAAU,GAAI,CAAE,QAAQ,MAAM,sCAAsC,EAAG,MAAO,CAEhJ,CAEI3F,EAAM,MAAQ,SAAW4E,IAAQ,OAAQ5E,EAAM,IAAI,aAAa4E,EAAKe,CAAK,EACzE3F,EAAM,IAAI4E,CAAG,EAAIe,CACvB,MACK,OAAOA,GAAU,UAChBA,EAAO3F,EAAM,IAAI,aAAa4E,EAAK,EAAE,EACpC5E,EAAM,IAAI,gBAAgB4E,CAAG,EAE9B5E,EAAM,IAAI,aAAa4E,IAAQ,YAAc,QAAUA,EAAKe,CAAK,EAExE,CACA,SAASM,GAAWjG,EAAO4E,EAAKtC,EAAK1B,EAAI,CACxC,GAAI,EAAAgE,IAAQ,OAAStC,GAAO,MAAQsD,GAAkBhB,CAAG,GACzD,GAAIA,EAAI,CAAC,IAAM,KAAOA,EAAI,CAAC,IAAM,IAAKkB,GAAY9F,EAAO4E,EAAK,MAAS,UAC9DA,IAAQ,QAASmB,GAAY/F,EAAM,IAAKsC,EAAK,IAAI,UAEzD0D,GAAehG,EAAO4E,EAAKhE,CAAE,GAC1BgE,IAAQ,aACRA,IAAQ,SACR,EAAEA,IAAQ,UACZ5E,EAAM,MAAQ,UACXA,EAAM,MAAQ,UAAYA,EAAM,IAAI,gBAAkB,IAAMA,EAAM,MAAQI,EAAcJ,EAAM,GAAG,KAElG,EAAEA,EAAM,MAAQ,SAAW4E,IAAQ,QAEtC5E,EAAM,IAAI4E,CAAG,EAAI,SACX,CACN,IAAIsB,EAActB,EAAI,QAAQ,GAAG,EAC7BsB,IAAgB,KAAItB,EAAMA,EAAI,MAAMsB,EAAc,CAAC,GACnD5D,IAAQ,IAAOtC,EAAM,IAAI,gBAAgB4E,IAAQ,YAAc,QAAUA,CAAG,CACjF,CACD,CACA,SAAS1C,GAAmBlC,EAAO6B,EAAO,CACzC,GAAI,UAAWA,EACd,GAAGA,EAAM,QAAU,KACd7B,EAAM,IAAI,gBAAkB,KAAIA,EAAM,IAAI,MAAQ,UAChD,CACN,IAAImG,EAAa,GAAKtE,EAAM,OACxB7B,EAAM,IAAI,QAAUmG,GAAcnG,EAAM,IAAI,gBAAkB,MACjEA,EAAM,IAAI,MAAQmG,EAEpB,CAEG,kBAAmBtE,GAAO6D,GAAQ1F,EAAO,gBAAiB,KAAM6B,EAAM,cAAe,MAAS,CACnG,CACA,SAAS8C,GAAY3E,EAAOsC,EAAKT,EAAOjB,EAAI,CAG3C,IAAIwF,EACJ,GAAI9D,GAAO,KAAM,CACZA,IAAQT,GAAS,CAACpC,GAAuB,IAAIoC,CAAK,GACrD,QAAQ,KAAK,0FAA0F,EAExG,QAAS+C,KAAOtC,GACT8D,EAAM9D,EAAIsC,CAAG,IAAM,OAAU/C,GAAS,MAAQA,EAAM+C,CAAG,GAAK,OACjEqB,GAAWjG,EAAO4E,EAAKwB,EAAKxF,CAAE,CAGjC,CACA,GAAIiB,GAAS,KACZ,QAAS+C,KAAO/C,EACf6D,GAAQ1F,EAAO4E,EAAKtC,GAAOA,EAAIsC,CAAG,EAAG/C,EAAM+C,CAAG,EAAGhE,CAAE,CAGtD,CACA,SAASiF,GAAgB7F,EAAOqG,EAAM,CACrC,OAAOA,IAAS,SAAWA,IAAS,WAAaA,IAAS,iBAAmBA,IAAS,aAAerG,EAAM,MAAQI,EAAcJ,EAAM,GAAG,GAAKA,EAAM,MAAQ,UAAYA,EAAM,IAAI,aAAeI,EAAcJ,EAAM,GAAG,EAC1N,CACA,SAAS4F,GAAkBS,EAAM,CAChC,OAAOA,IAAS,UAAYA,IAAS,YAAcA,IAAS,YAAcA,IAAS,YAAcA,IAAS,kBAAoBA,IAAS,gBACxI,CACA,SAASL,GAAehG,EAAO4E,EAAKhE,EAAI,CAEvC,OAAOA,IAAO,SAEbZ,EAAM,IAAI,QAAQ,GAAG,EAAI,IAAMA,EAAM,IAErC4E,IAAQ,QAAUA,IAAQ,QAAUA,IAAQ,QAAUA,IAAQ,SAAWA,IAAQ,WAE7EA,KAAO5E,EAAM,GACnB,CAGA,SAAS+F,GAAYhE,EAASO,EAAKgE,EAAO,CACzC,GAAIhE,IAAQgE,EAEL,GAAIA,GAAS,KAEnBvE,EAAQ,MAAQ,WACN,OAAOuE,GAAU,SAE3BvE,EAAQ,MAAQuE,UACNhE,GAAO,MAAQ,OAAOA,GAAQ,SAAU,CAElDP,EAAQ,MAAQ,GAEhB,QAAS6C,KAAO0B,EAAO,CACtB,IAAIX,EAAQW,EAAM1B,CAAG,EACjBe,GAAS,OACRf,EAAI,SAAS,GAAG,EAAG7C,EAAQ,MAAM,YAAY6C,EAAK,OAAOe,CAAK,CAAC,EAC9D5D,EAAQ,MAAM6C,CAAG,EAAI,OAAOe,CAAK,EAExC,CACD,KAAO,CAKN,QAASf,KAAOtC,EACXA,EAAIsC,CAAG,GAAK,MAAQ0B,EAAM1B,CAAG,GAAK,OACjCA,EAAI,SAAS,GAAG,EAAG7C,EAAQ,MAAM,eAAe6C,CAAG,EAClD7C,EAAQ,MAAM6C,CAAG,EAAI,IAI5B,QAASA,KAAO0B,EAAO,CACtB,IAAIX,EAAQW,EAAM1B,CAAG,EACjBe,GAAS,OAASA,EAAQ,OAAOA,CAAK,KAAO,OAAOrD,EAAIsC,CAAG,CAAC,IAC3DA,EAAI,SAAS,GAAG,EAAG7C,EAAQ,MAAM,YAAY6C,EAAKe,CAAK,EACtD5D,EAAQ,MAAM6C,CAAG,EAAIe,EAE5B,CACD,CACD,CAaA,SAASY,IAAY,CAEpB,KAAK,EAAI5G,CACV,CACA4G,GAAU,UAAY,OAAO,OAAO,IAAI,EACxCA,GAAU,UAAU,YAAc,SAAUC,EAAI,CAC/C,IAAIC,EAAU,KAAK,KAAOD,EAAG,IAAI,EAC7B1B,EACA,OAAO2B,GAAY,WAAY3B,EAAS2B,EAAQ,KAAKD,EAAG,cAAeA,CAAE,EACpE,OAAOC,EAAQ,aAAgB,YAAYA,EAAQ,YAAYD,CAAE,EAC1E,IAAIE,EAAO,KACPA,EAAK,GAAK,OACTF,EAAG,SAAW,OAAWE,EAAK,GAAG,EACjC5B,GAAU,MAAQ,OAAOA,EAAO,MAAS,YAC5C,QAAQ,QAAQA,CAAM,EAAE,KAAK,UAAY,CACpC4B,EAAK,GAAK,MAAQF,EAAG,SAAW,OAAWE,EAAK,GAAG,CACxD,CAAC,GAGC5B,IAAW,KACd0B,EAAG,eAAe,EAClBA,EAAG,gBAAgB,EAErB,EAGA,SAASV,GAAY9F,EAAO4E,EAAKe,EAAO,CACvC,GAAI3F,EAAM,QAAU,KAAM,CAEzB,GADAA,EAAM,OAAO,EAAIL,EACbK,EAAM,OAAO4E,CAAG,IAAMe,EAAO,OAC7BA,GAAS,OAAS,OAAOA,GAAU,YAAc,OAAOA,GAAU,WACjE3F,EAAM,OAAO4E,CAAG,GAAK,MAAM5E,EAAM,IAAI,iBAAiB4E,EAAI,MAAM,CAAC,EAAG5E,EAAM,OAAQ,EAAK,EAC3FA,EAAM,OAAO4E,CAAG,EAAIe,IAEhB3F,EAAM,OAAO4E,CAAG,GAAK,MAAM5E,EAAM,IAAI,oBAAoB4E,EAAI,MAAM,CAAC,EAAG5E,EAAM,OAAQ,EAAK,EAC9FA,EAAM,OAAO4E,CAAG,EAAI,OAEtB,MAAWe,GAAS,OAAS,OAAOA,GAAU,YAAc,OAAOA,GAAU,YAC5E3F,EAAM,OAAS,IAAIuG,GACnBvG,EAAM,IAAI,iBAAiB4E,EAAI,MAAM,CAAC,EAAG5E,EAAM,OAAQ,EAAK,EAC5DA,EAAM,OAAO4E,CAAG,EAAIe,EAEtB,CAGA,SAAS3E,GAAcqE,EAAQrF,EAAOU,EAAO,CACxC,OAAO2E,EAAO,QAAW,YAAYlF,EAAS,KAAKkF,EAAO,OAAQrF,CAAK,EACvE,OAAOqF,EAAO,UAAa,YAAY3E,EAAM,KAAKP,EAAS,KAAKkF,EAAO,SAAUrF,CAAK,CAAC,CAC5F,CACA,SAASmE,GAAgBkB,EAAQrF,EAAOU,EAAO,CAC1C,OAAO2E,EAAO,UAAa,YAAY3E,EAAM,KAAKP,EAAS,KAAKkF,EAAO,SAAUrF,CAAK,CAAC,CAC5F,CACA,SAASkE,GAAgBlE,EAAOsC,EAAK,CACpC,EAAG,CACF,GAAItC,EAAM,OAAS,MAAQ,OAAOA,EAAM,MAAM,gBAAmB,WAAY,CAC5E,IAAI2G,EAAQxG,EAAS,KAAKH,EAAM,MAAM,eAAgBA,EAAOsC,CAAG,EAChE,GAAIqE,IAAU,QAAa,CAACA,EAAO,KACpC,CACA,GAAI,OAAO3G,EAAM,KAAQ,UAAY,OAAOA,EAAM,MAAM,gBAAmB,WAAY,CACtF,IAAI2G,EAAQxG,EAAS,KAAKH,EAAM,MAAM,eAAgBA,EAAOsC,CAAG,EAChE,GAAIqE,IAAU,QAAa,CAACA,EAAO,KACpC,CACA,MAAO,EACR,OAAS,IACT,OAAA3G,EAAM,IAAMsC,EAAI,IAChBtC,EAAM,QAAUsC,EAAI,QACpBtC,EAAM,SAAWsC,EAAI,SAQrBtC,EAAM,MAAQsC,EAAI,MAClBtC,EAAM,SAAWsC,EAAI,SACrBtC,EAAM,KAAOsC,EAAI,KACV,EACR,CAEA,IAAIsE,GAEJ,OAAO,SAAS9G,EAAKS,EAAQsG,EAAQ,CACpC,GAAI,CAAC/G,EAAK,MAAM,IAAI,UAAU,+CAA+C,EAC7E,GAAI8G,IAAc,MAAQ9G,EAAI,SAAS8G,EAAU,EAChD,MAAM,IAAI,UAAU,yDAAyD,EAE9E,IAAIE,EAAanH,EACboH,EAAUH,GACVlG,EAAQ,CAAC,EACTsG,EAAS5G,EAAcN,CAAG,EAC1BmH,EAAYnH,EAAI,aAEpB8G,GAAa9G,EACbH,EAAgB,OAAOkH,GAAW,WAAaA,EAAS,OACxDjH,EAAgB,CAAC,EACjB,GAAI,CAECE,EAAI,QAAU,OAAMA,EAAI,YAAc,IAC1CS,EAASjB,GAAM,kBAAkB,MAAM,QAAQiB,CAAM,EAAIA,EAAS,CAACA,CAAM,CAAC,EAC1E8B,GAAYvC,EAAKA,EAAI,OAAQS,EAAQG,EAAO,KAAMuG,IAAc,+BAAiC,OAAYA,CAAS,EACtHnH,EAAI,OAASS,EAETyG,GAAU,MAAQ5G,EAAcN,CAAG,IAAMkH,GAAU,OAAOA,EAAO,OAAU,YAAYA,EAAO,MAAM,EACxG,QAASnG,EAAI,EAAGA,EAAIH,EAAM,OAAQG,IAAKH,EAAMG,CAAC,EAAE,CACjD,QAAE,CACDlB,EAAgBmH,EAChBF,GAAaG,CACd,CACD,CACD,IC74BA,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEAA,GAAO,QAAU,KAA2B,ICF5C,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAQ,KAEZD,GAAO,QAAU,SAASE,EAAQC,EAAUC,EAAS,CACpD,IAAIC,EAAgB,CAAC,EACjBC,EAAU,GACVC,EAAS,GAEb,SAASC,GAAO,CACf,IAAKD,EAAS,EAAGA,EAASF,EAAc,OAAQE,GAAU,EACzD,GAAI,CAAEL,EAAOG,EAAcE,CAAM,EAAGN,GAAMI,EAAcE,EAAS,CAAC,CAAC,EAAGE,CAAM,CAAE,OACvEC,EAAG,CAAEN,EAAQ,MAAMM,CAAC,CAAE,CAE9BH,EAAS,EACV,CAEA,SAASE,GAAS,CACZH,IACJA,EAAU,GACVH,EAAS,UAAW,CACnBG,EAAU,GACVE,EAAK,CACN,CAAC,EAEH,CAEAC,EAAO,KAAOD,EAEd,SAASG,EAAMC,EAAMC,EAAW,CAC/B,GAAIA,GAAa,MAAQA,EAAU,MAAQ,MAAQ,OAAOA,GAAc,WACvE,MAAM,IAAI,UAAU,2CAA2C,EAGhE,IAAIC,EAAQT,EAAc,QAAQO,CAAI,EAClCE,GAAS,IACZT,EAAc,OAAOS,EAAO,CAAC,EACzBA,GAASP,IAAQA,GAAU,GAC/BL,EAAOU,EAAM,CAAC,CAAC,GAGZC,GAAa,OAChBR,EAAc,KAAKO,EAAMC,CAAS,EAClCX,EAAOU,EAAMX,GAAMY,CAAS,EAAGJ,CAAM,EAEvC,CAEA,MAAO,CAAC,MAAOE,EAAO,OAAQF,CAAM,CACrC,IChDA,IAAAM,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAS,KAEbD,GAAO,QAAU,KAA8BC,GAAQ,OAAO,sBAA0B,IAAc,sBAAwB,KAAM,OAAO,QAAY,IAAc,QAAU,IAAI,ICJnL,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEAA,GAAO,QAAU,SAASC,EAAQ,CACjC,GAAI,OAAO,UAAU,SAAS,KAAKA,CAAM,IAAM,kBAAmB,MAAO,GAEzE,IAAIC,EAAO,CAAC,EACZ,QAASC,KAAOF,EACfG,EAAYD,EAAKF,EAAOE,CAAG,CAAC,EAG7B,OAAOD,EAAK,KAAK,GAAG,EAEpB,SAASE,EAAYD,EAAKE,EAAO,CAChC,GAAI,MAAM,QAAQA,CAAK,EACtB,QAASC,EAAI,EAAGA,EAAID,EAAM,OAAQC,IACjCF,EAAYD,EAAM,IAAMG,EAAI,IAAKD,EAAMC,CAAC,CAAC,UAGlC,OAAO,UAAU,SAAS,KAAKD,CAAK,IAAM,kBAClD,QAASC,KAAKD,EACbD,EAAYD,EAAM,IAAMG,EAAI,IAAKD,EAAMC,CAAC,CAAC,OAGtCJ,EAAK,KAAK,mBAAmBC,CAAG,GAAKE,GAAS,MAAQA,IAAU,GAAK,IAAM,mBAAmBA,CAAK,EAAI,GAAG,CAChH,CACD,ICzBA,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAmB,KAGvBD,GAAO,QAAU,SAASE,EAAUC,EAAQ,CAC3C,GAAK,wBAAyB,KAAKD,CAAQ,EAC1C,MAAM,IAAI,YAAY,0EAA0E,EAEjG,GAAIC,GAAU,KAAM,OAAOD,EAC3B,IAAIE,EAAaF,EAAS,QAAQ,GAAG,EACjCG,EAAYH,EAAS,QAAQ,GAAG,EAChCI,EAAWD,EAAY,EAAIH,EAAS,OAASG,EAC7CE,EAAUH,EAAa,EAAIE,EAAWF,EACtCI,EAAON,EAAS,MAAM,EAAGK,CAAO,EAChCE,EAAQ,CAAC,EAEb,OAAO,OAAOA,EAAON,CAAM,EAE3B,IAAIO,EAAWF,EAAK,QAAQ,wBAAyB,SAASG,GAAGC,EAAKC,GAAU,CAG/E,OAFA,OAAOJ,EAAMG,CAAG,EAEZT,EAAOS,CAAG,GAAK,KAAaD,GAEzBE,GAAWV,EAAOS,CAAG,EAAI,mBAAmB,OAAOT,EAAOS,CAAG,CAAC,CAAC,CACvE,CAAC,EAGGE,EAAgBJ,EAAS,QAAQ,GAAG,EACpCK,EAAeL,EAAS,QAAQ,GAAG,EACnCM,EAAcD,EAAe,EAAIL,EAAS,OAASK,EACnDE,EAAaH,EAAgB,EAAIE,EAAcF,EAC/CI,EAASR,EAAS,MAAM,EAAGO,CAAU,EAErCb,GAAc,IAAGc,GAAUhB,EAAS,MAAME,EAAYE,CAAQ,GAC9DQ,GAAiB,IAAGI,IAAWd,EAAa,EAAI,IAAM,KAAOM,EAAS,MAAMI,EAAeE,CAAW,GAC1G,IAAIG,EAAclB,GAAiBQ,CAAK,EACxC,OAAIU,IAAaD,IAAWd,EAAa,GAAKU,EAAgB,EAAI,IAAM,KAAOK,GAC3Ed,GAAa,IAAGa,GAAUhB,EAAS,MAAMG,CAAS,GAClDU,GAAgB,IAAGG,IAAWb,EAAY,EAAI,GAAK,KAAOK,EAAS,MAAMK,CAAY,GAClFG,CACR,ICzCA,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAgB,KAChBC,GAAS,KAEbF,GAAO,QAAU,SAASG,EAASC,EAAc,CAChD,SAASC,EAAaC,EAAU,CAC/B,OAAO,IAAI,QAAQA,CAAQ,CAC5B,CAEA,SAASC,EAAYC,EAAKC,EAAM,CAC/B,OAAO,IAAI,QAAQ,SAASC,EAASC,EAAQ,CAC5CH,EAAMP,GAAcO,EAAKC,EAAK,MAAM,EACpC,IAAIG,EAASH,EAAK,QAAU,KAAOA,EAAK,OAAO,YAAY,EAAI,MAC3DI,EAAOJ,EAAK,KACZK,GAAcL,EAAK,WAAa,MAAQA,EAAK,YAAc,KAAK,YAAc,EAAEI,aAAgBV,EAAQ,UAAYU,aAAgBV,EAAQ,iBAC5IY,EAAeN,EAAK,eAAiB,OAAOA,EAAK,SAAY,WAAa,GAAK,QAE/EO,EAAM,IAAIb,EAAQ,eAAkBc,EAAU,GAAOC,GAAY,GACjEC,EAAWH,EAAKI,GAChBC,EAAQL,EAAI,MAEhBA,EAAI,MAAQ,UAAW,CACtBC,EAAU,GACVI,EAAM,KAAK,IAAI,CAChB,EAEAL,EAAI,KAAKJ,EAAQJ,EAAKC,EAAK,QAAU,GAAO,OAAOA,EAAK,MAAS,SAAWA,EAAK,KAAO,OAAW,OAAOA,EAAK,UAAa,SAAWA,EAAK,SAAW,MAAS,EAE5JK,GAAcD,GAAQ,MAAQ,CAACS,EAAUb,EAAM,cAAc,GAChEO,EAAI,iBAAiB,eAAgB,iCAAiC,EAEnE,OAAOP,EAAK,aAAgB,YAAc,CAACa,EAAUb,EAAM,QAAQ,GACtEO,EAAI,iBAAiB,SAAU,0BAA0B,EAEtDP,EAAK,kBAAiBO,EAAI,gBAAkBP,EAAK,iBACjDA,EAAK,UAASO,EAAI,QAAUP,EAAK,SACrCO,EAAI,aAAeD,EAEnB,QAASQ,KAAOd,EAAK,QAChBP,GAAO,KAAKO,EAAK,QAASc,CAAG,GAChCP,EAAI,iBAAiBO,EAAKd,EAAK,QAAQc,CAAG,CAAC,EAI7CP,EAAI,mBAAqB,SAASQ,EAAI,CAErC,GAAI,CAAAP,GAEAO,EAAG,OAAO,aAAe,EAC5B,GAAI,CACH,IAAIC,EAAWD,EAAG,OAAO,QAAU,KAAOA,EAAG,OAAO,OAAS,KAAQA,EAAG,OAAO,SAAW,KAAQ,cAAe,KAAKhB,CAAG,EAMrHkB,EAAWF,EAAG,OAAO,SAAUG,EAEnC,GAAIZ,IAAiB,QAGpB,GAAI,CAACS,EAAG,OAAO,cAAgB,OAAOf,EAAK,SAAY,WAEtD,GAAI,CAAEiB,EAAW,KAAK,MAAMF,EAAG,OAAO,YAAY,CAAE,MAC1C,CAAEE,EAAW,IAAK,OAEnB,CAACX,GAAgBA,IAAiB,SAMxCW,GAAY,OAAMA,EAAWF,EAAG,OAAO,cAU5C,GAPI,OAAOf,EAAK,SAAY,YAC3BiB,EAAWjB,EAAK,QAAQe,EAAG,OAAQf,CAAI,EACvCgB,EAAU,IACA,OAAOhB,EAAK,aAAgB,aACtCiB,EAAWjB,EAAK,YAAYiB,CAAQ,GAGjCD,EAAS,CACZ,GAAI,OAAOhB,EAAK,MAAS,WACxB,GAAI,MAAM,QAAQiB,CAAQ,EACzB,QAASE,EAAI,EAAGA,EAAIF,EAAS,OAAQE,IACpCF,EAASE,CAAC,EAAI,IAAInB,EAAK,KAAKiB,EAASE,CAAC,CAAC,OAGpCF,EAAW,IAAIjB,EAAK,KAAKiB,CAAQ,EAEvChB,EAAQgB,CAAQ,CACjB,KACK,CACJ,IAAIG,EAAwB,UAAW,CACtC,GAAI,CAAEF,EAAUH,EAAG,OAAO,YAAa,MAC7B,CAAEG,EAAUD,CAAS,CAC/B,IAAII,EAAQ,IAAI,MAAMH,CAAO,EAC7BG,EAAM,KAAON,EAAG,OAAO,OACvBM,EAAM,SAAWJ,EACjBf,EAAOmB,CAAK,CACb,EAEId,EAAI,SAAW,EAKlB,WAAW,UAAW,CACjBE,IACJW,EAAsB,CACvB,CAAC,EACKA,EAAsB,CAC9B,CACD,OACOE,EAAG,CACTpB,EAAOoB,CAAC,CACT,CAEF,EAEAf,EAAI,UAAY,SAAUQ,EAAI,CAC7BN,GAAY,GACZ,IAAIY,EAAQ,IAAI,MAAM,mBAAmB,EACzCA,EAAM,KAAON,EAAG,OAAO,OACvBb,EAAOmB,CAAK,CACb,EAEI,OAAOrB,EAAK,QAAW,aAC1BO,EAAMP,EAAK,OAAOO,EAAKP,EAAMD,CAAG,GAAKQ,EAGjCA,IAAQG,IACXC,GAAgBJ,EAAI,MACpBA,EAAI,MAAQ,UAAW,CACtBC,EAAU,GACVG,GAAc,KAAK,IAAI,CACxB,IAIEP,GAAQ,KAAMG,EAAI,KAAK,EAClB,OAAOP,EAAK,WAAc,WAAYO,EAAI,KAAKP,EAAK,UAAUI,CAAI,CAAC,EACnEA,aAAgBV,EAAQ,UAAYU,aAAgBV,EAAQ,gBAAiBa,EAAI,KAAKH,CAAI,EAC9FG,EAAI,KAAK,KAAK,UAAUH,CAAI,CAAC,CACnC,CAAC,CACF,CAKAR,EAAa,UAAY,QAAQ,UACjCA,EAAa,UAAY,QAEzB,SAASiB,EAAUb,EAAMuB,EAAM,CAC9B,QAAST,KAAOd,EAAK,QACpB,GAAIP,GAAO,KAAKO,EAAK,QAASc,CAAG,GAAKA,EAAI,YAAY,IAAMS,EAAM,MAAO,GAE1E,MAAO,EACR,CAEA,MAAO,CACN,QAAS,SAASxB,EAAKC,EAAM,CACxB,OAAOD,GAAQ,UAAYC,EAAOD,EAAKA,EAAMA,EAAI,KAC5CC,GAAQ,OAAMA,EAAO,CAAC,GAC/B,IAAIwB,EAAU1B,EAAYC,EAAKC,CAAI,EACnC,GAAIA,EAAK,aAAe,GAAM,OAAOwB,EACrC,IAAIC,EAAQ,EACZ,SAASC,GAAW,CACf,EAAED,IAAU,GAAK,OAAO9B,GAAiB,YAAYA,EAAa,CACvE,CAEA,OAAOgC,EAAKH,CAAO,EAEnB,SAASG,EAAKH,EAAS,CACtB,IAAII,EAAOJ,EAAQ,KAQnB,OAAAA,EAAQ,YAAc5B,EACtB4B,EAAQ,KAAO,UAAW,CACzBC,IACA,IAAII,EAAOD,EAAK,MAAMJ,EAAS,SAAS,EACxC,OAAAK,EAAK,KAAKH,EAAU,SAASJ,EAAG,CAE/B,GADAI,EAAS,EACLD,IAAU,EAAG,MAAMH,CACxB,CAAC,EACMK,EAAKE,CAAI,CACjB,EACOL,CACR,CACD,CACD,CACD,ICtMA,IAAAM,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAc,KAElBD,GAAO,QAAU,KAA6B,OAAO,OAAW,IAAc,OAAS,KAAMC,GAAY,MAAM,ICJ/G,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cA8BA,IAAIC,GAAqB,qHAEzBD,GAAO,QAAU,SAASE,EAAK,CAC9B,OAAO,OAAOA,CAAG,EAAE,QAAQD,GAAoB,kBAAkB,CAClE,IClCA,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAyB,KAE7BD,GAAO,QAAU,SAASE,EAAQ,CACjC,GAAIA,IAAW,IAAMA,GAAU,KAAM,MAAO,CAAC,EACzCA,EAAO,OAAO,CAAC,IAAM,MAAKA,EAASA,EAAO,MAAM,CAAC,GAGrD,QADIC,EAAUD,EAAO,MAAM,GAAG,EAAGE,EAAW,CAAC,EAAGC,EAAO,CAAC,EAC/C,EAAI,EAAG,EAAIF,EAAQ,OAAQ,IAAK,CACxC,IAAIG,EAAQH,EAAQ,CAAC,EAAE,MAAM,GAAG,EAC5BI,EAAMN,GAAuBK,EAAM,CAAC,CAAC,EACrCE,EAAQF,EAAM,SAAW,EAAIL,GAAuBK,EAAM,CAAC,CAAC,EAAI,GAEhEE,IAAU,OAAQA,EAAQ,GACrBA,IAAU,UAASA,EAAQ,IAEpC,IAAIC,EAASF,EAAI,MAAM,UAAU,EAC7BG,EAASL,EACTE,EAAI,QAAQ,GAAG,EAAI,IAAIE,EAAO,IAAI,EACtC,QAASE,EAAI,EAAGA,EAAIF,EAAO,OAAQE,IAAK,CACvC,IAAIC,EAAQH,EAAOE,CAAC,EAAGE,EAAYJ,EAAOE,EAAI,CAAC,EAC3CG,EAAWD,GAAa,IAAM,CAAC,MAAM,SAASA,EAAW,EAAE,CAAC,EAChE,GAAID,IAAU,GAAI,CACjB,IAAIL,EAAME,EAAO,MAAM,EAAGE,CAAC,EAAE,KAAK,EAC9BP,EAASG,CAAG,GAAK,OACpBH,EAASG,CAAG,EAAI,MAAM,QAAQG,CAAM,EAAIA,EAAO,OAAS,GAEzDE,EAAQR,EAASG,CAAG,GACrB,SAESK,IAAU,YAAa,MAChC,GAAID,IAAMF,EAAO,OAAS,EAAGC,EAAOE,CAAK,EAAIJ,MACxC,CAGJ,IAAIO,EAAO,OAAO,yBAAyBL,EAAQE,CAAK,EACpDG,GAAQ,OAAMA,EAAOA,EAAK,OAC1BA,GAAQ,OAAML,EAAOE,CAAK,EAAIG,EAAOD,EAAW,CAAC,EAAI,CAAC,GAC1DJ,EAASK,CACV,CACD,CACD,CACA,OAAOV,CACR,IC5CA,IAAAW,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAmB,KAGvBD,GAAO,QAAU,SAASE,EAAK,CAC9B,IAAIC,EAAaD,EAAI,QAAQ,GAAG,EAC5BE,EAAYF,EAAI,QAAQ,GAAG,EAC3BG,EAAWD,EAAY,EAAIF,EAAI,OAASE,EACxCE,EAAUH,EAAa,EAAIE,EAAWF,EACtCI,EAAOL,EAAI,MAAM,EAAGI,CAAO,EAAE,QAAQ,UAAW,GAAG,EAEvD,OAAKC,EAEAA,EAAK,CAAC,IAAM,MAAKA,EAAO,IAAMA,GAFxBA,EAAO,IAIX,CACN,KAAMA,EACN,OAAQJ,EAAa,EAClB,CAAC,EACDF,GAAiBC,EAAI,MAAMC,EAAa,EAAGE,CAAQ,CAAC,CACxD,CACD,ICtBA,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAgB,KAOpBD,GAAO,QAAU,SAASE,EAAU,CACnC,IAAIC,EAAeF,GAAcC,CAAQ,EACrCE,EAAe,OAAO,KAAKD,EAAa,MAAM,EAC9CE,EAAO,CAAC,EACRC,EAAS,IAAI,OAAO,IAAMH,EAAa,KAAK,QAK/C,qDACA,SAASI,EAAGC,EAAKC,EAAO,CACvB,OAAID,GAAO,KAAa,KAAOD,GAC/BF,EAAK,KAAK,CAAC,EAAGG,EAAK,EAAGC,IAAU,KAAK,CAAC,EAClCA,IAAU,MAAc,OACxBA,IAAU,IAAY,aACnB,WAAaA,GAAS,IAC9B,CACD,EAAI,OAAO,EACX,OAAO,SAASC,EAAM,CAGrB,QAASC,EAAI,EAAGA,EAAIP,EAAa,OAAQO,IACxC,GAAIR,EAAa,OAAOC,EAAaO,CAAC,CAAC,IAAMD,EAAK,OAAON,EAAaO,CAAC,CAAC,EAAG,MAAO,GAGnF,GAAI,CAACN,EAAK,OAAQ,OAAOC,EAAO,KAAKI,EAAK,IAAI,EAC9C,IAAIE,EAASN,EAAO,KAAKI,EAAK,IAAI,EAClC,GAAIE,GAAU,KAAM,MAAO,GAC3B,QAASD,EAAI,EAAGA,EAAIN,EAAK,OAAQM,IAChCD,EAAK,OAAOL,EAAKM,CAAC,EAAE,CAAC,EAAIN,EAAKM,CAAC,EAAE,EAAIC,EAAOD,EAAI,CAAC,EAAI,mBAAmBC,EAAOD,EAAI,CAAC,CAAC,EAEtF,MAAO,EACR,CACD,IC1CA,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAyBA,IAAIC,GAAS,KACTC,GAAQ,4EAEZF,GAAO,QAAU,SAASG,EAAOC,EAAQ,CACxC,IAAIC,EAAS,CAAC,EAEd,GAAID,GAAU,KACb,QAASE,KAAOH,EACXF,GAAO,KAAKE,EAAOG,CAAG,GAAK,CAACJ,GAAM,KAAKI,CAAG,GAAKF,EAAO,QAAQE,CAAG,EAAI,IACxED,EAAOC,CAAG,EAAIH,EAAMG,CAAG,OAIzB,SAASA,KAAOH,EACXF,GAAO,KAAKE,EAAOG,CAAG,GAAK,CAACJ,GAAM,KAAKI,CAAG,IAC7CD,EAAOC,CAAG,EAAIH,EAAMG,CAAG,GAK1B,OAAOD,CACR,IC9CA,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAQ,KACRC,GAAc,KAEdC,GAAyB,KACzBC,GAAgB,KAChBC,GAAgB,KAChBC,GAAkB,KAClBC,GAAS,KAEbP,GAAO,QAAU,SAASQ,EAASC,EAAa,CAC/C,IAAIC,EAAI,QAAQ,QAAQ,EAEpBC,EAAY,GAEZC,EAAQ,GACRC,EAAkB,GAElBC,EAAKC,EAAUC,EAEfC,EAAiBC,EAAWC,EAAOC,EAAaC,EAEhDC,EAAa,CAChB,SAAU,UAAW,CACpBV,EAAQC,EAAkB,GAC1BL,EAAQ,oBAAoB,WAAYe,GAAW,EAAK,CACzD,EACA,KAAM,UAAW,CAKhB,IAAIC,EAAQvB,GAAMiB,EAAWC,EAAM,IAAKA,CAAK,EAC7C,OAAIF,EAAwBA,EAAgB,OAAOO,CAAK,EAEjD,CAACA,CAAK,CACd,CACD,EAEIC,GAAOC,EAAM,KAAO,CAAC,EAEzB,SAASC,GAAe,CACvBhB,EAAY,GAGZ,IAAIiB,EAASpB,EAAQ,SAAS,KAC1BkB,EAAM,OAAO,CAAC,IAAM,MACvBE,EAASpB,EAAQ,SAAS,OAASoB,EAC/BF,EAAM,OAAO,CAAC,IAAM,MACvBE,EAASpB,EAAQ,SAAS,SAAWoB,EACjCA,EAAO,CAAC,IAAM,MAAKA,EAAS,IAAMA,KAGxC,IAAIC,EAAO1B,GAAuByB,CAAM,EAAE,MAAMF,EAAM,OAAO,MAAM,EAC/DI,EAAOzB,GAAcwB,CAAI,EAE7B,OAAO,OAAOC,EAAK,OAAQtB,EAAQ,QAAQ,KAAK,EAEhD,SAASuB,EAAOC,EAAG,CAClB,QAAQ,MAAMA,CAAC,EACfN,EAAM,IAAIV,EAAe,KAAM,CAAC,QAAS,EAAI,CAAC,CAC/C,CAEAiB,EAAK,CAAC,EACN,SAASA,EAAKC,EAAG,CAChB,KAAOA,EAAInB,EAAS,OAAQmB,IAC3B,GAAInB,EAASmB,CAAC,EAAE,MAAMJ,CAAI,EAAG,CAC5B,IAAIK,EAAUpB,EAASmB,CAAC,EAAE,UACtBE,EAAerB,EAASmB,CAAC,EAAE,MAC3BG,GAAYF,EACZG,GAASjB,EAAa,SAASkB,GAAM,CACxC,GAAID,KAAWjB,EACf,IAAIkB,KAASd,GAAM,OAAOQ,EAAKC,EAAI,CAAC,EACpChB,EAAYqB,IAAQ,OAAS,OAAOA,GAAK,MAAS,YAAc,OAAOA,IAAS,YAAaA,GAAO,MACpGpB,EAAQW,EAAK,OAAQV,EAAcS,EAAMR,EAAa,KACtDJ,EAAkBkB,EAAQ,OAASA,EAAU,KACzCtB,EAAiBJ,EAAY,OAAO,GAEvCI,EAAkB,GAClBJ,EAAY,MAAMK,EAAKQ,CAAU,GAEnC,EAGIa,EAAQ,MAAQ,OAAOA,GAAY,YACtCA,EAAU,CAAC,EACXG,GAAOD,EAAS,GAERF,EAAQ,QAChBzB,EAAE,KAAK,UAAY,CAClB,OAAOyB,EAAQ,QAAQL,EAAK,OAAQD,EAAMO,CAAY,CACvD,CAAC,EAAE,KAAKE,GAAQT,IAASb,EAAgB,KAAOe,CAAM,EAElDO,GAAkB,EACvB,MACD,CAGD,GAAIT,IAASb,EACZ,MAAM,IAAI,MAAM,mCAAqCA,EAAgB,GAAG,EAEzEU,EAAM,IAAIV,EAAe,KAAM,CAAC,QAAS,EAAI,CAAC,CAC/C,CACD,CAEA,SAASO,IAAY,CACfZ,IACJA,EAAY,GAIZ,WAAWgB,CAAY,EAEzB,CAEA,SAASD,EAAMc,EAAMC,EAAcC,EAAQ,CAC1C,GAAI,CAACF,EAAM,MAAM,IAAI,UAAU,+CAA+C,EAc9E,GAZAzB,EAAW,OAAO,KAAK2B,CAAM,EAAE,IAAI,SAAShB,EAAO,CAClD,GAAIA,EAAM,CAAC,IAAM,IAAK,MAAM,IAAI,YAAY,+BAA+B,EAC3E,GAAK,wBAAyB,KAAKA,CAAK,EACvC,MAAM,IAAI,YAAY,uEAAuE,EAE9F,MAAO,CACN,MAAOA,EACP,UAAWgB,EAAOhB,CAAK,EACvB,MAAOpB,GAAgBoB,CAAK,CAC7B,CACD,CAAC,EACDV,EAAgByB,EACZA,GAAgB,KAAM,CACzB,IAAIE,EAActC,GAAcoC,CAAY,EAE5C,GAAI,CAAC1B,EAAS,KAAK,SAAUmB,EAAG,CAAE,OAAOA,EAAE,MAAMS,CAAW,CAAE,CAAC,EAC9D,MAAM,IAAI,eAAe,+CAA+C,CAE1E,CACA7B,EAAM0B,EAENhC,EAAQ,iBAAiB,WAAYe,GAAW,EAAK,EAErDX,EAAQ,GAGRe,EAAa,CACd,CACA,OAAAD,EAAM,IAAM,SAASG,EAAMC,EAAMc,EAAS,CAQzC,GAPIvB,GAAc,OACjBuB,EAAUA,GAAW,CAAC,EACtBA,EAAQ,QAAU,IAEnBvB,EAAa,KAEbQ,EAAOzB,GAAcyB,EAAMC,CAAI,EAC3BlB,EAAO,CACVW,GAAU,EACV,IAAIsB,EAAQD,EAAUA,EAAQ,MAAQ,KAClCE,EAAQF,EAAUA,EAAQ,MAAQ,KAClCA,GAAWA,EAAQ,QAASpC,EAAQ,QAAQ,aAAaqC,EAAOC,EAAOpB,EAAM,OAASG,CAAI,EACzFrB,EAAQ,QAAQ,UAAUqC,EAAOC,EAAOpB,EAAM,OAASG,CAAI,CACjE,MAECrB,EAAQ,SAAS,KAAOkB,EAAM,OAASG,CAEzC,EACAH,EAAM,IAAM,UAAW,CAAC,OAAON,CAAW,EAC1CM,EAAM,OAAS,KACfA,EAAM,KAAO,CACZ,KAAM,SAASF,EAAO,CAMrB,IAAIuB,EAAQ7C,GACXsB,EAAM,MAAM,UAAY,IACxBjB,GAAOiB,EAAM,MAAO,CAAC,UAAW,SAAU,WAAY,SAAS,CAAC,EAChEA,EAAM,QACP,EACIoB,EAASI,EAASC,EAQtB,OAAIF,EAAM,MAAM,SAAW,EAAQA,EAAM,MAAM,WAC9CA,EAAM,MAAM,KAAO,KACnBA,EAAM,MAAM,eAAe,EAAI,SAI/BH,EAAUpB,EAAM,MAAM,QACtBwB,EAAUxB,EAAM,MAAM,QAEtByB,EAAO7C,GAAc2C,EAAM,MAAM,KAAMvB,EAAM,MAAM,MAAM,EACzDuB,EAAM,MAAM,KAAOrB,EAAM,OAASuB,EAClCF,EAAM,MAAM,QAAU,SAASf,EAAG,CACjC,IAAIkB,EACA,OAAOF,GAAY,WACtBE,EAASF,EAAQ,KAAKhB,EAAE,cAAeA,CAAC,EAC9BgB,GAAW,MAAQ,OAAOA,GAAY,UAEtC,OAAOA,EAAQ,aAAgB,YACzCA,EAAQ,YAAYhB,CAAC,EAcrBkB,IAAW,IAAS,CAAClB,EAAE,mBAEtBA,EAAE,SAAW,GAAKA,EAAE,QAAU,GAAKA,EAAE,QAAU,KAE/C,CAACA,EAAE,cAAc,QAAUA,EAAE,cAAc,SAAW,UAEvD,CAACA,EAAE,SAAW,CAACA,EAAE,SAAW,CAACA,EAAE,UAAY,CAACA,EAAE,SAE9CA,EAAE,eAAe,EACjBA,EAAE,OAAS,GACXN,EAAM,IAAIuB,EAAM,KAAML,CAAO,EAE/B,GAEMG,CACR,CACD,EACArB,EAAM,MAAQ,SAASyB,EAAK,CAC3B,OAAOhC,GAASgC,GAAO,KAAOhC,EAAMgC,CAAG,EAAIhC,CAC5C,EAEOO,CACR,IClPA,IAAA0B,GAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAc,KAElBD,GAAO,QAAU,KAAwB,OAAO,OAAW,IAAc,OAAS,KAAMC,EAAW,ICJnG,IAAAC,EAAAC,EAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAc,KACdC,GAAc,KACdC,GAAU,KACVC,GAAS,KAETC,GAAI,UAAa,CAAE,OAAOJ,GAAY,MAAM,KAAM,SAAS,CAAE,EACjEI,GAAE,EAAIJ,GACNI,GAAE,MAAQJ,GAAY,MACtBI,GAAE,SAAWJ,GAAY,SACzBI,GAAE,SAAW,IACbA,GAAE,MAAQH,GAAY,MACtBG,GAAE,MAAQD,GACVC,GAAE,OAAS,KACXA,GAAE,OAASH,GAAY,OACvBG,GAAE,QAAUF,GAAQ,QACpBE,GAAE,iBAAmB,KACrBA,GAAE,iBAAmB,KACrBA,GAAE,cAAgB,KAClBA,GAAE,cAAgB,KAClBA,GAAE,MAAQ,KACVA,GAAE,OAAS,KACXA,GAAE,OAAS,KAEXL,GAAO,QAAUK,KCzBjB,IAAAC,GAAc,OCKd,IAAAC,EAAc,OCLd,IAAAC,EAAc,OCUP,SAASC,GACdC,EACAC,EACA,CACA,QAAQ,KAAK,uBAAuBD,CAAK,GAAIC,CAAM,EAElD,OAAe,SAAS,cACvB,IAAI,YAAYD,EAAO,CACrB,OAAAC,CACF,CAAC,CACH,CACF,CAKO,SAASC,GACdF,EACAG,EACA,CACC,OAAe,SAAS,iBAAiBH,EAAOG,CAAQ,CAC3D,CAOO,SAASC,GAAMC,EAAc,CAClCA,GAAO,eAAe,CACxB,CAOO,SAASC,EAASC,EAAe,CACtC,OAAQF,GAAiB,CACvBN,GAAU,WAAY,CAAE,MAAAQ,CAAM,CAAC,EAC/BH,GAAMC,CAAK,CACb,CACF,CD1CA,SAASG,IAAa,CACpB,IAAMC,EAAWC,GAAa,CAC5BC,GAAU,oBAAqB,CAAC,CAAC,CACnC,EAEA,MAAO,CACL,MAAO,CACL,SAAO,EAAAC,SAAE,IAAK,CAAE,QAAAH,CAAQ,KAAG,EAAAG,SAAE,cAAe,QAAG,CAAC,CAClD,CACF,CACF,CAKA,SAASC,IAAkB,CACzB,IAAMC,EAAa,SAEnB,MAAO,CACL,MAAO,CACL,SAAO,EAAAF,SAAE,IAAK,CACZ,KAAM,KACN,QAASG,EAAS,GAAG,CACvB,KAAG,EAAAH,SAAE,aAAcE,CAAU,CAAC,CAChC,CACF,CACF,CAKA,SAASE,IAAU,CACjB,IAAMC,KAAW,EAAAL,SAAE,OAAQ,CACzB,KAAM,UACN,EAAG,0ZACL,CAAC,EAED,MAAO,CACL,MAAO,CACL,SAAO,EAAAA,SACL,QACA,CAAE,MAAO,MAAO,KAAM,+BAAgC,EACtD,IACE,EAAAA,SAAE,MAAO,CACP,IAAK,MACL,MAAO,OACP,OAAQ,OACR,QAAS,YACT,MAAO,+BACT,EAAG,CACDK,CACF,CAAC,CACH,CACF,CACF,CACF,CACF,CAGA,SAASC,IAAc,CACrB,MAAO,CACL,KAAKC,EAA6B,CAChC,IAAMC,EAAOD,EAAM,MAAM,SAAW,eAAO,YAE3C,SAAO,EAAAP,SACL,IACA,CAAC,KACD,EAAAA,SAAE,oBAAqB,CACrB,QAAS,IAAM,CACbD,GAAU,eAAgB,CAAC,CAAC,CAC9B,CACF,EAAGS,CAAI,CACT,CACF,CACF,CACF,CAGO,SAASC,IAAS,CACvB,MAAO,CACL,KAAKF,EAA6B,CAChC,SAAO,EAAAP,SAAE,aAAc,CAAE,KAAM,YAAa,EAAG,IAI7C,EAAAA,SAAE,KAAM,CAAE,MAAO,eAAgB,EAAG,IAClC,EAAAA,SAAE,iBAAkB,CAAC,KAAG,EAAAA,SAAEJ,GAAW,CAAC,CAAC,KACvC,EAAAI,SAAE,iBAAkB,CAAC,KAAG,EAAAA,SAAEC,GAAgB,CAAC,CAAC,KAC5C,EAAAD,SAAE,yBAA0B,CAAE,MAAO,cAAe,KAAG,EAAAA,SAAEI,GAAQ,CAAC,CAAC,KACnE,EAAAJ,SACE,iBACA,CAAE,MAAO,cAAe,KACxB,EAAAA,SAAEM,GAAY,EAAG,CACf,SAAUC,EAAM,MAAM,QACxB,CAAC,CACH,CACF,CAAC,CACH,CAAC,CACH,CACF,CACF,CE3GO,SAASG,IAAO,CACrB,OAAO,aAAa,QAAQ,UAAU,IAAM,MAC9C,CCJA,IAAIC,GAAa,MAAMC,EAAY,CACjCC,GACAC,GACAC,GACA,aAAc,CACZ,KAAKF,GAAO,EACZ,KAAKC,GAAuB,IAAI,IAChC,KAAKC,GAA8B,IAAI,GACzC,CAIA,KAAM,CACJ,OAAO,KAAKD,EACd,CAIA,YAAa,CACX,OAAO,KAAKC,EACd,CAIA,IAAIC,EAAO,CACT,OAAI,KAAKF,GAAK,IAAIE,CAAK,EACd,KAAKF,GAAK,IAAIE,CAAK,GAE5B,KAAKF,GAAK,IAAIE,EAAO,KAAKH,EAAI,EAC9B,KAAKE,GAAY,IAAI,KAAKF,GAAMG,CAAK,EACrC,KAAKH,KACE,KAAKA,GAAO,EACrB,CAIA,SAASG,EAAOC,EAAO,CACrB,KAAKH,GAAK,IAAIE,EAAOC,CAAK,EAC1B,KAAKF,GAAY,IAAIE,EAAOD,CAAK,CACnC,CAIA,SAASA,EAAO,CACd,OAAO,KAAKF,GAAK,IAAIE,CAAK,CAC5B,CAIA,SAASE,EAAK,CACZ,OAAO,KAAKH,GAAY,IAAIG,CAAG,CACjC,CAIA,IAAIF,EAAO,CACT,OAAO,KAAKF,GAAK,IAAIE,CAAK,CAC5B,CACA,OAAQ,CACN,IAAMG,EAAS,IAAIP,GACnB,OAAW,CAACQ,EAAKJ,CAAK,IAAK,KAAKF,GAAK,QAAQ,EAC3CK,EAAO,SAASC,EAAKJ,CAAK,EAE5B,OAAOG,CACT,CACF,EAGIE,GAAgB,KAAM,CACxB,YACA,aAAc,CACZ,KAAK,YAAc,IAAIV,EACzB,CAIA,YAAYW,EAAM,CAChB,IAAMC,EAAQD,EAAK,MAAM,qBAAqB,EAC9C,GAAI,CAACC,EACH,MAAM,IAAI,YAAY,mCAAmCD,CAAI,EAAE,EAEjE,IAAME,EAAM,KAAK,YAAY,SAAS,SAASD,EAAM,CAAC,EAAG,EAAE,CAAC,EACtDE,EAAM,KAAK,YAAY,SAAS,SAASF,EAAM,CAAC,EAAG,EAAE,CAAC,EACtDG,EAAM,KAAK,YAAY,SAAS,SAASH,EAAM,CAAC,EAAG,EAAE,CAAC,EAC5D,GAAIC,IAAQ,QAAUC,IAAQ,QAAUC,IAAQ,OAC9C,MAAM,IAAI,YAAY,6BAA6BJ,CAAI,EAAE,EAE3D,MAAO,CAACE,EAAKC,EAAKC,CAAG,CACvB,CAKA,iBAAiBJ,EAAM,CACrB,IAAMC,EAAQD,EAAK,MAAM,gBAAgB,EACzC,GAAI,CAACC,EACH,MAAM,IAAI,YAAY,wCAAwCD,CAAI,EAAE,EAEtE,IAAMK,EAAKJ,EAAM,CAAC,EACZP,EAAQO,EAAM,CAAC,EACrB,KAAK,YAAY,SAASP,EAAO,SAASW,EAAI,EAAE,CAAC,CACnD,CAKA,MAAML,EAAM,CAEV,GADiB,wBACJ,KAAKA,CAAI,EACpB,OAAO,KAAK,YAAYA,CAAI,EAE5B,KAAK,iBAAiBA,CAAI,CAG9B,CACF,EA6BA,SAASM,GAASC,EAAK,CACrB,IAAMC,EAAYD,EAAI,MAAM,IAAK,CAAC,EAC5BE,EAAOD,EAAU,CAAC,EAClBE,EAAYF,EAAU,CAAC,GAAK,GAC5BG,EAAMD,EAAU,QAAQ,GAAG,EAC3BE,EAAcD,IAAQ,GAAKD,EAAU,MAAMC,EAAM,CAAC,EAAI,GACtDE,EAAKF,IAAQ,GAAKD,EAAU,MAAM,EAAGC,CAAG,EAAID,EAC5CI,EAAKF,EAAc,OAAO,YAAY,IAAI,gBAAgBA,CAAW,CAAC,EAAI,CAAC,EACjF,MAAO,CACL,KAAAH,EACA,GAAAI,EACA,GAAAC,CACF,CACF,CACA,SAASC,EAAMC,EAAOC,EAAY,QAAS,CACzC,OAAI,OAAOD,GAAU,UAAY,CAACA,EAAM,WAAW,OAAOC,CAAS,GAAG,EAC7D,CACL,KAAM,UACN,GAAID,EACJ,GAAI,CAAC,CACP,EAEKV,GAASU,CAAK,CACvB,CAGA,IAAIE,GAA0B,MAAMC,EAAyB,CAC3D,aACA,aAAc,CACZ,KAAK,aAAe,CACtB,CACA,SAAU,CACR,KAAK,cACP,CACA,OAAQ,CACN,IAAMC,EAAQ,IAAID,GAClB,OAAAC,EAAM,aAAe,KAAK,aACnBA,CACT,CACF,EAGA,SAASC,GAAWC,EAAQ,CAC1B,GAAM,CAACC,EAAKC,EAAKC,CAAG,EAAIH,EACpBI,EAAY,EAChB,QAASC,EAAI,EAAGA,EAAIJ,EAAI,OAAQI,IAC9BD,GAAaA,GAAa,GAAKA,EAAYH,EAAI,WAAWI,CAAC,EAC3DD,GAAa,EAEf,QAASC,EAAI,EAAGA,EAAIH,EAAI,OAAQG,IAC9BD,GAAaA,GAAa,GAAKA,EAAYF,EAAI,WAAWG,CAAC,EAC3DD,GAAa,EAEf,QAASC,EAAI,EAAGA,EAAIF,EAAI,OAAQE,IAC9BD,GAAaA,GAAa,GAAKA,EAAYD,EAAI,WAAWE,CAAC,EAC3DD,GAAa,EAEf,OAAOA,EAAU,SAAS,CAC5B,CAGA,IAAIE,GAAQ,MAAMC,EAAO,CAEvB,eAEA,eAEA,YACA,aACA,YACA,WACA,SAEA,SACA,UACA,WACA,SACA,SACA,QACA,UACA,YAAYC,EAAS,CACnB,KAAK,eAAiB,CAAC,EACvB,KAAK,eAAiC,IAAI,IAC1C,KAAK,YAAc,IAAIC,GACvB,KAAK,aAA+B,IAAI,IACxC,KAAK,YAA8B,IAAI,IACvC,KAAK,WAA6B,IAAI,IACtC,KAAK,SAA2B,IAAI,IACpC,KAAK,SAA2B,IAAI,IACpC,KAAK,UAA4B,IAAI,IACrC,KAAK,WAA6B,IAAI,IACtC,KAAK,SAA2B,IAAI,IACpC,KAAK,SAA2B,IAAI,IACpC,KAAK,UAA4B,IAAI,IACrC,KAAK,IAAID,CAAO,EAChB,KAAK,QAAU,IAAIZ,EACrB,CAIA,OAAOY,EAAS,CACd,QAASnB,EAAM,EAAGA,EAAMmB,EAAQ,OAAQnB,IAAO,CAC7C,IAAMW,EAASQ,EAAQnB,CAAG,EACpBqB,EAAaX,GAAWC,CAAM,EAC9BW,EAAc,KAAK,YAAY,IAAID,CAAU,EACnD,GAAIC,IAAgB,OAClB,SAEF,KAAK,aAAa,OAAOD,CAAU,EACnC,KAAK,YAAY,OAAOA,CAAU,EAClC,IAAME,EAAW,KAAK,eAAe,IAAID,CAAW,EACpD,GAAIC,EAAU,CACZ,KAAK,WAAW,IAAIA,EAAS,aAAa,GAAG,OAAOD,CAAW,EAC/D,KAAK,SAAS,IAAIC,EAAS,WAAW,GAAG,OAAOD,CAAW,EAC3D,KAAK,UAAU,IAAIC,EAAS,QAAQ,GAAG,OAAOD,CAAW,EACzD,KAAK,WAAW,IAAIC,EAAS,aAAa,GAAG,OAAOD,CAAW,EAC/D,KAAK,SAAS,IAAIC,EAAS,WAAW,GAAG,OAAOD,CAAW,EAC3D,QAAWE,KAASD,EAAS,gBAC3B,KAAK,SAAS,IAAIC,CAAK,GAAG,OAAOF,CAAW,EAE9C,QAAWE,KAASD,EAAS,gBAC3B,KAAK,SAAS,IAAIC,CAAK,GAAG,OAAOF,CAAW,EAE9C,KAAK,eAAe,OAAOA,CAAW,CACxC,CACA,OAAO,KAAK,eAAeA,CAAW,CACxC,CACF,CAIA,WAAWH,EAAS,CAClB,OAAOA,EAAQ,OAAQR,GAAW,CAAC,KAAK,UAAUA,CAAM,CAAC,CAC3D,CAIA,UAAUA,EAAQ,CAChB,OAAO,KAAK,aAAa,IAAID,GAAWC,CAAM,CAAC,CACjD,CAIA,eAAeA,EAAQ,CACrB,IAAMc,EAAOf,GAAWC,CAAM,EAC9B,OAAO,KAAK,YAAY,IAAIc,CAAI,CAClC,CAIA,IAAIN,EAAS,CACX,QAASO,EAAM,EAAGA,EAAMP,EAAQ,OAAQO,IAAO,CAC7C,IAAMf,EAASQ,EAAQO,CAAG,EACpBC,EAAShB,EAAO,CAAC,EACjBiB,EAAWjB,EAAO,CAAC,EACnBkB,EAASlB,EAAO,CAAC,EACnBmB,EAAe,KAAK,UAAU,IAAIH,CAAM,EACvCG,IACHA,EAAe1B,EAAMuB,CAAM,EAC3B,KAAK,UAAU,IAAIA,EAAQG,CAAY,GAEzC,IAAIC,EAAe,KAAK,UAAU,IAAIF,CAAM,EACvCE,IACHA,EAAe3B,EAAMyB,CAAM,EAC3B,KAAK,UAAU,IAAIA,EAAQE,CAAY,GAEzC,IAAMC,EAAY,KAAK,YAAY,IAAIL,CAAM,EACvCM,EAAY,KAAK,YAAY,IAAIJ,CAAM,EACvCK,EAAgB,KAAK,YAAY,IAAIJ,EAAa,IAAI,EACtDK,EAAc,KAAK,YAAY,IAAIL,EAAa,EAAE,EAClDM,EAAgB,KAAK,YAAY,IAAIL,EAAa,IAAI,EACtDM,EAAc,KAAK,YAAY,IAAIN,EAAa,EAAE,EAClDN,GAAOf,GAAWC,CAAM,EAC9B,GAAI,KAAK,aAAa,IAAIc,EAAI,EAC5B,SAEF,KAAK,aAAa,IAAIA,EAAI,EAC1B,IAAMzB,EAAM,KAAK,eAAe,OAChC,KAAK,YAAY,IAAIyB,GAAMzB,CAAG,EAC9B,KAAK,eAAe,KAAK,CAACgC,EAAWJ,EAAUK,CAAS,CAAC,EACzD,IAAMK,GAAkB,CAAC,EACnBC,EAAkB,CAAC,EACrBC,EAAgB,KAAK,WAAW,IAAIN,CAAa,EAChDM,IACHA,EAAgC,IAAI,IACpC,KAAK,WAAW,IAAIN,EAAeM,CAAa,GAElDA,EAAc,IAAIxC,CAAG,EACrB,IAAIyC,EAAc,KAAK,SAAS,IAAIN,CAAW,EAC1CM,IACHA,EAA8B,IAAI,IAClC,KAAK,SAAS,IAAIN,EAAaM,CAAW,GAE5CA,EAAY,IAAIzC,CAAG,EACnB,OAAW,CAAC0C,EAAKC,CAAG,IAAK,OAAO,QAAQb,EAAa,EAAE,EAAG,CACxD,IAAMN,EAAQ,KAAK,YAAY,IAAI,GAAGkB,CAAG,IAAIC,CAAG,EAAE,EAClDL,GAAgB,KAAKd,CAAK,EAC1B,IAAIoB,GAAc,KAAK,SAAS,IAAIpB,CAAK,EACpCoB,KACHA,GAA8B,IAAI,IAClC,KAAK,SAAS,IAAIpB,EAAOoB,EAAW,GAEtCA,GAAY,IAAI5C,CAAG,CACrB,CACA,IAAI6C,EAAc,KAAK,UAAU,IAAIjB,CAAQ,EACxCiB,IACHA,EAA8B,IAAI,IAClC,KAAK,UAAU,IAAIjB,EAAUiB,CAAW,GAE1CA,EAAY,IAAI7C,CAAG,EACnB,IAAI8C,EAAgB,KAAK,WAAW,IAAIV,CAAa,EAChDU,IACHA,EAAgC,IAAI,IACpC,KAAK,WAAW,IAAIV,EAAeU,CAAa,GAElDA,EAAc,IAAI9C,CAAG,EACrB,IAAI+C,EAAc,KAAK,SAAS,IAAIV,CAAW,EAC1CU,IACHA,EAA8B,IAAI,IAClC,KAAK,SAAS,IAAIV,EAAaU,CAAW,GAE5CA,EAAY,IAAI/C,CAAG,EACnB,OAAW,CAAC0C,EAAKC,CAAG,IAAK,OAAO,QAAQZ,EAAa,EAAE,EAAG,CACxD,IAAMP,EAAQ,KAAK,YAAY,IAAI,GAAGkB,CAAG,IAAIC,CAAG,EAAE,EAClDJ,EAAgB,KAAKf,CAAK,EAC1B,IAAIwB,GAAc,KAAK,SAAS,IAAIxB,CAAK,EACpCwB,KACHA,GAA8B,IAAI,IAClC,KAAK,SAAS,IAAIxB,EAAOwB,EAAW,GAEtCA,GAAY,IAAIhD,CAAG,CACrB,CACA,KAAK,eAAe,IAAIA,EAAK,CAC3B,cAAAkC,EACA,YAAAC,EACA,gBAAAG,GACA,SAAAV,EACA,cAAAQ,EACA,YAAAC,EACA,gBAAAE,CACF,CAAC,CACH,CACA,OAAO,IACT,CAIA,IAAI,QAAS,CACX,OAAO,KAAK,aAAa,IAC3B,CAIA,IAAI,aAAc,CAChB,OAAO,KAAK,eAAe,MAC7B,CAIA,SAAU,CACR,OAAO,KAAK,eAAe,OAAQ5B,GAAWA,IAAW,MAAM,EAAE,IAAI,CAAC,CAACqB,EAAWJ,EAAUK,CAAS,IAAM,CACzG,KAAK,YAAY,SAASD,CAAS,EACnCJ,EACA,KAAK,YAAY,SAASK,CAAS,CACrC,CAAC,CACH,CAIA,UAAUgB,EAAO,CACf,GAAIA,EAAQ,GAAKA,GAAS,KAAK,eAAe,OAC5C,OAEF,IAAMC,EAAgB,KAAK,eAAeD,CAAK,EAC/C,GAAI,CAACC,EACH,OAEF,GAAM,CAAClB,EAAWJ,EAAUK,CAAS,EAAIiB,EACzC,MAAO,CACL,KAAK,YAAY,SAASlB,CAAS,EACnCJ,EACA,KAAK,YAAY,SAASK,CAAS,CACrC,CACF,CAIA,iBAAiBgB,EAAO,CACtB,GAAI,EAAAA,EAAQ,GAAKA,GAAS,KAAK,eAAe,QAG9C,OAAO,KAAK,eAAeA,CAAK,CAClC,CAIA,iBAAiBnD,EAAM,CACrB,IAAMqD,EAAU,KAAK,YAAY,SAASrD,CAAI,EAC9C,GAAIqD,IAAY,OAGhB,YAAK,QAAQ,QAAQ,EACd,KAAK,WAAW,IAAIA,CAAO,CACpC,CACA,eAAejD,EAAI,CACjB,IAAMkD,EAAQ,KAAK,YAAY,SAASlD,CAAE,EAC1C,GAAIkD,IAAU,OAGd,YAAK,QAAQ,QAAQ,EACd,KAAK,SAAS,IAAIA,CAAK,CAChC,CACA,eAAeV,EAAKC,EAAK,CACvB,IAAMnB,EAAQ,KAAK,YAAY,SAAS,GAAGkB,CAAG,IAAIC,CAAG,EAAE,EACvD,GAAInB,IAAU,OAGd,YAAK,QAAQ,QAAQ,EACd,KAAK,SAAS,IAAIA,CAAK,CAChC,CACA,eAAeI,EAAU,CACvB,YAAK,QAAQ,QAAQ,EACd,KAAK,UAAU,IAAIA,CAAQ,CACpC,CACA,iBAAiB9B,EAAM,CACrB,IAAMqD,EAAU,KAAK,YAAY,SAASrD,CAAI,EAC9C,GAAIqD,IAAY,OAGhB,YAAK,QAAQ,QAAQ,EACd,KAAK,WAAW,IAAIA,CAAO,CACpC,CACA,eAAejD,EAAI,CACjB,IAAMkD,EAAQ,KAAK,YAAY,SAASlD,CAAE,EAC1C,GAAIkD,IAAU,OAGd,YAAK,QAAQ,QAAQ,EACd,KAAK,SAAS,IAAIA,CAAK,CAChC,CACA,eAAeV,EAAKC,EAAK,CACvB,IAAMnB,EAAQ,KAAK,YAAY,SAAS,GAAGkB,CAAG,IAAIC,CAAG,EAAE,EACvD,GAAInB,IAAU,OAGd,YAAK,QAAQ,QAAQ,EACd,KAAK,SAAS,IAAIA,CAAK,CAChC,CAIA,kBAAmB,CACjB,IAAM6B,EAAsC,IAAI,IAChD,QAAW1C,KAAU,KAAK,eACpBA,IAAW,QACb0C,EAAoB,IAAI1C,EAAO,CAAC,CAAC,EAGrC,IAAM2C,EAA0B,IAAI,IACpC,QAAWtB,KAAaqB,EAAqB,CAC3C,IAAME,EAAY,KAAK,YAAY,SAASvB,CAAS,EACjDuB,IAAc,QAChBD,EAAQ,IAAIC,CAAS,CAEzB,CACA,OAAOD,CACT,CAIA,oBAAqB,CACnB,OAAO,IAAI,IAAI,KAAK,UAAU,KAAK,CAAC,CACtC,CAIA,kBAAmB,CACjB,IAAME,EAAsC,IAAI,IAChD,QAAW7C,KAAU,KAAK,eACpBA,IAAW,QACb6C,EAAoB,IAAI7C,EAAO,CAAC,CAAC,EAGrC,IAAM8C,EAA0B,IAAI,IACpC,QAAWxB,KAAauB,EAAqB,CAC3C,IAAME,EAAY,KAAK,YAAY,SAASzB,CAAS,EACjDyB,IAAc,QAChBD,EAAQ,IAAIC,CAAS,CAEzB,CACA,OAAOD,CACT,CAIA,OAAQ,CACN,IAAME,EAAW,IAAIzC,GAAO,CAAC,CAAC,EAC9ByC,EAAS,eAAiB,KAAK,eAAe,MAAM,EACpDA,EAAS,eAAiB,IAAI,IAAI,KAAK,cAAc,EACrDA,EAAS,YAAc,KAAK,YAAY,MAAM,EAC9CA,EAAS,aAAe,IAAI,IAAI,KAAK,YAAY,EACjDA,EAAS,YAAc,IAAI,IAAI,KAAK,WAAW,EAC/C,IAAMC,EAAYC,GAAa,CAC7B,IAAMC,EAAyB,IAAI,IACnC,OAAW,CAACpB,EAAKqB,CAAQ,IAAKF,EAAS,QAAQ,EAC7CC,EAAO,IAAIpB,EAAK,IAAI,IAAIqB,CAAQ,CAAC,EAEnC,OAAOD,CACT,EACME,EAAoBH,GAAa,CACrC,IAAMC,EAAyB,IAAI,IACnC,OAAW,CAACpB,EAAKqB,CAAQ,IAAKF,EAAS,QAAQ,EAC7CC,EAAO,IAAIpB,EAAK,IAAI,IAAIqB,CAAQ,CAAC,EAEnC,OAAOD,CACT,EACA,OAAAH,EAAS,WAAaC,EAAS,KAAK,UAAU,EAC9CD,EAAS,SAAWC,EAAS,KAAK,QAAQ,EAC1CD,EAAS,SAAWC,EAAS,KAAK,QAAQ,EAC1CD,EAAS,UAAYK,EAAiB,KAAK,SAAS,EACpDL,EAAS,WAAaC,EAAS,KAAK,UAAU,EAC9CD,EAAS,SAAWC,EAAS,KAAK,QAAQ,EAC1CD,EAAS,SAAWC,EAAS,KAAK,QAAQ,EAC1CD,EAAS,UAAY,IAAI,IAAI,KAAK,SAAS,EAC3CA,EAAS,QAAU,KAAK,QAAQ,MAAM,EAC/BA,CACT,CACF,EAGA,SAASM,GAAM5D,EAAO,CACpB,OAAOA,EAAM,WAAW,MAAM,CAChC,CACA,SAAS6D,GAAgBC,EAAQ,CAC/B,OAAI,OAAOA,GAAW,SACbF,GAAME,CAAM,EAAI,CAAC/D,EAAM+D,CAAM,CAAC,EAAI,CAAC,CACxC,KAAM,UACN,GAAIA,CACN,CAAC,EAEC,MAAM,QAAQA,CAAM,EACfA,EAAO,IAAKC,GACVH,GAAMG,CAAS,EAAIhE,EAAMgE,CAAS,EAAI,CAC3C,KAAM,UACN,GAAIA,CACN,CACD,EAEI,CAACD,CAAM,CAChB,CACA,SAASE,GAAcF,EAAQ,CAC7B,OAAO,OAAOA,GAAW,UAAY,MAAM,QAAQA,CAAM,EAAI,CAAE,SAAUA,CAAO,EAAIA,CACtF,CACA,SAASG,GAAYH,EAAQ,CAC3B,IAAMxC,EAAS,MAAM,QAAQwC,CAAM,EAAIA,EAAO,CAAC,EAAIA,EAAO,OACpDvC,EAAW,MAAM,QAAQuC,CAAM,EAAIA,EAAO,CAAC,EAAIA,EAAO,SACtDtC,EAAS,MAAM,QAAQsC,CAAM,EAAIA,EAAO,CAAC,EAAIA,EAAO,OACpDI,EAAM,CAAC,EACb,OAAI5C,IACF4C,EAAI,OAASL,GAAgBvC,CAAM,GAEjCC,IACF2C,EAAI,SAAWF,GAAczC,CAAQ,GAEnCC,IACF0C,EAAI,OAASL,GAAgBrC,CAAM,GAE9B0C,CACT,CAGA,IAAIC,GAAY,MAAMC,EAAW,CAC/B,MACA,YACA,YAAYtD,EAASuD,EAAc,CAAC,EAAG,CACrC,KAAK,MAAQ,IAAIzD,GAAME,CAAO,EAC9B,KAAK,YAAcuD,CACrB,CACA,OAAO,GAAGvD,EAAS,CACjB,OAAO,IAAIsD,GAAWtD,CAAO,CAC/B,CACA,OAAO,KAAKwD,EAAS,CACnB,IAAMxD,EAAU,CAAC,EACjB,QAAWyD,KAAOD,EAAS,CACzB,GAAM,CAAE,GAAAzE,EAAI,GAAG2E,CAAU,EAAID,EAC7B,GAAI,OAAO1E,GAAO,SAChB,MAAM,IAAI,MAAM,0CAA0C,EAE5D,OAAW,CAAC0B,EAAUC,CAAM,IAAK,OAAO,QAAQgD,CAAS,EACvD,GAAI,MAAM,QAAQhD,CAAM,EACtB,QAAWiD,KAAOjD,EAChBV,EAAQ,KAAK,CAACjB,EAAI0B,EAAUkD,CAAG,CAAC,OAGlC3D,EAAQ,KAAK,CAACjB,EAAI0B,EAAUC,CAAM,CAAC,CAGzC,CACA,OAAO,IAAI4C,GAAWtD,CAAO,CAC/B,CACA,gBAAgBA,EAAS,CACvB,IAAM4D,EAAW,CAAC,EAClB,OAAW,CAACpD,EAAQC,EAAUC,CAAM,IAAKV,EAAS,CAChD,IAAM6D,EAAY,KAAK,YAAYpD,CAAQ,EAC3C,GAAI,CAACoD,EACH,SAEF,GAAM,CAAE,KAAAlF,CAAK,EAAIM,EAAMuB,CAAM,EACvBsD,EAAMD,EAAUlF,EAAM8B,EAAUC,CAAM,EACxC,OAAOoD,GAAQ,UACjBF,EAAS,KAAKE,CAAG,CAErB,CACA,GAAIF,EAAS,OAAS,EACpB,MAAM,IAAI,MAAM;AAAA,IAClBA,EAAS,KAAK;AAAA,GAAM,CAAC,EAAE,CAEzB,CACA,IAAI5D,EAAS,CACX,KAAK,gBAAgBA,CAAO,EAC5B,KAAK,MAAM,IAAIA,CAAO,CACxB,CACA,OAAOA,EAAS,CACd,YAAK,MAAM,OAAOA,CAAO,EAClB,IACT,CACA,SAAU,CACR,OAAO,KAAK,MAAM,QAAQ,CAC5B,CACA,SAAU,CACR,OAAO,KAAK,MAAM,iBAAiB,CACrC,CACA,WAAY,CACV,OAAO,KAAK,MAAM,mBAAmB,CACvC,CACA,SAAU,CACR,OAAO,KAAK,MAAM,iBAAiB,CACrC,CACA,aAAc,CACZ,IAAM+D,EAAa,KAAK,QAAQ,EAChC,OAAOA,EAAW,OAAS,EAAIA,EAAW,CAAC,EAAI,MACjD,CACA,aAAc,CACZ,OAAO,KAAK,MAAM,UAAU,CAAC,IAAI,CAAC,CACpC,CACA,eAAgB,CACd,OAAO,KAAK,MAAM,UAAU,CAAC,IAAI,CAAC,CACpC,CACA,aAAc,CACZ,OAAO,KAAK,MAAM,UAAU,CAAC,IAAI,CAAC,CACpC,CACA,YAAYC,EAAW,GAAO,CAC5B,IAAIC,EACER,EAAM,CAAC,EACb,OAAW,CAACjD,EAAQ0D,EAAcxD,CAAM,IAAK,KAAK,MAAM,QAAQ,EAC1DuD,IAAY,SACdA,EAAUzD,EACViD,EAAI,GAAKjD,GAEPyD,IAAYzD,IAGX,OAAO,UAAU,eAAe,KAAKiD,EAAKS,CAAY,EAEhD,MAAM,QAAQT,EAAIS,CAAY,CAAC,EACnCT,EAAIS,CAAY,EAAE,SAASxD,CAAM,GACpC+C,EAAIS,CAAY,EAAE,KAAKxD,CAAM,EAG/B+C,EAAIS,CAAY,EAAIT,EAAIS,CAAY,IAAMxD,EAAS+C,EAAIS,CAAY,EAAI,CAACT,EAAIS,CAAY,EAAGxD,CAAM,EANjG+C,EAAIS,CAAY,EAAIF,EAAW,CAACtD,CAAM,EAAIA,GAS9C,OAAO,OAAO,KAAK+C,CAAG,EAAE,OAAS,EAAIA,EAAM,MAC7C,CACA,QAAQO,EAAW,GAAO,CACxB,IAAMG,EAAuB,IAAI,IACjC,OAAW,CAAC3D,EAAQ0D,EAAcxD,CAAM,IAAK,KAAK,MAAM,QAAQ,EAAG,CACjE,IAAI+C,EAAMU,EAAK,IAAI3D,CAAM,EACpBiD,IACHA,EAAM,CAAE,GAAIjD,CAAO,EACnB2D,EAAK,IAAI3D,EAAQiD,CAAG,GAEtB,IAAMW,EAAcX,EAAIS,CAAY,EAC/BE,EAEM,MAAM,QAAQA,CAAW,EAC7BA,EAAY,SAAS1D,CAAM,GAC9B0D,EAAY,KAAK1D,CAAM,EAGzB+C,EAAIS,CAAY,EAAIE,IAAgB1D,EAAS0D,EAAc,CAACA,EAAa1D,CAAM,EAN/E+C,EAAIS,CAAY,EAAIF,EAAW,CAACtD,CAAM,EAAIA,CAQ9C,CACA,OAAO,MAAM,KAAKyD,EAAK,OAAO,CAAC,CACjC,CACA,IAAIE,EAAK,CACP,OAAO,IAAIf,GAAW,KAAK,QAAQ,EAAE,IAAIe,CAAG,CAAC,CAC/C,CACA,QAAQA,EAAK,CACX,OAAO,IAAIf,GAAW,KAAK,QAAQ,EAAE,QAAQe,CAAG,CAAC,CACnD,CACA,mBAAmBrE,EAAS,CAC1B,IAAMsE,EAAuB,IAAI,IAC3BC,EAAS,CAAC,EAChB,QAAW/E,KAAUQ,EAAS,CAC5B,IAAME,EAAaX,GAAWC,CAAM,EAC/B8E,EAAK,IAAIpE,CAAU,IACtBoE,EAAK,IAAIpE,CAAU,EACnBqE,EAAO,KAAK/E,CAAM,EAEtB,CACA,OAAO+E,CACT,CACA,MAAMC,EAAO,CACX,YAAK,IAAIA,EAAM,QAAQ,CAAC,EACjB,IACT,CACA,OAAQ,CACN,OAAO,IAAIlB,GAAW,KAAK,QAAQ,EAAG,KAAK,WAAW,CACxD,CACA,UAAU7E,EAAKgG,EAAO,CAAE,GAAI,EAAM,EAAG,CACnC,IAAMV,EAAa,KAAK,QAAQ,EAC1BW,EAAkB,CAAC,EACzB,GAAID,EAAK,GAAI,CACX,GAAM,CAAE,KAAA9F,EAAM,GAAAI,CAAG,EAAIE,EAAMR,CAAG,EAC9B,QAAWe,KAAUuE,EAAY,CAC/B,IAAMY,EAAe1F,EAAMO,EAAO,CAAC,CAAC,EAChCmF,EAAa,OAAShG,GAAQgG,EAAa,KAAO5F,GACpD2F,EAAgB,KAAKlF,CAAM,CAE/B,CACF,KACE,SAAWA,KAAUuE,EACfvE,EAAO,CAAC,IAAMf,GAChBiG,EAAgB,KAAKlF,CAAM,EAIjC,GAAIkF,EAAgB,SAAW,EAAG,OAClC,IAAMjB,EAAM,CAAE,GAAIiB,EAAgB,CAAC,EAAE,CAAC,CAAE,EACxC,OAAW,CAAC,CAAEjE,EAAUC,CAAM,IAAKgE,EAC5B,OAAO,UAAU,eAAe,KAAKjB,EAAKhD,CAAQ,EAE5C,MAAM,QAAQgD,EAAIhD,CAAQ,CAAC,EAC/BgD,EAAIhD,CAAQ,EAAE,SAASC,CAAM,GAChC+C,EAAIhD,CAAQ,EAAE,KAAKC,CAAM,EAG3B+C,EAAIhD,CAAQ,EAAI,CAACgD,EAAIhD,CAAQ,EAAGC,CAAM,EANtC+C,EAAIhD,CAAQ,EAAIC,EASpB,OAAO+C,CACT,CACA,WAAWmB,EAAMH,EAAO,CAAE,GAAI,EAAM,EAAG,CACrC,IAAMI,EAAU,CAAC,EACjB,QAAWpG,KAAOmG,EAAM,CACtB,IAAME,EAAQ,KAAK,UAAUrG,EAAKgG,CAAI,EAClCK,IAAU,QACZD,EAAQ,KAAKC,CAAK,CAEtB,CACA,OAAOD,CACT,CACA,WAAWE,EAAQtG,EAAKgG,EAAO,CAAE,GAAI,EAAM,EAAG,CAC5C,IAAMK,EAAQ,KAAK,UAAUrG,EAAKgG,CAAI,EACtC,OAAOK,EAAQC,EAAOD,CAAK,EAAI,MACjC,CACA,YAAYC,EAAQH,EAAMH,EAAO,CAAE,GAAI,EAAM,EAAG,CAC9C,IAAMI,EAAU,CAAC,EACjB,QAAWpG,KAAOmG,EAAM,CACtB,IAAMd,EAAM,KAAK,WAAWiB,EAAQtG,EAAKgG,CAAI,EACzCX,GACFe,EAAQ,KAAKf,CAAG,CAEpB,CACA,OAAOe,CACT,CACA,cAAcG,EAAMC,EAAM,CACxB,IAAMV,EAAyB,IAAI,IACnC,QAAWW,KAAQF,EACbC,EAAK,IAAIC,CAAI,GACfX,EAAO,IAAIW,CAAI,EAGnB,OAAOX,CACT,CACA,OAAOY,EAAQ,CACb,IAAMC,EAASjC,GAAYgC,CAAM,EACjC,GAAI,CAACC,EAAO,QAAU,CAACA,EAAO,UAAY,CAACA,EAAO,OAChD,OAAO,IAAI9B,GAAW,KAAK,QAAQ,EAAG,KAAK,WAAW,EAExD,IAAI+B,EAAmB,KACvB,GAAID,EAAO,SAAU,CACnB,IAAME,EAAgB,MAAM,QAAQF,EAAO,SAAS,QAAQ,EAAIA,EAAO,SAAS,SAAW,CAACA,EAAO,SAAS,QAAQ,EACpH,GAAIE,EAAc,OAAS,EAAG,CAC5BD,EAAmC,IAAI,IACvC,QAAWE,KAAWD,EAAe,CACnC,IAAME,EAAM,KAAK,MAAM,eAAeD,CAAO,EAC7C,GAAIC,EACF,QAAW3G,KAAO2G,EAChBH,EAAiB,IAAIxG,CAAG,CAG9B,CACF,CACF,CACA,GAAIuG,EAAO,OAAQ,CACjB,IAAMK,EAAY,KAAK,+BACrBL,EAAO,OACP,QACF,EACA,GAAIC,IAAqB,KACvBA,EAAmBI,MACd,CACL,IAAMC,EAA+B,IAAI,IACzC,QAAW7G,KAAOwG,EACZI,EAAU,IAAI5G,CAAG,GACnB6G,EAAa,IAAI7G,CAAG,EAGxBwG,EAAmBK,CACrB,CACF,CACA,GAAIN,EAAO,OAAQ,CACjB,IAAMO,EAAY,KAAK,+BACrBP,EAAO,OACP,QACF,EACA,GAAIC,IAAqB,KACvBA,EAAmBM,MACd,CACL,IAAMD,EAA+B,IAAI,IACzC,QAAW7G,KAAOwG,EACZM,EAAU,IAAI9G,CAAG,GACnB6G,EAAa,IAAI7G,CAAG,EAGxBwG,EAAmBK,CACrB,CACF,CACA,GAAIL,IAAqB,MAAQA,EAAiB,OAAS,EACzD,OAAO,IAAI/B,GAAW,CAAC,EAAG,KAAK,WAAW,EAE5C,IAAMoB,EAAkB,CAAC,EACzB,QAAWkB,KAAaP,EAAkB,CACxC,IAAM7F,EAAS,KAAK,MAAM,UAAUoG,CAAS,EAC7C,GAAI,CAACpG,EAAQ,SACb,GAAM,CAACgB,EAAQC,EAAUC,CAAM,EAAIlB,EACnC,GAAI4F,EAAO,OAAQ,CACjB,IAAIS,EAAgB,GACpB,QAAWC,KAAeV,EAAO,OAC/B,GAAI,EAAAU,EAAY,WAAa,CAACA,EAAY,UAAUtF,CAAM,GAG1D,CAAAqF,EAAgB,GAChB,MAEF,GAAI,CAACA,EAAe,QACtB,CACA,GAAI,EAAAT,EAAO,UAAU,WAAa,CAACA,EAAO,SAAS,UAAU3E,CAAQ,GAGrE,IAAI2E,EAAO,OAAQ,CACjB,IAAIW,EAAgB,GACpB,QAAWC,KAAeZ,EAAO,OAC/B,GAAI,EAAAY,EAAY,WAAa,CAACA,EAAY,UAAUtF,CAAM,GAG1D,CAAAqF,EAAgB,GAChB,MAEF,GAAI,CAACA,EAAe,QACtB,CACArB,EAAgB,KAAKlF,CAAM,EAC7B,CACA,OAAO,IAAI8D,GAAWoB,EAAiB,KAAK,WAAW,CACzD,CACA,+BAA+BuB,EAASC,EAAU,CAChD,IAAM3B,EAAyB,IAAI,IACnC,QAAW4B,KAASF,EAAS,CAE3B,GAAI,EAD4BE,EAAM,OAAS,QAAUA,EAAM,KAAO,QAAUA,EAAM,KAAO,QAAU,OAAO,KAAKA,EAAM,EAAE,EAAE,OAAS,GACxG,CAC5B,QAAStH,EAAM,EAAGA,EAAM,KAAK,MAAM,YAAaA,IAC9C0F,EAAO,IAAI1F,CAAG,EAEhB,QACF,CACA,IAAMuH,EAAe,CAAC,EACtB,GAAID,EAAM,OAAS,OAAQ,CACzB,IAAME,EAAUH,IAAa,SAAW,KAAK,MAAM,iBAAiBC,EAAM,IAAI,EAAI,KAAK,MAAM,iBAAiBA,EAAM,IAAI,EACxH,GAAIE,EACFD,EAAa,KAAKC,CAAO,MAEzB,SAEJ,CACA,GAAIF,EAAM,KAAO,OAAQ,CACvB,IAAMX,EAAM,MAAM,QAAQW,EAAM,EAAE,EAAIA,EAAM,GAAK,CAACA,EAAM,EAAE,EACpDG,EAA0B,IAAI,IACpC,QAAWC,KAAUf,EAAK,CACxB,IAAMgB,EAAQN,IAAa,SAAW,KAAK,MAAM,eAAeK,CAAM,EAAI,KAAK,MAAM,eAAeA,CAAM,EAC1G,GAAIC,EACF,QAAW3H,KAAO2H,EAChBF,EAAQ,IAAIzH,CAAG,CAGrB,CACA,GAAIyH,EAAQ,KAAO,EACjBF,EAAa,KAAKE,CAAO,MAEzB,SAEJ,CACA,GAAIH,EAAM,KAAO,OAAQ,CACvB,IAAMM,EAAS,OAAO,KAAKN,EAAM,EAAE,EACnC,GAAIM,EAAO,OAAS,EAAG,CACrB,IAAMC,EAAS,CAAC,EAChB,QAAWnF,KAAOkF,EAAQ,CACxB,IAAME,EAAQT,IAAa,SAAW,KAAK,MAAM,eAAe3E,EAAK4E,EAAM,GAAG5E,CAAG,CAAC,EAAI,KAAK,MAAM,eAAeA,EAAK4E,EAAM,GAAG5E,CAAG,CAAC,EAClI,GAAIoF,EACFD,EAAO,KAAKC,CAAK,MACZ,CACLD,EAAO,OAAS,EAChB,KACF,CACF,CACA,GAAIA,EAAO,OAAS,EAAG,CACrB,IAAIE,EAAiBF,EAAO,CAAC,EAC7B,QAAS7H,EAAM,EAAGA,EAAM6H,EAAO,SAC7BE,EAAiB,KAAK,cAAcA,EAAgBF,EAAO7H,CAAG,CAAC,EAC3D+H,EAAe,OAAS,GAFS/H,IAErC,CAEFuH,EAAa,KAAKQ,CAAc,CAClC,KACE,SAEJ,CACF,CACA,GAAIR,EAAa,SAAW,EAC1B,SAEF,IAAIS,EAAcT,EAAa,CAAC,EAChC,QAASvH,EAAM,EAAGA,EAAMuH,EAAa,SACnCS,EAAc,KAAK,cAAcA,EAAaT,EAAavH,CAAG,CAAC,EAC3DgI,EAAY,OAAS,GAFkBhI,IAE3C,CAEF,QAAWA,KAAOgI,EAChBtC,EAAO,IAAI1F,CAAG,CAElB,CACA,OAAO0F,CACT,CACA,cAAcY,EAAQ,CACpB,IAAMC,EAASjC,GAAYgC,CAAM,EACjC,GAAI,CAACC,EAAO,QAAU,CAACA,EAAO,UAAY,CAACA,EAAO,OAChD,OAAO,KAAK,QAAQ,EAEtB,IAAIC,EAAmB,KACvB,GAAID,EAAO,SAAU,CACnB,IAAME,EAAgB,MAAM,QAAQF,EAAO,SAAS,QAAQ,EAAIA,EAAO,SAAS,SAAW,CAACA,EAAO,SAAS,QAAQ,EACpH,GAAIE,EAAc,OAAS,EAAG,CAC5BD,EAAmC,IAAI,IACvC,QAAWE,KAAWD,EAAe,CACnC,IAAME,EAAM,KAAK,MAAM,eAAeD,CAAO,EAC7C,GAAIC,EACF,QAAW3G,KAAO2G,EAChBH,EAAiB,IAAIxG,CAAG,CAG9B,CACF,CACF,CACA,GAAIuG,EAAO,OAAQ,CACjB,IAAMK,EAAY,KAAK,+BACrBL,EAAO,OACP,QACF,EACA,GAAIC,IAAqB,KACvBA,EAAmBI,MACd,CACL,IAAMC,EAA+B,IAAI,IACzC,QAAW7G,KAAOwG,EACZI,EAAU,IAAI5G,CAAG,GACnB6G,EAAa,IAAI7G,CAAG,EAGxBwG,EAAmBK,CACrB,CACF,CACA,GAAIN,EAAO,OAAQ,CACjB,IAAMO,EAAY,KAAK,+BACrBP,EAAO,OACP,QACF,EACA,GAAIC,IAAqB,KACvBA,EAAmBM,MACd,CACL,IAAMD,EAA+B,IAAI,IACzC,QAAW7G,KAAOwG,EACZM,EAAU,IAAI9G,CAAG,GACnB6G,EAAa,IAAI7G,CAAG,EAGxBwG,EAAmBK,CACrB,CACF,CACA,GAAIL,IAAqB,MAAQA,EAAiB,OAAS,EACzD,MAAO,CAAC,EAEV,IAAMX,EAAkB,CAAC,EACzB,QAAWkB,KAAaP,EAAkB,CACxC,IAAM7F,EAAS,KAAK,MAAM,UAAUoG,CAAS,EAC7C,GAAI,CAACpG,EAAQ,SACb,GAAM,CAACgB,EAAQC,EAAUC,CAAM,EAAIlB,EACnC,GAAI4F,EAAO,OAAQ,CACjB,IAAIS,EAAgB,GACpB,QAAWC,KAAeV,EAAO,OAC/B,GAAI,EAAAU,EAAY,WAAa,CAACA,EAAY,UAAUtF,CAAM,GAG1D,CAAAqF,EAAgB,GAChB,MAEF,GAAI,CAACA,EAAe,QACtB,CACA,GAAI,EAAAT,EAAO,UAAU,WAAa,CAACA,EAAO,SAAS,UAAU3E,CAAQ,GAGrE,IAAI2E,EAAO,OAAQ,CACjB,IAAIW,EAAgB,GACpB,QAAWC,KAAeZ,EAAO,OAC/B,GAAI,EAAAY,EAAY,WAAa,CAACA,EAAY,UAAUtF,CAAM,GAG1D,CAAAqF,EAAgB,GAChB,MAEF,GAAI,CAACA,EAAe,QACtB,CACArB,EAAgB,KAAKlF,CAAM,EAC7B,CACA,OAAOkF,CACT,CAKA,cAAc1B,EAAQqB,EAAK,CACzB,IAAMK,EAAkB,KAAK,cAAc1B,CAAM,EAC3C8D,EAAqBpC,EAAgB,QAAQL,CAAG,EAChD0C,EAAiC,IAAI,IACrCC,EAAoC,IAAI,IACxCC,EAAoC,IAAI,IAC9C,QAAWzH,KAAUkF,EACnBqC,EAAe,IAAIxH,GAAWC,CAAM,CAAC,EAEvC,QAAWA,KAAUsH,EAAoB,CACvC,IAAMxG,EAAOf,GAAWC,CAAM,EAC9BwH,EAAkB,IAAI1G,CAAI,EAC1B2G,EAAkB,IAAI3G,EAAMd,CAAM,CACpC,CACA,IAAM0H,EAAkB,CAAC,EACzB,QAAW1H,KAAUkF,EAAiB,CACpC,IAAMpE,EAAOf,GAAWC,CAAM,EACzBwH,EAAkB,IAAI1G,CAAI,GAC7B4G,EAAgB,KAAK1H,CAAM,CAE/B,CACA,IAAM2H,EAAe,CAAC,EACtB,QAAW7G,KAAQ0G,EACZD,EAAe,IAAIzG,CAAI,GAC1B6G,EAAa,KAAKF,EAAkB,IAAI3G,CAAI,CAAC,EAGjD,OAAI4G,EAAgB,OAAS,GAC3B,KAAK,OAAOA,CAAe,EAEzBC,EAAa,OAAS,GACxB,KAAK,IAAIA,CAAY,EAEhB,IACT,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,MAAM,MACpB,CACF,EC7lCA,eAAuBC,GAAeC,EAAuC,CAC3E,IAAMC,EAAS,IAAIC,GACbC,EAAM,MAAM,MAAMH,CAAG,EAC3B,GAAI,CAACG,EAAI,KACP,MAAM,IAAI,MAAM,kBAAkB,EAGpC,IAAMC,EAAU,IAAI,kBACdC,EAASF,EAAI,KAAK,YAAYC,CAAO,EAAE,UAAU,EACnDE,EAAS,GAIPC,EAAyB,CAAC,EAEhC,OAAa,CACX,GAAM,CAAE,MAAAC,EAAO,KAAAC,CAAK,EAAI,MAAMJ,EAAO,KAAK,EAC1C,GAAII,EACF,MAEFH,GAAUE,EACV,IAAME,EAAQJ,EAAO,MAAM;AAAA,CAAI,EAC/BA,EAASI,EAAM,IAAI,GAAK,GACxB,QAAWC,KAAQD,EAAO,CACxB,IAAME,EAASX,EAAO,MAAMU,CAAI,EAC5BC,IAAW,QACbL,EAAa,KAAKK,CAAM,EAGtBL,EAAa,QAAU,MACzB,KAAM,CAAC,GAAGA,CAAY,EACtBA,EAAa,OAAS,EAE1B,CACF,CAGA,GAAID,EAAO,OAAS,EAAG,CACrB,IAAMM,EAASX,EAAO,MAAMK,CAAM,EAC9BM,IAAW,QACbL,EAAa,KAAKK,CAAM,CAE5B,CAGIL,EAAa,OAAS,IACxB,KAAM,CAAC,GAAGA,CAAY,EAE1B,CAEA,IAAIM,GAAwB,KAW5B,eAAsBC,GACpBd,EACAe,EAA8B,CAAC,EAC/BC,EAA2CC,GAAM,CAACA,CAAC,EAC/B,CACfJ,KACHA,GAAM,IAAIK,GAAU,CAAC,EAAGH,CAAM,GAGhC,cAAiBI,KAAWpB,GAAeC,CAAG,EAC5C,QAAWY,KAAUO,EACnBN,GAAI,IAAIG,EAAUJ,CAAM,CAAC,EAI7B,OAAOC,EACT,CCrFO,IAAMO,EAAN,KAAqB,CAC1B,OAAO,SAAW,UAClB,OAAO,QAAU,UACjB,OAAO,SAAW,WAClB,OAAO,UAAY,YACnB,OAAO,SAAW,WAClB,OAAO,QAAU,UACjB,OAAO,KAAO,OACd,OAAO,OAAS,SAChB,OAAO,KAAO,OACd,OAAO,cAAgB,eACvB,OAAO,UAAY,YACnB,OAAO,WAAa,YACpB,OAAO,OAAS,SAChB,OAAO,OAAS,SAChB,OAAO,aAAe,cACtB,OAAO,MAAQ,QACf,OAAO,cAAgB,eACvB,OAAO,IAAM,MACb,OAAO,MAAQ,QACf,OAAO,OAAS,SAChB,OAAO,cAAgB,eACvB,OAAO,QAAU,SACjB,OAAO,oBAAsB,mBAC7B,OAAO,WAAa,YACpB,OAAO,WAAa,YACpB,OAAO,gBAAkB,gBACzB,OAAO,eAAiB,eACxB,OAAO,eAAiB,eACxB,OAAO,mBAAqB,mBAC5B,OAAO,KAAO,OACd,OAAO,SAAW,WAClB,OAAO,GAAK,KACZ,OAAO,MAAQ,QAEf,OAAO,MAAQ,QAEf,OAAO,eAAiB,gBACxB,OAAO,KAAO,MAChB,EAEaC,EAAN,KAAiB,CACtB,OAAO,MAAQ,QACf,OAAO,QAAU,UACjB,OAAO,KAAO,OACd,OAAO,OAAS,SAChB,OAAO,QAAU,UACjB,OAAO,UAAY,YACnB,OAAO,OAAS,SAChB,OAAO,OAAS,SAChB,OAAO,MAAQ,QACf,OAAO,MAAQ,QACf,OAAO,MAAQ,QACf,OAAO,OAAS,SAChB,OAAO,KAAO,OACd,OAAO,cAAgB,eACzB,EAMaC,GAAmB,IAAI,IAAI,CACtCD,EAAW,QACXA,EAAW,OACXA,EAAW,KACb,CAAC,EAMYE,GAAU,IAAI,IAAoB,CAC7C,CAAC,UAAW,WAAW,CACzB,CAAC,EAUM,IAAMC,GAAgB,IAAI,IAAI,CACnCC,EAAe,cACfA,EAAe,QACfA,EAAe,oBACfA,EAAe,WACfA,EAAe,WACfA,EAAe,gBACfA,EAAe,eACfA,EAAe,eACfA,EAAe,kBACjB,CAAC,EAMYC,GAAqB,CAChC,CAACD,EAAe,GAAIA,EAAe,QAAQ,EAC3C,CAACA,EAAe,eAAgBA,EAAe,IAAI,CACrD,EAKaE,GAAS,CACpB,EAAK,aACL,UAAa,qCACb,OAAU,oCACV,KAAQ,gCACV,EAGaC,GAAc,sBAGdC,GAAW,mCAOjB,IAAMC,GAA0B,CACrC,SAAU,YACV,SAAU,kBACV,eAAgB,YAChB,MAAO,kBACP,OAAQ,YACR,MAAO,YACP,OAAQ,YACR,OAAQ,SACR,UAAW,SACX,UAAW,YACX,KAAM,eACN,KAAM,kBACN,OAAQ,eACR,OAAQ,kBACR,SAAU,kBACV,OAAQ,YACR,OAAQ,SACR,OAAQ,kBACR,KAAM,kBACN,SAAU,YACV,OAAQ,YACR,SAAU,kBACV,UAAW,kBACX,OAAQ,kBACR,UAAW,YACX,SAAU,qBACV,OAAQ,YACR,OAAQ,YACR,KAAM,YACN,KAAM,kBACN,WAAY,YACZ,OAAQ,YACR,MAAO,kBACP,OAAQ,8BACR,KAAM,kBACN,MAAO,YACP,OAAQ,kBACR,QAAS,YACT,QAAS,YACT,UAAW,YACX,SAAU,YACV,IAAK,WACP,EAKaC,GAAgB,IAAI,IAAI,CACnC,SACA,SACA,WACA,SACA,iBACA,MACF,CAAC,EAKYC,GAAe,IAAI,IAAI,CAClC,WACA,cACA,WACA,UACF,CAAC,EAEYC,GAAgB,IAAI,IAAI,CACnCC,EAAW,KACXA,EAAW,OACXA,EAAW,QACXA,EAAW,UACXA,EAAW,KACXA,EAAW,MACb,CAAC,ECxLM,SAASC,GAAcC,EAA0B,CACtD,GAAM,CAACC,EAAKC,EAAKC,CAAG,EAAIH,EAMxB,OAJsB,MAAM,KAAKI,EAAa,EAAE,KAAMC,GAC7CH,IAAQG,CAChB,EAMM,CAAC,CACNJ,EACAC,EACA,GAAGI,EAAQ,GAAGH,CAAG,EACnB,CAAC,EAPQ,CAACH,CAAM,CAQlB,CAKO,SAASO,GAAWP,EAA0B,CACnD,GAAM,CAACC,EAAKC,EAAKC,CAAG,EAAIH,EAExB,MAAO,CAAC,CACN,OAAOC,GAAQ,UAAYA,EAAI,WAAW,IAAI,EAC1C,aAAUA,EAAI,MAAM,CAAC,CAAC,GACtBA,EACJC,EACA,OAAOC,GAAQ,UAAYA,EAAI,WAAW,IAAI,EAC1C,aAAUA,EAAI,MAAM,CAAC,CAAC,GACtBA,CACN,CAAC,CACH,CAKO,SAASK,GAAQC,EAAgB,CACtC,IAAMC,EAAQD,EAAI,OAAO,CACvB,SAAUE,EAAe,UAC3B,CAAC,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAACV,EAAKW,EAAGT,CAAG,IAAM,CACtC,IAAMU,EAAO,IAAI,KAAKV,CAAG,EAEzB,GAAI,MAAMU,EAAK,QAAQ,CAAC,EACtB,MAAO,CAAC,EAGV,IAAMC,EAAOD,EAAK,eAAe,EAAE,SAAS,EAE5C,MAAO,CAAC,CAACZ,EAAKU,EAAe,KAAMG,CAAI,CAAC,CAC1C,CAAC,EAEDL,EAAI,IAAIC,CAAK,CACf,CAOO,SAASK,GAAoBN,EAAgB,CAClD,IAAMO,EAAoB,CAAC,EAE3B,OAAW,CAACC,EAAIC,CAAI,IAAKC,GAAoB,CAC3C,IAAMC,EAAUX,EAAI,OAAO,CACzB,SAAUQ,CACZ,CAAC,EAAE,QAAQ,EAEX,OAAW,CAAChB,EAAKW,EAAGT,CAAG,IAAKiB,EAC1BJ,EAAQ,KAAK,CAACb,EAAKe,EAAMjB,CAAG,CAAC,CAEjC,CAEAQ,EAAI,IAAIO,CAAO,CACjB,CAEA,IAAMK,GAAc,IAAI,IAKjB,SAASC,GAAYC,EAAgCC,EAAe,CACzE,IAAMC,EAASJ,GAAY,IAAIG,CAAK,EACpC,GAAIC,EACF,OAAOA,EAGT,GAAI,OAAOD,GAAU,UAAY,CAACE,GAAY,KAAKF,CAAK,EACtD,OAAOA,EAET,IAAMG,EAAQH,EAAM,MAAME,EAAW,EAErC,GAAI,CAACC,EACH,OAAOH,EAGT,IAAMI,EAASD,EAAM,CAAC,EAChBE,EAAKF,EAAM,CAAC,EAEZG,EAASP,EAAOK,CAAM,EAAI,GAAGL,EAAOK,CAAM,CAAC,GAAGC,CAAE,GAAKL,EAE3D,OAAAH,GAAY,IAAIG,EAAOM,CAAM,EACtBA,CACT,CAMO,SAASC,GACd/B,EACA,CACA,GAAM,CAACC,EAAKC,EAAKC,CAAG,EAAIH,EAExB,MAAO,CACL,CACEsB,GAAYU,GAAQ/B,CAAG,EACvBC,EACAoB,GAAYU,GAAQ7B,CAAG,CACzB,CACF,CACF,CAKO,SAAS8B,GACdxB,EACA,CAEA,IAAMyB,EAAY,CAChB,MAAO,IAAI,IAKX,UAAW,IAAI,GACjB,EAEMd,EAAUX,EAAI,OAAO,CACzB,SAAUE,EAAe,EAC3B,CAAC,EAAE,QAAQ,EAELwB,EAAQD,EAAU,MACxB,OAAW,CAACjC,EAAK,CAAEE,CAAG,IAAKiB,EAAS,CAClC,IAAIgB,EAAUD,EAAM,IAAIlC,CAAG,EACtBmC,IACHA,EAAU,CAAE,GAAInC,EAAK,QAAS,IAAI,GAAM,EACxCkC,EAAM,IAAIlC,EAAKmC,CAAO,GAGxB,IAAIC,EAAUF,EAAM,IAAIhC,CAAG,EACtBkC,IACHA,EAAU,CAAE,GAAIlC,EAAK,QAAS,IAAI,GAAM,EACxCgC,EAAM,IAAIhC,EAAKkC,CAAO,GAGxBH,EAAU,UAAU,IAAI/B,CAAG,EAC3BiC,GAAS,QAAQ,IAAIjC,CAAG,CAC1B,CAEA,OAAO+B,CACT,CAGO,IAAMI,GAA+B,CAC1C,CAAC,6BAA2B3B,EAAe,KAAM,QAAG,EACpD,CAAC,sCAAoCA,EAAe,KAAM,cAAI,EAC9D,CAAC,+CAA6CA,EAAe,KAAM,oBAAK,EACxE,CACE,wDACAA,EAAe,KACf,0BACF,EACA,CACE,iEACAA,EAAe,KACf,gCACF,CACF,EAWO,SAAS4B,GACdvC,EACU,CACV,IAAMwC,EAAmB,CACvBjC,GACAwB,GACAhC,EACF,EAEI0C,EAA0B,CAACzC,CAAM,EACrC,QAAW0C,KAAMF,EAAkB,CACjC,IAAIG,EAAqB,CAAC,EAE1B,QAAW3C,KAAUyC,EACnBE,EAAS,KAAK,GAAID,EAAG1C,CAAM,CAAc,EAG3CyC,EAAgB,CAAC,GAAGE,CAAQ,EAC5BA,EAAW,CAAC,CACd,CAEA,OAAOF,CACT,CAMO,SAASG,GAAanC,EAAgB,CAC3CD,GAAQC,CAAG,EACXM,GAAoBN,CAAG,EACvBoC,GAAmBpC,CAAG,CACxB,CAOO,SAASoC,GAAmBpC,EAAgB,CACjD,IAAMyB,EAAYD,GAAmBxB,CAAG,EAIxC,SAASqC,EAAQC,EAAgBC,EAAuB,CACtD,IAAMhC,EAAoB,CAAC,EAErBiC,EAAOf,EAAU,MAAM,IAAIc,CAAG,EAGpC,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,gCAAgCD,CAAG,EAAE,EAIvD,GAAID,EAAK,OAAS,EAChB,MAAM,IAAI,MAAM,iBAAiB,KAAK,UAAUA,CAAI,CAAC,EAAE,EAGzD,GAAIE,EAAK,QAAQ,OAAS,EAAG,CAK3B,IAAMC,EAAY,CAAC,GAAGH,EAAMC,CAAG,EAE/B,QAASG,EAAM,EAAGA,EAAMD,EAAU,OAAS,EAAGC,IAC5C,QAASC,EAAMD,EAAKC,EAAMF,EAAU,OAAQE,IAAO,CACjD,IAAMnD,EAAMiD,EAAUC,CAAG,EACnBhD,EAAM+C,EAAUE,CAAG,EAErBnD,IAAQE,IAIZa,EAAQ,KAAK,CAACf,EAAKU,EAAe,GAAIR,CAAG,CAAC,EAC1Ca,EAAQ,KAAK,CAACb,EAAKQ,EAAe,SAAUV,CAAG,CAAC,EAClD,CAEJ,KACE,SAAWoD,KAAUJ,EAAK,QACxBjC,EAAQ,KAAK,GAAG8B,EAAQ,CAAC,GAAGC,EAAMC,CAAG,EAAGK,CAAM,CAAC,EAInD,OAAOrC,CACT,CAEA,IAAMA,EAAoB,CAAC,EAI3B,QAAWsC,KAAUpB,EAAU,MAAM,KAAK,EACpCA,EAAU,UAAU,IAAIoB,CAAM,GAIlCtC,EAAQ,KAAK,GAAG8B,EAAQ,CAAC,EAAGQ,CAAM,CAAC,EAGrC7C,EAAI,IAAIO,CAAO,CACjB,CCvTO,SAASuC,GAAgBC,EAAmB,CACjD,IAAMC,EAAoB,CAAC,EAE3B,QAAWC,KAASF,EAClBC,EAAQ,KACN;AAAA,EACE,KAAK,UAAUC,EAAM,KAAM,KAAM,CAAC,CACpC;AAAA,IAAOA,EAAM,OAAO,EACtB,EAIF,QAAQ,KAAKD,EAAQ,KAAK;AAAA,CAAI,CAAC,EAC/B,QAAQ,MAAM,CAChB,CCfA,IAAIE,GAoBJ,SAASC,GAAgBC,EAAU,CAClC,MAAO,CACN,KAAMA,GAAU,MAAQC,IAAS,KACjC,QAASD,GAAU,QACnB,WAAYA,GAAU,YAAcC,IAAS,WAC7C,eAAgBD,GAAU,gBAAkBC,IAAS,cACtD,CACD,CAUA,IAAIC,GAmBJ,SAASC,GAAiBC,EAAM,CAC/B,OAAOC,IAAS,IAAID,CAAI,CACzB,CAYA,IAAIE,GAmBJ,SAASC,GAAiBC,EAAM,CAC/B,OAAOC,IAAS,IAAID,CAAI,CACzB,CAYA,IAAIE,GAsBJ,SAASC,GAAmBC,EAAWC,EAAM,CAC5C,OAAOC,IAAS,IAAIF,CAAS,GAAG,IAAIC,CAAI,CACzC,CAuBA,SAASE,GAAWC,EAAO,CAC1B,IAAMC,EAAO,OAAOD,EACpB,OAAIC,IAAS,SAAiB,IAAID,CAAK,IACnCC,IAAS,UAAYA,IAAS,UAAYA,IAAS,UAAkB,GAAGD,CAAK,GAC7EC,IAAS,UAAYA,IAAS,YAAoBD,GAAS,OAAO,eAAeA,CAAK,GAAG,aAAa,OAAS,OAC5GC,CACR,CAeA,SAASC,GAAUC,EAASC,EAAOC,EAASC,EAAUC,EAAO,CAC5D,IAAMP,EAAQO,GAAS,UAAWA,EAAQA,EAAM,MAAQF,EAAQ,MAC1DG,EAAWD,GAAO,UAAYJ,EAAQ,SAAW,KACjDM,EAAWF,GAAO,UAA4BR,GAAWC,CAAK,EAC9DU,EAAQ,CACb,KAAMP,EAAQ,KACd,KAAMA,EAAQ,KACd,MAAAH,EACA,SAAAQ,EACA,SAAAC,EACA,QAAS,WAAWL,CAAK,KAAKI,EAAW,YAAYA,CAAQ,SAAW,GAAG,WAAWC,CAAQ,GAC9F,YAAaN,EAAQ,YACrB,KAAMI,GAAO,KACb,OAAQA,GAAO,OACf,KAAMD,EAAS,KACf,WAAYA,EAAS,WACrB,eAAgBA,EAAS,cAC1B,EACMK,EAAWR,EAAQ,OAAS,SAC5BS,EAAYL,GAAO,SAAWJ,EAAQ,SAA2BU,GAAmBV,EAAQ,UAAWO,EAAM,IAAI,IAAMC,EAA2BG,GAAiBJ,EAAM,IAAI,EAAI,OAASJ,EAAS,SAA2BS,GAAiBL,EAAM,IAAI,EAC3PE,IAAc,SAAQF,EAAM,QAAU,OAAOE,GAAc,WAAaA,EAAUF,CAAK,EAAIE,GAC3FD,IAAUN,EAAQ,MAAQ,IAC1BA,EAAQ,OAAQA,EAAQ,OAAO,KAAKK,CAAK,EACxCL,EAAQ,OAAS,CAACK,CAAK,CAC7B,CAgFA,SAASM,GAAkBC,EAAS,CACnC,MAAO,CACN,QAAS,EACT,OAAQ,UACR,SAASC,EAAS,CACjB,OAAOD,EAAQ,MAAM,EAAE,CAAE,MAAOC,CAAQ,EAAmBC,GAAgB,CAAC,CAC7E,CACD,CACD,CAgGA,SAASC,GAAaC,EAAUC,EAAW,CAC1C,IAAMC,EAAO,CAAC,GAAG,IAAI,IAAIF,CAAQ,CAAC,EAClC,OAAIE,EAAK,OAAS,EAAU,IAAIA,EAAK,KAAK,IAAID,CAAS,GAAG,CAAC,IACpDC,EAAK,CAAC,GAAK,OACnB,CAk+BA,SAASC,GAAQC,EAAW,CAC3B,MAAO,CACN,KAAM,aACN,KAAM,UACN,UAAWD,GACX,MAAO,GACP,QAAS,KACT,YAAa,OAAO,UACpB,QAASC,EACT,OAAOC,EAASC,EAAU,CACzB,OAAID,EAAQ,OAAS,CAAC,KAAK,YAAYA,EAAQ,KAAK,GAAGE,GAAU,KAAM,UAAWF,EAASC,CAAQ,EAC5FD,CACR,CACD,CACD,CAmiDA,SAASG,GAAUC,EAAW,CAC7B,MAAO,CACN,KAAM,iBACN,KAAM,YACN,UAAWD,GACX,MAAO,GACP,UAAAC,EACA,OAAOC,EAAS,CACf,OAAAA,EAAQ,MAAQ,KAAK,UAAUA,EAAQ,KAAK,EACrCA,CACR,CACD,CACD,CA+GA,SAASC,GAAIC,EAAW,CACvB,MAAO,CACN,KAAM,aACN,KAAM,MACN,UAAWD,GACX,MAAO,GACP,QAAS,KACT,YAAYE,EAAO,CAClB,GAAI,CACH,WAAI,IAAIA,CAAK,EACN,EACR,MAAQ,CACP,MAAO,EACR,CACD,EACA,QAASD,EACT,OAAOE,EAASC,EAAU,CACzB,OAAID,EAAQ,OAAS,CAAC,KAAK,YAAYA,EAAQ,KAAK,GAAGE,GAAU,KAAM,MAAOF,EAASC,CAAQ,EACxFD,CACR,CACD,CACD,CAsIA,SAASG,GAAYC,EAAQC,EAASC,EAAU,CAC/C,OAAO,OAAOF,EAAO,UAAa,WAAaA,EAAO,SAASC,EAASC,CAAQ,EAAIF,EAAO,QAC5F,CA4KA,SAASG,GAAWC,EAAQC,EAASC,EAAU,CAC9C,OAAO,OAAOF,EAAO,SAAY,WAAaA,EAAO,QAAQC,EAASC,CAAQ,EAAIF,EAAO,OAC1F,CAkNA,SAASG,IAAM,CACd,MAAO,CACN,KAAM,SACN,KAAM,MACN,UAAWA,GACX,QAAS,MACT,MAAO,GACP,GAAI,aAAc,CACjB,OAAuBC,GAAkB,IAAI,CAC9C,EACA,OAAOC,EAAS,CACf,OAAAA,EAAQ,MAAQ,GACTA,CACR,CACD,CACD,CAKA,SAASC,GAAMC,EAAMC,EAAW,CAC/B,MAAO,CACN,KAAM,SACN,KAAM,QACN,UAAWF,GACX,QAAS,QACT,MAAO,GACP,KAAAC,EACA,QAASC,EACT,GAAI,aAAc,CACjB,OAAuBJ,GAAkB,IAAI,CAC9C,EACA,OAAOC,EAASI,EAAU,CACzB,IAAMC,EAAQL,EAAQ,MACtB,GAAI,MAAM,QAAQK,CAAK,EAAG,CACzBL,EAAQ,MAAQ,GAChBA,EAAQ,MAAQ,CAAC,EACjB,QAASM,EAAM,EAAGA,EAAMD,EAAM,OAAQC,IAAO,CAC5C,IAAMC,EAAUF,EAAMC,CAAG,EACnBE,EAAc,KAAK,KAAK,MAAM,EAAE,CAAE,MAAOD,CAAQ,EAAGH,CAAQ,EAClE,GAAII,EAAY,OAAQ,CACvB,IAAMC,EAAW,CAChB,KAAM,QACN,OAAQ,QACR,MAAAJ,EACA,IAAAC,EACA,MAAOC,CACR,EACA,QAAWG,KAASF,EAAY,OAC3BE,EAAM,KAAMA,EAAM,KAAK,QAAQD,CAAQ,EACtCC,EAAM,KAAO,CAACD,CAAQ,EAC3BT,EAAQ,QAAQ,KAAKU,CAAK,EAG3B,GADKV,EAAQ,SAAQA,EAAQ,OAASQ,EAAY,QAC9CJ,EAAS,WAAY,CACxBJ,EAAQ,MAAQ,GAChB,KACD,CACD,CACKQ,EAAY,QAAOR,EAAQ,MAAQ,IACxCA,EAAQ,MAAM,KAAKQ,EAAY,KAAK,CACrC,CACD,MAAOG,GAAU,KAAM,OAAQX,EAASI,CAAQ,EAChD,OAAOJ,CACR,CACD,CACD,CAovCA,SAASY,GAAOC,EAAW,CAC1B,MAAO,CACN,KAAM,SACN,KAAM,SACN,UAAWD,GACX,QAAS,SACT,MAAO,GACP,QAASC,EACT,GAAI,aAAc,CACjB,OAAuBC,GAAkB,IAAI,CAC9C,EACA,OAAOC,EAASC,EAAU,CACzB,OAAI,OAAOD,EAAQ,OAAU,UAAY,CAAC,MAAMA,EAAQ,KAAK,EAAGA,EAAQ,MAAQ,GAC3EE,GAAU,KAAM,OAAQF,EAASC,CAAQ,EACvCD,CACR,CACD,CACD,CAKA,SAASG,GAAOC,EAAWN,EAAW,CACrC,MAAO,CACN,KAAM,SACN,KAAM,SACN,UAAWK,GACX,QAAS,SACT,MAAO,GACP,QAASC,EACT,QAASN,EACT,GAAI,aAAc,CACjB,OAAuBC,GAAkB,IAAI,CAC9C,EACA,OAAOC,EAASC,EAAU,CACzB,IAAMI,EAAQL,EAAQ,MACtB,GAAIK,GAAS,OAAOA,GAAU,SAAU,CACvCL,EAAQ,MAAQ,GAChBA,EAAQ,MAAQ,CAAC,EACjB,QAAWM,KAAO,KAAK,QAAS,CAC/B,IAAMC,EAAc,KAAK,QAAQD,CAAG,EACpC,GAAIA,KAAOD,IAAUE,EAAY,OAAS,kBAAoBA,EAAY,OAAS,YAAcA,EAAY,OAAS,YAAcA,EAAY,UAAY,OAAQ,CACnK,IAAMC,EAAUF,KAAOD,EAAQA,EAAMC,CAAG,EAAoBG,GAAWF,CAAW,EAC5EG,EAAeH,EAAY,MAAM,EAAE,CAAE,MAAOC,CAAQ,EAAGP,CAAQ,EACrE,GAAIS,EAAa,OAAQ,CACxB,IAAMC,EAAW,CAChB,KAAM,SACN,OAAQ,QACR,MAAAN,EACA,IAAAC,EACA,MAAOE,CACR,EACA,QAAWI,KAASF,EAAa,OAC5BE,EAAM,KAAMA,EAAM,KAAK,QAAQD,CAAQ,EACtCC,EAAM,KAAO,CAACD,CAAQ,EAC3BX,EAAQ,QAAQ,KAAKY,CAAK,EAG3B,GADKZ,EAAQ,SAAQA,EAAQ,OAASU,EAAa,QAC/CT,EAAS,WAAY,CACxBD,EAAQ,MAAQ,GAChB,KACD,CACD,CACKU,EAAa,QAAOV,EAAQ,MAAQ,IACzCA,EAAQ,MAAMM,CAAG,EAAII,EAAa,KACnC,SAAWH,EAAY,WAAa,OAAQP,EAAQ,MAAMM,CAAG,EAAoBO,GAAYN,CAAW,UAC/FA,EAAY,OAAS,kBAAoBA,EAAY,OAAS,YAAcA,EAAY,OAAS,YACzGL,GAAU,KAAM,MAAOF,EAASC,EAAU,CACzC,MAAO,OACP,SAAU,IAAIK,CAAG,IACjB,KAAM,CAAC,CACN,KAAM,SACN,OAAQ,MACR,MAAAD,EACA,IAAAC,EACA,MAAOD,EAAMC,CAAG,CACjB,CAAC,CACF,CAAC,EACGL,EAAS,YAAY,KAE3B,CACD,MAAOC,GAAU,KAAM,OAAQF,EAASC,CAAQ,EAChD,OAAOD,CACR,CACD,CACD,CAgSA,SAASc,GAASC,EAASC,EAAU,CACpC,MAAO,CACN,KAAM,SACN,KAAM,WACN,UAAWF,GACX,QAAS,IAAIC,EAAQ,OAAO,gBAC5B,MAAO,GACP,QAAAA,EACA,QAASC,EACT,GAAI,aAAc,CACjB,OAAuBC,GAAkB,IAAI,CAC9C,EACA,OAAOC,EAASC,EAAU,CACzB,OAAID,EAAQ,QAAU,SACjB,KAAK,UAAY,SAAQA,EAAQ,MAAwBE,GAAW,KAAMF,EAASC,CAAQ,GAC3FD,EAAQ,QAAU,SACrBA,EAAQ,MAAQ,GACTA,GAGF,KAAK,QAAQ,MAAM,EAAEA,EAASC,CAAQ,CAC9C,CACD,CACD,CAynBA,SAASE,GAAOC,EAAW,CAC1B,MAAO,CACN,KAAM,SACN,KAAM,SACN,UAAWD,GACX,QAAS,SACT,MAAO,GACP,QAASC,EACT,GAAI,aAAc,CACjB,OAAuBC,GAAkB,IAAI,CAC9C,EACA,OAAOC,EAASC,EAAU,CACzB,OAAI,OAAOD,EAAQ,OAAU,SAAUA,EAAQ,MAAQ,GAClDE,GAAU,KAAM,OAAQF,EAASC,CAAQ,EACvCD,CACR,CACD,CACD,CAkYA,SAASG,GAAWC,EAAU,CAC7B,IAAIC,EACJ,GAAID,EAAU,QAAWE,KAAWF,EAAcC,EAAQA,EAAO,KAAK,GAAGC,EAAQ,MAAM,EAClFD,EAASC,EAAQ,OACtB,OAAOD,CACR,CAKA,SAASE,GAAMC,EAASC,EAAW,CAClC,MAAO,CACN,KAAM,SACN,KAAM,QACN,UAAWF,GACX,QAAyBG,GAAaF,EAAQ,IAAKG,GAAWA,EAAO,OAAO,EAAG,GAAG,EAClF,MAAO,GACP,QAAAH,EACA,QAASC,EACT,GAAI,aAAc,CACjB,OAAuBG,GAAkB,IAAI,CAC9C,EACA,OAAON,EAASO,EAAU,CACzB,IAAIC,EACAC,EACAC,EACJ,QAAWC,KAAU,KAAK,QAAS,CAClC,IAAMC,EAAgBD,EAAO,MAAM,EAAE,CAAE,MAAOX,EAAQ,KAAM,EAAGO,CAAQ,EACvE,GAAIK,EAAc,MAAO,GAAIA,EAAc,OAAYH,EAAeA,EAAc,KAAKG,CAAa,EACjGH,EAAgB,CAACG,CAAa,MAC9B,CACJJ,EAAeI,EACf,KACD,MACSF,EAAiBA,EAAgB,KAAKE,CAAa,EACvDF,EAAkB,CAACE,CAAa,CACtC,CACA,GAAIJ,EAAc,OAAOA,EACzB,GAAIC,EAAe,CAClB,GAAIA,EAAc,SAAW,EAAG,OAAOA,EAAc,CAAC,EACtDI,GAAU,KAAM,OAAQb,EAASO,EAAU,CAAE,OAAwBV,GAAWY,CAAa,CAAE,CAAC,EAChGT,EAAQ,MAAQ,EACjB,KAAO,IAAIU,GAAiB,SAAW,EAAG,OAAOA,EAAgB,CAAC,EAC7DG,GAAU,KAAM,OAAQb,EAASO,EAAU,CAAE,OAAwBV,GAAWa,CAAe,CAAE,CAAC,EACvG,OAAOV,CACR,CACD,CACD,CAqZA,SAASc,MAAQC,EAAQ,CACxB,MAAO,CACN,GAAGA,EAAO,CAAC,EACX,KAAMA,EACN,GAAI,aAAc,CACjB,OAAuBC,GAAkB,IAAI,CAC9C,EACA,OAAOC,EAASC,EAAU,CACzB,QAAWC,KAAQJ,EAAQ,GAAII,EAAK,OAAS,WAAY,CACxD,GAAIF,EAAQ,SAAWE,EAAK,OAAS,UAAYA,EAAK,OAAS,kBAAmB,CACjFF,EAAQ,MAAQ,GAChB,KACD,EACI,CAACA,EAAQ,QAAU,CAACC,EAAS,YAAc,CAACA,EAAS,kBAAgBD,EAAUE,EAAK,MAAM,EAAEF,EAASC,CAAQ,EAClH,CACA,OAAOD,CACR,CACD,CACD,CAwEA,SAASG,GAAUC,EAAQC,EAAOC,EAAU,CAC3C,IAAMC,EAAUH,EAAO,MAAM,EAAE,CAAE,MAAOC,CAAM,EAAmBG,GAAgBF,CAAQ,CAAC,EAC1F,MAAO,CACN,MAAOC,EAAQ,MACf,QAAS,CAACA,EAAQ,OAClB,OAAQA,EAAQ,MAChB,OAAQA,EAAQ,MACjB,CACD,CC/xNA,IAAAE,GAAc,OCAd,IAAAC,GAAc,OCIP,SAASC,GAAYC,EAAiC,CAC3D,OAAIA,IAAU,OACL,CAAC,EAGH,MAAM,QAAQA,CAAK,EAAIA,EAAQ,CAACA,CAAK,CAC9C,CAOO,SAASC,EAAOD,EAA2C,CAChE,OAAO,MAAM,QAAQA,CAAK,EAAIA,EAAM,CAAC,EAAIA,CAC3C,CCJO,SAASE,GAAWC,EAAoB,CAC7C,IAAMC,EAAUC,EAAIF,EAAM,QAAQ,EAC5B,CAAE,GAAIG,CAAU,EAAIC,EAAMH,CAAO,EAEvC,OACE,OAAO,UAAU,eAAe,KAAKI,GAAyBF,CAAS,EAEhEE,GACLF,CACF,EAGK,WACT,CAKO,SAASG,GAAkBC,EAA4B,CAC5D,GAAM,CAAE,GAAIJ,CAAU,EAAIC,EAAMG,CAAU,EAE1C,OACE,OAAO,UAAU,eAAe,KAAKF,GAAyBF,CAAS,EAEhEE,GACLF,CACF,EAGK,WACT,CAOO,SAASK,GAAaR,EAAoB,CAE/C,OADaE,EAAIF,EAAM,IAAI,CAE7B,CAKA,SAASS,IAAoB,CAC3B,MAAO,WACT,CAOA,SAASC,GAAYV,EAAsB,CACzC,GAAM,CAAE,GAAAW,CAAG,EAAIP,EAAMJ,EAAM,EAAE,EAE7B,OAAIY,GAAc,IAAID,CAAE,EACf,YACEE,GAAa,IAAIF,CAAE,EACrB,YAGF,WACT,CAGO,SAASG,GAAWC,EAAaC,EAAWhB,EAAsB,CACvE,GAAM,CAAE,KAAAiB,CAAK,EAAIb,EAAMW,CAAG,EAE1B,OAAQE,EAAM,CACZ,KAAKC,EAAW,MACd,OAAOnB,GAAWC,CAAK,EACzB,KAAKkB,EAAW,QACd,OAAOV,GAAaR,CAAK,EAC3B,KAAKkB,EAAW,KACd,OAAOT,GAAU,EACnB,KAAKS,EAAW,OACd,OAAOR,GAAYV,CAAK,EAC1B,KAAKkB,EAAW,cACd,OAAOZ,GAAkBS,CAAG,EAC9B,QACE,MAAO,EACX,CACF,CFrFO,SAASI,IAAY,CAC1B,MAAO,CACL,KAAKC,EAAgC,CACnC,GAAM,CAAE,IAAAC,EAAK,MAAAC,CAAM,EAAIF,EAAM,MACvB,CAAE,KAAAG,EAAM,GAAAC,CAAG,EAAIC,EAAMJ,CAAG,EAE1BK,EAAOF,EACX,GAAI,OAAO,UAAU,eAAe,KAAKF,EAAO,MAAM,EAAG,CACvD,IAAMK,EAAYC,EAAKN,EAAsC,IAAI,EAC7DK,IACFD,EAAOC,EAEX,CAEA,IAAME,EAAQC,GAAWT,EAAKK,EAAMJ,CAAK,EAEzC,SAAO,GAAAS,SAAE,IAAK,CACZ,KAAMV,EACN,QAASW,EAAS,UAAUT,CAAI,IAAIC,CAAE,EAAE,EACxC,MAAO,CAAC,aAAc,GAAGD,CAAI,OAAO,EAAE,KAAK,GAAG,CAChD,EAAG,GAAGM,CAAK,IAAKH,CAAI,EAAE,CACxB,CACF,CACF,CD1BO,SAASO,GACdC,EACAC,EAC0B,CAC1B,GAAM,CAAE,GAAAC,EAAI,KAAAC,CAAK,EAAIC,EAAMH,CAAG,EAE9B,OAAOD,EAAI,OAAO,CAChB,OAAQ,CAAE,GAAAE,EAAI,KAAAC,CAAK,CACrB,CAAC,EAAE,YAAY,CACjB,CAKO,SAASE,GACdC,EACAN,EACAE,EACe,CACf,IAAMK,EAAQR,GAAUC,EAAKE,CAAE,EAC/B,GAAKK,EAIL,OAAOD,EAAON,EAAKO,CAAK,CAC1B,CAQO,SAASC,GACdR,EACAS,EACgB,CAChB,IAAMC,EAAyB,CAAC,EAEhC,QAAWT,KAAOQ,EAAM,CACtB,IAAMF,EAAQR,GAAUC,EAAKC,CAAG,EAC5BM,GACFG,EAAO,KAAKH,CAAK,CAErB,CAEA,OAAOG,CACT,CAKO,IAAMC,GAAmB,SAC9BL,EACAN,EACAS,EACK,CACL,GAAI,OAAOH,GAAW,WACpB,MAAM,IAAI,MAAM,2BAA2B,EAG7C,IAAMM,EAAoB,CAAC,EAE3B,QAAWX,KAAOQ,EAAM,CACtB,IAAMF,EAAQR,GAAUC,EAAKC,CAAG,EAChC,GAAI,CAACM,EACH,SAGF,IAAMM,EAASP,EAAON,EAAKO,CAAK,EAC5BM,GACFD,EAAa,KAAKC,CAAM,CAE5B,CAEA,OAAOD,CACT,EAKO,SAASE,GACdd,EACAG,EACgB,CAKhB,OAJeH,EAAI,OAAO,CACxB,OAAQ,CAAE,KAAAG,CAAK,CACjB,CAAC,EAAE,QAAQ,EAGR,OAAQI,GACA,OAAO,UAAU,eAAe,KAAKA,EAAO,MAAM,CAC1D,EACA,KAAK,CAACQ,EAAQC,IAAW,CACxB,IAAMC,EAAYF,EAAO,KACnBG,EAAaF,EAAO,KAEpBG,EAAQC,EAAIH,CAAS,EACrBI,EAASD,EAAIF,CAAU,EAE7B,OAAOC,EAAM,cAAcE,CAAM,CACnC,CAAC,CACL,CAGO,SAASC,GACdtB,EACAS,EAC+B,CAC/B,OAAOA,EAAK,QAASR,GAAQ,CAC3B,GAAI,CAACA,EACH,MAAO,CAAC,EAEV,IAAMM,EAAQR,GAAUC,EAAKC,CAAG,EAEhC,MAAI,CAACM,GAAS,CAACA,EAAM,KACZ,CAAC,EAGH,IAAC,GAAAgB,SAAEC,GAAW,CAAE,IAAAvB,EAAK,MAAAM,CAAM,CAAC,CAAC,CACtC,CAAC,CACH,CIrHO,SAASkB,GAIdC,EACAC,EAIwD,CACxD,MAAO,CAACC,EAAcC,IAAyB,CAC7C,IAAMC,EAASC,GAAUL,EAAQG,CAAM,EAEvC,GAAI,CAACC,EAAO,QAAS,CACnBE,GAAgBF,EAAO,MAAM,EAC7B,MACF,CAEA,MAAO,CAAE,GAAGA,EAAO,OAAe,KAAAH,CAAK,CAGzC,CACF,CAKO,SAASM,GACdC,EACW,CACX,MAAO,CAACC,EAAgBC,IAAwB,CAC9C,GAAM,CAAE,KAAAT,CAAK,EAAIU,EAAMC,EAAIF,EAAM,EAAE,CAAE,EAE/BG,EAASL,EAAYP,CAAI,GAAKO,EAAY,QAChD,GAAKK,EAIL,OAAOA,EAAOJ,EAAKC,CAAK,CAC1B,CACF,CAKO,SAASI,GAAWD,EAAmB,CAC5C,MAAO,CAACJ,EAAgBM,IACfC,GAAgBH,EAAQJ,EAAKM,CAAE,CAE1C,CAKO,SAASE,GAAYJ,EAAmB,CAC7C,GAAI,OAAOA,GAAW,WACpB,MAAM,IAAI,MAAM,2BAA2B,EAG7C,MAAO,CAACJ,EAAgBS,IACfC,GAAiBN,EAAQJ,EAAKS,CAAI,CAE7C,CAKO,SAASE,GAAWP,EAAmB,CAC5C,MAAO,CACL,IAAKC,GAAQD,CAAM,EACnB,KAAMI,GAASJ,CAAM,CACvB,CACF,CCpEA,IAAMQ,EAAI,CACR,OAAAC,GACA,MAAAC,GACA,OAAAC,GACA,SAAAC,GACA,MAAAC,GACA,IAAAC,GACA,KAAAC,GACA,IAAAC,GACA,QAAAC,GACA,OAAAC,GACA,UAAAC,EACF,EAEaC,GAAcZ,EAAE,OAAO,CAClC,KAAMA,EAAE,OAAO,EACf,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC3B,QAASA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,UAAU,MAAM,CAAC,EAC/C,QAASA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,UAAU,MAAM,CAAC,EAC/C,aAAcA,EAAE,OAAO,EAEvB,OAAQA,EAAE,OAAO,EACjB,YAAaA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,UAAU,MAAM,CAAC,EACnD,YAAaA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,UAAU,MAAM,CAAC,EACnD,QAASA,EAAE,MAAM,CAACA,EAAE,OAAO,EAAGA,EAAE,MAAMA,EAAE,OAAO,CAAC,CAAC,CAAC,EAClD,YAAaA,EAAE,SAASA,EAAE,OAAO,CAAC,EAGlC,UAAWA,EAAE,OAAO,EACpB,eAAgBA,EAAE,OAAO,CAC3B,CAAC,EAEYa,GAAgBb,EAAE,OAAO,CACpC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC3B,KAAMA,EAAE,OAAO,EACf,SAAUA,EAAE,SAASA,EAAE,MAAM,CAACA,EAAE,OAAO,EAAGA,EAAE,MAAMA,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,EAC/D,GAAIA,EAAE,SAASA,EAAE,MAAM,CAACA,EAAE,OAAO,EAAGA,EAAE,MAAMA,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAC3D,CAAC,EAEYc,GAAed,EAAE,OAAO,CACnC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC3B,UAAWA,EAAE,SAASA,EAAE,OAAO,CAAC,EAChC,SAAUA,EAAE,SAASA,EAAE,OAAO,CAAC,CACjC,CAAC,EAEYe,GAAcf,EAAE,OAAO,CAClC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,OAAO,EACf,SAAUA,EAAE,SAASA,EAAE,MAAM,CAACA,EAAE,OAAO,EAAGA,EAAE,MAAMA,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,EAC/D,GAAIA,EAAE,SAASA,EAAE,MAAM,CAACA,EAAE,OAAO,EAAGA,EAAE,MAAMA,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,EACzD,UAAWA,EAAE,SAASA,EAAE,OAAO,CAAC,EAChC,UAAWA,EAAE,SAASA,EAAE,OAAO,CAAC,EAChC,SAAUA,EAAE,SAASA,EAAE,OAAO,CAAC,CACjC,CAAC,EAEYgB,GAAchB,EAAE,OAAO,CAClC,QAASA,EAAE,OAAO,EAClB,QAASA,EAAE,SAASA,EAAE,MAAM,CAACA,EAAE,OAAO,EAAGA,EAAE,MAAMA,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,EAC9D,UAAWA,EAAE,OAAO,EACpB,QAASA,EAAE,SAASA,EAAE,MAAM,CAACA,EAAE,OAAO,EAAGA,EAAE,MAAMA,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,EAC9D,aAAcA,EAAE,SAASA,EAAE,OAAO,CAAC,EACnC,MAAOA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC5B,YAAaA,EAAE,SAASA,EAAE,OAAO,CAAC,EAClC,UAAWA,EAAE,OAAO,EACpB,OAAQA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC7B,GAAIA,EAAE,OAAO,EACb,IAAKA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC1B,SAAUA,EAAE,SAASA,EAAE,MAAM,CAACA,EAAE,OAAO,EAAGA,EAAE,MAAMA,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,EAC/D,iBAAkBA,EAAE,OAAO,EAC3B,MAAOA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC5B,cAAeA,EAAE,OAAO,EACxB,OAAQA,EAAE,OAAO,EACjB,OAAQA,EAAE,OAAO,EACjB,MAAOA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC5B,aAAcA,EAAE,OAAO,EACvB,MAAOA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC5B,YAAaA,EAAE,SAASA,EAAE,OAAO,CAAC,EAClC,QAASA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC9B,gBAAiBA,EAAE,OAAO,CAC5B,CAAC,EAEYiB,GAAejB,EAAE,OAAO,CACnC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,OAAO,EACf,UAAWA,EAAE,SAASA,EAAE,OAAO,CAAC,CAClC,CAAC,EAEYkB,GAAgBlB,EAAE,OAAO,CACpC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC3B,UAAWA,EAAE,SAASA,EAAE,OAAO,CAAC,CAClC,CAAC,EAEYmB,GAAanB,EAAE,OAAO,CACjC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC3B,UAAWA,EAAE,SAASA,EAAE,OAAO,CAAC,CAClC,CAAC,EAEYoB,GAAkBpB,EAAE,OAAO,CACtC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC3B,UAAWA,EAAE,SAASA,EAAE,OAAO,CAAC,CAClC,CAAC,EAEYqB,GAAerB,EAAE,OAAO,CACnC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC3B,UAAWA,EAAE,SAASA,EAAE,OAAO,CAAC,CAClC,CAAC,EAEYsB,GAAgBtB,EAAE,OAAO,CACpC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC3B,UAAWA,EAAE,SAASA,EAAE,OAAO,CAAC,CAClC,CAAC,EAEYuB,GAAavB,EAAE,OAAO,CACjC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,SAASA,EAAE,OAAO,CAAC,EAC3B,UAAWA,EAAE,SAASA,EAAE,OAAO,CAAC,EAChC,aAAcA,EAAE,SAASA,EAAE,MAAM,CAACA,EAAE,OAAO,EAAGA,EAAE,MAAMA,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CACrE,CAAC,EAEYwB,GAAcxB,EAAE,OAAO,CAClC,GAAIA,EAAE,OAAO,EACb,QAASA,EAAE,OAAO,EAClB,YAAaA,EAAE,OAAO,EACtB,UAAWA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,IAAI,CAAC,EACrC,cAAeA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,IAAI,CAAC,EACzC,aAAcA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,IAAI,CAAC,EACxC,aAAcA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,IAAI,CAAC,EACxC,iBAAkBA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,IAAI,CAAC,CAC9C,CAAC,EAEYyB,GAAczB,EAAE,OAAO,CAClC,OAAQA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,QAAQ,CAAC,EACtC,OAAQA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,QAAQ,CAAC,EACtC,OAAQA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,QAAQ,CAAC,EACtC,MAAOA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,QAAQ,CAAC,EACrC,UAAWA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,QAAQ,CAAC,EACzC,aAAcA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,QAAQ,CAAC,EAC5C,eAAgBA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,QAAQ,CAAC,EAC9C,kBAAmBA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,QAAQ,CAAC,EACjD,gBAAiBA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,QAAQ,CAAC,EAC/C,aAAcA,EAAE,KAAKA,EAAE,OAAO,EAAGA,EAAE,QAAQ,CAAC,CAC9C,CAAC,EAEY0B,GAAgB1B,EAAE,OAAO,CACpC,GAAIA,EAAE,OAAO,EACb,KAAMA,EAAE,SAASA,EAAE,OAAO,CAAC,CAC7B,CAAC,EC/IM,IAAM2B,GAAeC,GAAYC,GAAe,SAAS,EACnDC,GAAeF,GAAYG,GAAe,SAAS,EACnDC,GAAcJ,GAAYK,GAAc,QAAQ,EAChDC,GAAaN,GAAYO,GAAa,OAAO,EAC7CC,GAAYR,GAAYS,GAAY,MAAM,EAC1CC,GAAcV,GAAYW,GAAc,QAAQ,EAChDC,GAAeZ,GAAYa,GAAe,SAAS,EACnDC,GAAiBd,GAAYe,GAAiB,WAAW,EACzDC,GAAchB,GAAYiB,GAAc,QAAQ,EAChDC,GAAYlB,GAAYmB,GAAY,MAAM,EAC1CC,GAAapB,GAAYqB,GAAa,OAAO,EAC7CC,GAAatB,GAAYuB,GAAa,OAAO,EAC7CC,GAAaxB,GAAYyB,GAAa,OAAO,EAK7CC,GAAeC,GAE1B,CACA,CAACC,EAAW,IAAI,EAAGpB,GACnB,CAACoB,EAAW,MAAM,EAAGlB,GACrB,CAACkB,EAAW,OAAO,EAAGhB,GACtB,CAACgB,EAAW,SAAS,EAAGd,GACxB,CAACc,EAAW,MAAM,EAAGZ,GACrB,CAACY,EAAW,IAAI,EAAGV,EACrB,CAAC,EAKYW,GAAgBF,GAAiB,CAC5C,CAACC,EAAW,KAAK,EAAGN,GACpB,CAACM,EAAW,OAAO,EAAG1B,GACtB,CAAC0B,EAAW,MAAM,EAAGxB,EACvB,CAAC,EAKM,SAAS0B,GAAWC,EAAmC,CAC5D,OAAOC,GAAUC,GAAaF,CAAK,EAAE,QAAWA,EAAkB,MACpE,CCpDO,GAAM,CAAE,IAAKG,GAAa,KAAMC,EAAc,EAAIC,GAAQC,EAAY,EAChE,CAAE,IAAKC,GAAW,KAAMC,EAAW,EAAIH,GAAQI,EAAU,EACzD,CAAE,IAAKC,GAAc,KAAMC,EAAc,EAAIN,GACxDO,EACF,EACa,CAAE,IAAKC,GAAY,KAAMC,EAAY,EAAIT,GAAQU,EAAW,EAC5D,CAAE,IAAKC,GAAW,KAAMC,EAAW,EAAIZ,GAAQa,EAAU,EACzD,CAAE,IAAKC,GAAY,KAAMC,EAAY,EAAIf,GAAQgB,EAAW,EAC5D,CAAE,IAAKC,GAAa,KAAMC,EAAa,EAAIlB,GAAQmB,EAAY,EAC/D,CAAE,IAAKC,GAAY,KAAMC,EAAY,EAAIrB,GAAQsB,EAAW,EAE5D,CAAE,IAAKC,GAAU,KAAMC,EAAW,EAAIxB,GAAQyB,EAAS,EACvD,CAAE,IAAKC,GAAa,KAAMC,EAAa,EAAI3B,GAAQ4B,EAAY,EAC/D,CAAE,IAAKC,GAAe,KAAMC,EAAe,EAAI9B,GAC1D+B,EACF,EACa,CAAE,IAAKC,GAAW,KAAMC,EAAW,EAAIjC,GAAQkC,EAAU,EACzD,CAAE,IAAKC,GAAW,KAAMC,EAAW,EAAIpC,GAAQqC,EAAU,EACzD,CAAE,IAAKC,GAAa,KAAMC,EAAa,EAAIvC,GAAQwC,EAAY,ECxBrE,SAASC,GAAYC,EAA+B,CACzD,IAAMC,EAAiB,WAAmB,WACpCC,EAAkB,WAAmB,YAErCC,EAAiB,IACjBC,EAAkB,KAAK,MAAMH,EAAgBE,CAAc,EAC3DE,EAAgB,KAAK,MAAMH,EAAiBC,CAAc,EAEhE,OAAOH,EAAOI,EAAkBC,EAAiB,EAAI,OAAS,OAChE,CAEA,IAAMC,GAAqC,IAAI,IAOxC,SAASC,GAAoBC,EAAyB,CAC3D,GAAIF,GAAc,IAAIE,CAAO,EAC3B,OAAOF,GAAc,IAAIE,CAAO,EAGlC,IAAMC,EAAcD,EAAQ,MAAM,GAAG,EAAE,IAAKE,GAAmB,IAAIA,CAAM,EAAE,EACrEC,EAAU,OAAe,SAAS,cAAc,QAAQ,EAC9DA,EAAO,MAAQ,EACfA,EAAO,OAAS,EAEhB,IAAMC,EAAMD,EAAO,WAAW,IAAI,EAClC,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,iBAAiB,EAEnC,OAAAA,EAAI,UAAYH,EAAY,CAAC,EAC7BG,EAAI,SAAS,EAAG,EAAG,EAAG,CAAC,EACvBA,EAAI,UAAYH,EAAY,CAAC,EAC7BG,EAAI,SAAS,EAAG,EAAG,EAAG,CAAC,EACvBA,EAAI,UAAYH,EAAY,CAAC,EAC7BG,EAAI,SAAS,EAAG,EAAG,EAAG,CAAC,EACvBA,EAAI,UAAYH,EAAY,CAAC,EAC7BG,EAAI,SAAS,EAAG,EAAG,EAAG,CAAC,EAEvBN,GAAc,IAAIE,EAASG,EAAO,UAAU,WAAW,CAAC,EACjDL,GAAc,IAAIE,CAAO,CAClC,CAKO,SAASK,GAAcC,EAAyB,CACrD,IAAMC,EAASD,EAAI,OAAO,CACxB,OAAQ,CAAE,KAAM,OAAQ,CAC1B,CAAC,EAAE,QAAQ,EAEX,OAAOE,GAAWF,EAAKC,CAAM,EAAE,KAAK,CAACE,EAAQC,IACpC,SAASA,EAAO,SAAS,EAAI,SAASD,EAAO,SAAS,CAC9D,CACH,CAKO,SAASE,GAAqBL,EAAgBM,EAGnD,CACA,IAAMC,EAAY,IAAI,IAChBC,EAAW,IAAI,IAErB,QAAWC,KAAWH,EAAU,CAC9B,IAAMI,EAAMC,EAAMF,CAAO,EAEnBG,EAAMZ,EAAI,OAAO,CACrB,OAAQ,CAAE,KAAMU,EAAI,KAAM,GAAIA,EAAI,EAAG,EACrC,SAAU,CAACG,EAAe,SAAUA,EAAe,OAAO,CAC5D,CAAC,EAAE,YAAY,EAAI,EAEnB,GAAI,CAACD,EACH,SAGF,IAAME,EAAWF,GAAK,UAAY,CAAC,EAC7BG,EAAUH,GAAK,SAAW,CAAC,EAEjC,QAAWI,KAAOF,EAChBP,EAAU,IAAIS,CAAG,EAEnB,QAAWC,KAAQF,EACjBP,EAAS,IAAIS,CAAI,CAErB,CAEA,MAAO,CACL,SAAUC,GAAalB,EAAKQ,CAAQ,EACpC,UAAWW,GAAcnB,EAAKO,CAAS,CACzC,CACF,CAGO,SAASa,GACdpB,EACAqB,EACS,CACT,IAAMf,EAAW,IAAI,IAErB,QAAWgB,KAAYD,EAAY,CACjC,GAAM,CAAE,KAAAE,EAAM,GAAAC,CAAG,EAAIb,EAAMW,CAAQ,EAE7BG,EAAUzB,EAAI,OAAO,CACzB,OAAQ,CAAE,KAAM,OAAQ,EAExB,OAAQ,CAAE,KAAAuB,EAAM,GAAAC,CAAG,CACrB,CAAC,EAAE,QAAQ,EAEX,QAAWE,KAAUD,EACnBnB,EAAS,IAAIoB,CAAM,CAEvB,CAEA,OAAOxB,GAAWF,EAAKM,CAAQ,EAAE,KAAK,CAACH,EAAQC,IACtC,SAASA,EAAO,SAAS,EAAI,SAASD,EAAO,SAAS,CAC9D,CACH,CAEO,SAASwB,GACd3B,EACAsB,EACmB,CACnB,GAAM,CAAE,KAAAC,EAAM,GAAAC,CAAG,EAAIb,EAAMW,CAAQ,EAE7BM,EAAS5B,EAAI,OAAO,CACxB,OAAQ,CAAE,KAAM,OAAQ,EACxB,SAAU,QACV,OAAQ,CAAE,KAAAuB,EAAM,GAAAC,CAAG,CACrB,CAAC,EAAE,YAAY,EAEf,OAAOI,EAASC,GAAU7B,EAAK4B,CAAM,EAAI,MAC3C,CAEA,SAASE,GAAa3B,EAAeC,EAAe,CAClD,IAAM2B,EAAU5B,EAAO,OAGvB,OAFgBC,EAAO,OAER,eAAe,EAAE,cAAc2B,EAAQ,eAAe,CAAC,CACxE,CAKO,SAASC,GACdhC,EACAsB,EACA,CACA,GAAM,CAAE,KAAAC,EAAM,GAAAC,CAAG,EAAIb,EAAMW,CAAQ,EAE7BW,EAAQN,GAAe3B,EAAKsB,CAAQ,EAC1C,GAAIW,EACF,OAAOA,EAGT,IAAMR,EAAUzB,EAAI,OAAO,CACzB,OAAQ,CAAE,KAAM,OAAQ,EACxB,OAAQ,CAAE,KAAAuB,EAAM,GAAAC,CAAG,CACrB,CAAC,EAAE,QAAQ,EAELvB,EAASC,GAAWF,EAAK,IAAI,IAAIyB,CAAO,CAAC,EAAE,KAAKK,EAAY,EAElE,OAAO7B,EAAO,OAAS,EAAIA,EAAO,CAAC,EAAI,IACzC,CC1KO,SAASiC,GAAUC,EAAsB,CAC9C,OAAO,IAAI,KAAKA,EAAM,OAAO,EAAE,YAAY,CAC7C,CAKO,SAASC,GAAcC,EAAyB,CACrD,IAAMC,EAAMD,EAAI,OAAO,CACrB,OAAQ,CAAE,KAAME,EAAW,KAAM,CACnC,CAAC,EAAE,QAAQ,EAEX,OAAQC,GAAWH,EAAKC,CAAG,EACxB,KAAK,CAACG,EAAeC,IACbA,EAAO,QAAUD,EAAO,OAChC,CACL,CAQO,SAASE,GAAkBN,EAAgBO,EAAyB,CACzE,OAAOP,EAAI,OAAO,CAChB,OAAQ,CAAE,KAAME,EAAW,KAAM,EACjC,SAAUM,EAAe,SACzB,OAAQ,CAAE,GAAIC,EAAMF,CAAE,EAAE,EAAG,CAC7B,CAAC,EAAE,QAAQ,CACb,CAQO,SAASG,GAAyBV,EAAgBO,EAAqB,CAC5E,OAAOI,GAAWX,EAAKM,GAAkBN,EAAKO,CAAE,CAAC,CACnD,CAQO,SAASK,GAAkBZ,EAAgBO,EAAyB,CACzE,OAAOP,EAAI,OAAO,CAChB,OAAQ,CAAE,KAAME,EAAW,KAAM,EACjC,SAAUM,EAAe,SACzB,OAAQ,CAAE,GAAIC,EAAMF,CAAE,EAAE,EAAG,CAC7B,CAAC,EAAE,QAAQ,CACb,CAQO,SAASM,GAAyBb,EAAgBO,EAAqB,CAC5E,OAAOO,GAAWd,EAAKY,GAAkBZ,EAAKO,CAAE,CAAC,CACnD,CASO,SAASQ,GAAoBf,EAAgBO,EAAY,CAC9D,OAAOS,GAAqBhB,EAAKM,GAAkBN,EAAKO,CAAE,CAAC,CAC7D,CAKO,SAASU,GACdjB,EACAkB,EACA,CACA,IAAMC,EAAW,IAAI,IAGrB,QAAWC,KAAYF,EAAY,CACjC,GAAM,CAAE,KAAAG,EAAM,GAAAd,CAAG,EAAIE,EAAMW,CAAQ,EAE7BE,EAAUtB,EAAI,OAAO,CAAE,OAAQ,CAAE,KAAAqB,EAAM,GAAAd,CAAG,CAAE,CAAC,EAAE,QAAQ,EAE7D,QAAWgB,KAAUD,EACnBH,EAAS,IAAII,CAAM,CAEvB,CAEA,IAAMC,EAAW,IAAI,IAGrB,QAAWC,KAAWN,EAAU,CAC9B,IAAMO,EAAMjB,EAAMgB,CAAO,EAEnBE,EAAS3B,EAAI,OAAO,CACxB,OAAQ,CAAE,KAAM0B,EAAI,KAAM,GAAIA,EAAI,EAAG,EACrC,SAAUlB,EAAe,QAC3B,CAAC,EAAE,QAAQ,EAEX,QAAWD,KAAMoB,EACfH,EAAS,IAAI,mBAAgBjB,CAAE,EAAE,CAErC,CAEA,OAAOJ,GAAWH,EAAKwB,CAAQ,CACjC,CCtHA,IAAMI,GAAyC,IAAI,IAU5C,SAASC,GAAYC,EAAgBC,EAAiC,CAC3E,IAAMC,EAAoB,IAAI,IAC9B,GAAID,EAAM,OAAS,EACjB,OAAOC,EAIT,QAAWC,KAAQF,EACjB,GAAIH,GAAkB,IAAIK,CAAI,EAAG,CAC/B,IAAMC,EAAYN,GAAkB,IAAIK,CAAI,EACxCC,GACFF,EAAK,IAAIE,CAAS,CAEtB,CAKF,GAAIF,EAAK,OAASD,EAAM,KACtB,OAAOC,EAGT,IAAMG,EAAcL,EAAI,OAAO,CAC7B,SAAUM,EAAe,KACzB,OAAQ,MAAM,KAAKL,CAAK,CAC1B,CAAC,EAED,OAAW,CAACM,EAAKC,EAAGL,CAAI,IAAKE,EAAY,QAAQ,EAC3CJ,EAAM,IAAIE,CAAc,GAC1BD,EAAK,IAAIK,CAAa,EAI1B,OAAOL,CACT,CCdA,eAAeO,IAAW,CACxB,IAAMC,EAAS,CAAC,EACVC,EAAM,MAAMC,GAChB,sBAAuB,OAAqB,UAAU,cAAc,OACpEF,EACAG,EACF,EAEA,OAAAC,GAAaH,CAAG,EAEhBA,EAAI,IAAII,EAAkB,EAEnBJ,CACT,CAOO,SAASK,GAAaL,EAAgB,CAC3C,MAAO,CACL,UAAWA,EAAI,UACf,UAAWM,GAAU,KAAK,KAAMN,CAAG,EACnC,YAAaO,GAAY,KAAK,KAAMP,CAAG,EACvC,UAAWQ,GAAU,KAAK,KAAMR,CAAG,EACnC,UAAWS,GAAU,KAAK,KAAMT,CAAG,EACnC,WAAYU,GAAW,KAAK,KAAMV,CAAG,EACrC,YAAaW,GAAY,KAAK,KAAMX,CAAG,EACvC,cAAeY,GAAc,KAAK,KAAMZ,CAAG,EAC3C,WAAYa,GAAW,KAAK,KAAMb,CAAG,EACrC,UAAWc,GAAU,KAAK,KAAMd,CAAG,EACnC,aAAce,GAAa,KAAK,KAAMf,CAAG,EACzC,WAAYgB,GAAW,KAAK,KAAMhB,CAAG,EACrC,cAAeiB,GAAc,KAAK,KAAMjB,CAAG,EAC3C,aAAckB,GAAa,KAAK,KAAMlB,CAAG,EACzC,WAAYmB,GAAW,KAAK,KAAMnB,CAAG,EACrC,YAAaoB,GAAY,KAAK,KAAMpB,CAAG,EACvC,WAAYqB,GAAW,KAAK,KAAMrB,CAAG,EACrC,cAAesB,GAAc,KAAK,KAAMtB,CAAG,EAC3C,YAAauB,GAAY,KAAK,KAAMvB,CAAG,EACvC,eAAgBwB,GAAiB,KAAK,KAAMxB,CAAG,EAC/C,qBAAsByB,GAAqB,KAAK,KAAMzB,CAAG,EACzD,qBAAsB0B,GAAqB,KAAK,KAAM1B,CAAG,EACzD,aAAc2B,GAAa,KAAK,KAAM3B,CAAG,CAC3C,CACF,CAKA,eAAsB4B,IAA4B,CAChD,IAAMC,EAAO,MAAM/B,GAAS,EAE5B,MAAO,CACL,aAAc,OACd,aAAc,OACd,WAAY,OACZ,YAAa,OACb,KAAA+B,EACA,SAAmBC,GAAK,EACxB,eAAgB,GAChB,SAAUzB,GAAawB,CAAI,CAC7B,CACF,CCrGA,IAAAE,GAAc,OAed,SAASC,IAAc,CACrB,MAAO,CACL,KAAKC,EAAkC,CACrC,SAAO,GAAAC,SAAE,KAAM,CACb,MAAO,eACP,QAASC,EAASF,EAAM,MAAM,KAAK,CACrC,EAAGA,EAAM,MAAM,IAAI,CACrB,CACF,CACF,CAKO,SAASG,IAAU,CACxB,SAASC,EAAQC,EAAkB,CACjC,IAAMC,EAAM,CAAC,eAAe,EAC5B,OAAID,GACFC,EAAI,KAAK,iBAAiB,EAErBA,EAAI,KAAK,GAAG,CACrB,CAEA,MAAO,CACL,KAAKN,EAA8B,CACjC,SAAO,GAAAC,SAAE,QAAS,CAAE,MAAOG,EAAQJ,EAAM,MAAM,OAAO,CAAE,EAAG,IACzD,GAAAC,SAAE,MAAO,IACP,GAAAA,SAAE,KAAM,IACN,GAAAA,SAAEF,GAAa,CAAE,KAAM,SAAU,MAAO,SAAU,CAAC,KACnD,GAAAE,SAAEF,GAAa,CAAE,KAAM,SAAU,MAAO,SAAU,CAAC,KACnD,GAAAE,SAAEF,GAAa,CAAE,KAAM,SAAU,MAAO,SAAU,CAAC,KACnD,GAAAE,SAAEF,GAAa,CAAE,KAAM,WAAY,MAAO,WAAY,CAAC,KACvD,GAAAE,SAAEF,GAAa,CAAE,KAAM,QAAS,MAAO,QAAS,CAAC,CACnD,CAAC,CACH,CAAC,CACH,CAAC,CACH,CACF,CACF,CCrDA,IAAAQ,GAAc,OCAd,IAAAC,GAAc,OAOP,SAASC,IAAa,CAC3B,IAAMC,EAAQC,GAAY,OAAqB,KAAK,EAEpD,MAAO,CACL,MAAO,CACL,OAAKD,KAIE,GAAAE,SAAE,gBAAiB,CACxB,GAAGF,EAAM,MAAM,OACf,GAAAE,SAAE,IAAK,CAAE,KAAM,UAAW,EAAG,QAAQ,EACrC,SACA,GAAGF,EAAM,MAAM,OACf,GAAAE,SAAE,IAAK,CAAE,KAAM,UAAW,EAAG,QAAQ,EACrC,SACA,GAAGF,EAAM,MAAM,gBAAaA,EAAM,KAAK,eACvC,GAAGA,EAAM,SAAS,OAClB,GAAAE,SAAE,IAAK,CAAE,KAAM,mBAAoB,EAAG,WAAW,EACjD,SACA,GAAGF,EAAM,YAAY,OACrB,GAAAE,SAAE,IAAK,CAAE,KAAM,gBAAiB,EAAG,cAAc,EACjD,SACA,GAAGF,EAAM,cAAc,OACvB,GAAAE,SAAE,IAAK,CAAE,KAAM,kBAAmB,EAAG,gBAAgB,EACrD,kBACA,GAAAA,SAAE,IAAK,CAAE,KAAM,qBAAsB,EAAG,YAAY,EACpD,WACA,GAAAA,SAAE,IAAK,CAAE,KAAM,mBAAoB,EAAG,UAAU,EAChD,SACA,GAAGF,EAAM,YAAY,OACrB,GAAAE,SAAE,IAAK,CAAE,KAAM,kBAAmB,EAAG,cAAc,CACrD,CAAC,KA1BQ,GAAAA,SAAE,GAAG,CA2BhB,CACF,CACF,CC1CA,IAAAC,GAAc,OCUP,SAASC,GAAcC,EAAgB,IAA6B,CACzE,OAAO,WAAW,WAAW,eAAeA,CAAK,KAAK,EAAE,OAC1D,CAKO,SAASC,GAASC,EAAe,CACtC,SAAS,MAAQA,CACnB,CDFO,SAASC,IAAqB,CACnC,MAAO,CACL,KAAKC,EAAyC,CAC5C,GAAM,CACJ,MAAAC,EACA,QAAAC,EACA,QAAAC,EACA,MAAAC,EACA,aAAAC,EACA,UAAAC,EACA,eAAAC,CACF,EAAIP,EAAM,MACJQ,EAAOJ,IAAU,EAAI,QAAU,SAG/BK,EAFUC,GAAc,GAAkB,EAEhBH,EAAiBD,EAEjD,SAAO,GAAAK,SAAE,2BAA4B,IACnC,GAAAA,SAAE,sBAAuBV,CAAK,KAC9B,GAAAU,SAAE,qBAAsB,IACtB,GAAAA,SAAE,OAAQF,CAAa,CACzB,CAAC,KACD,GAAAE,SAAE,4BAA6B,IAC7B,GAAAA,SAAE,sBAAuB,GAAGP,CAAK,IAAII,CAAI,EAAE,KAC3C,GAAAG,SAAE,0BAA2BN,CAAY,CAC3C,CAAC,CACH,CAAC,CACH,CACF,CACF,CE9CA,IAAAO,GAAc,OCAd,IAAAC,GAAc,OCAd,IAAAC,GAAc,OAId,SAASC,IAAU,CACjB,MAAO,CACL,KAAKC,EAAoC,CACvC,GAAM,CAAE,OAAAC,CAAO,EAAID,EAAM,MAEzB,SAAO,GAAAE,SAAE,iBAAkB,CACzB,OAAQ,GACR,MAAO,GACP,oBAAqB,WACrB,QAAS,cACT,MAAO,4BACT,EAAG,IACD,GAAAA,SAAE,OAAQ,CACR,EAAG,yMACH,KAAMD,CACR,CAAC,CACH,CAAC,CACH,CACF,CACF,CAQO,SAASE,IAAe,CAC7B,MAAO,CACL,KAAKH,EAAmC,CACtC,GAAM,CAAE,GAAAI,EAAI,OAAAH,CAAO,EAAID,EAAM,MAE7B,SAAO,GAAAE,SAAE,6BAA8B,CACrC,QAAS,IAAMG,GAAU,WAAY,CAAE,MAAO,UAAUD,CAAE,EAAG,CAAC,CAChE,KAAG,GAAAF,SAAEH,GAAS,CAAE,OAAAE,CAAO,CAAC,CAAC,CAC3B,CACF,CACF,CD7BA,SAASK,GAAUC,EAAaC,EAAc,CAC5CC,GAAU,eAAgB,CAAE,IAAAF,CAAI,CAAC,EAEjC,IAAMG,EAAgBF,EAAM,QAAwB,YAChD,cACA,wBACF,EAEGE,IAILA,EAAa,MAAM,OAAS,KAC9B,CAWA,SAASC,IAAQ,CACf,MAAO,CACL,KAAKC,EAA4B,CAC/B,GAAM,CAAE,aAAAC,EAAc,QAAAC,EAAS,QAAAC,CAAQ,EAAIH,EAAM,MAEjD,SAAO,GAAAI,SAAE,sBAAuB,CAC9B,OAAQV,GAAU,KAAK,KAAMO,CAAY,EACzC,MAAO,IACP,OAAQ,IACR,IAAKA,EACL,QAASC,EACT,QAAAC,CACF,CAAC,CACH,CACF,CACF,CASA,SAASE,IAAmB,CAC1B,MAAO,CACL,KAAKL,EAAuC,CAC1C,GAAM,CAAE,iBAAAM,CAAiB,EAAIN,EAAM,MAEnC,SAAO,GAAAI,SAAE,oDAAqD,CAC5D,MAAO,IACP,OAAQ,IACR,IAAKE,CACP,CAAC,CACH,CACF,CACF,CAcO,SAASC,IAAY,CAC1B,MAAO,CACL,KAAKP,EAAgC,CACnC,GAAM,CACJ,SAAAQ,EACA,aAAAP,EACA,iBAAAK,EACA,QAAAJ,EACA,QAAAC,CACF,EAAIH,EAAM,MAEV,SAAO,GAAAI,SAAE,IAAK,CACZ,KAAMI,EACN,OAAQ,SACR,IAAK,UACP,EAAG,IACD,GAAAJ,SAAEC,GAAkB,CAAE,iBAAAC,CAAiB,CAAC,KACxC,GAAAF,SAAEL,GAAO,CAAE,aAAAE,EAAc,QAAAC,EAAS,QAAAC,CAAQ,CAAC,CAC7C,CAAC,CACH,CACF,CACF,CAGA,SAASM,GAASC,EAAoB,CACpC,OAAOA,EAAG,WAAW,MAAM,EAAIC,GAASD,CAAE,EAAE,GAAKA,CACnD,CAaO,SAASE,IAAQ,CACtB,MAAO,CACL,KAAKZ,EAA4B,CAC/B,GAAM,CAAE,MAAAa,EAAO,QAAAX,EAAS,YAAAY,CAAY,EAAId,EAAM,MACxCU,EAAKD,GAASI,EAAM,EAAE,EACtB,CACJ,UAAAE,EACA,aAAAd,EACA,cAAAe,CACF,EAAIH,EAGEP,EAAmBW,GAAoBD,CAAa,EAEpDE,KAAU,GAAAd,SAAEe,GAAc,CAAE,GAAAT,EAAI,OAAQG,EAAM,eAAgB,CAAC,EAC/DO,KAAa,GAAAhB,SAAEG,GAAW,CAC9B,SAAUM,EAAM,UAChB,aAAAZ,EACA,iBAAAK,EACA,QAAAJ,EACA,QAAS,IAAM,CACb,OAAO,SAAS,KAAOa,CACzB,CACF,CAAC,EAED,SAAO,GAAAX,SACL,SACA,GAAAA,SAAE,YAAa,CAAC,EAAG,IACjB,GAAAA,SACE,IACA,CAAE,QAASiB,EAAM,EACjBP,EACI,CACAI,EACAE,CACF,EACE,CAACA,CAAU,CACjB,CACF,CAAC,CACH,CACF,CACF,CACF,CDlKA,IAAME,GAAkB,CAAC,EAEzB,SAASC,IAAU,CACjB,MAAO,CACL,KAAKC,EAA8C,CACjD,GAAM,CAAE,KAAAC,CAAK,EAAID,EAAM,MAEvB,GAAI,CAACC,EACH,OAAO,KAGJH,GAAM,SAASG,CAAI,GACtBH,GAAM,KAAKG,CAAI,EAIjB,IAAMC,EAAYJ,GAAM,QAAQG,CAAI,EACpC,SAAO,GAAAE,SAAE,4BAA+BD,EAAY,CAAE,CACxD,CACF,CACF,CAcO,SAASE,IAAa,CAC3B,MAAO,CACL,KAAKJ,EAAiC,CACpC,GAAM,CACJ,SAAAK,EACA,aAAAC,EACA,iBAAAC,EACA,QAAAC,EACA,MAAAC,EACA,QAAAC,EACA,QAAAC,EACA,KAAAV,CACF,EAAID,EAAM,MAEV,SAAO,GAAAG,SAAE,kBAAmB,CAAE,gBAAiBO,CAAQ,EAAG,IACxD,GAAAP,SAAEJ,GAAS,CAAE,KAAAE,CAAK,CAAC,KACnB,GAAAE,SAAES,GAAW,CACX,SAAAP,EACA,aAAAC,EACA,iBAAAC,EACA,QAAAC,EACA,QAAAG,CACF,CAAC,EAEDF,CACF,CAAC,CACH,CACF,CACF,CGnEA,IAAAI,GAAc,OCKP,SAASC,GAASC,EAAa,CACpC,GAAM,CAAE,KAAAC,EAAM,GAAAC,CAAG,EAAIC,EAAMH,CAAG,EAC9B,MAAO,WAAWC,CAAI,IAAIC,CAAE,EAC9B,CDSO,SAASE,IAAc,CAC5B,MAAO,CACL,KAAKC,EAAkC,CACrC,GAAM,CAAE,QAAAC,EAAS,KAAAC,CAAK,EAAIF,EAAM,MAC1B,CAAE,GAAAG,EAAI,KAAAC,CAAK,EAAIH,EAErB,GAAI,CAACE,EACH,SAAO,GAAAE,SAAE,GAAG,EAGd,IAAMC,EAAOC,GAAaN,CAAO,EAE3BO,EAASC,EAAMN,CAAE,EACjBO,EAAUC,EAAS,UAAUH,EAAO,IAAI,IAAIA,EAAO,EAAE,EAAE,EAE7D,OAAIN,IAAS,UACJ,GAAAG,SAAE,uBAAwB,CAAE,KAAMO,GAAST,CAAE,EAAG,QAAAO,CAAQ,EAAGJ,CAAI,KAGjE,GAAAD,SACL,iBACA,CAAE,KAAMO,GAAST,CAAE,EAAG,QAAAO,CAAQ,EAC9B,GAAGJ,CAAI,IAAIF,CAAI,EACjB,CACF,CACF,CACF,CEtCO,SAASS,GAAUC,EAAoC,CAC5D,OAAIA,IAAU,OACL,IAAI,IAGN,IAAI,IAAI,MAAM,QAAQA,CAAK,EAAIA,EAAQ,CAACA,CAAK,CAAC,CACvD,CAKO,SAASC,GAASC,EAAkBC,EAAiC,CAC1E,IAAMC,EAAS,IAAI,IAEnB,QAAWC,KAAOF,EAChB,GAAID,KAAYG,EAAK,CACnB,IAAML,EAAQK,EAAIH,CAAQ,EAC1B,GAAIF,IAAU,OACZ,SAGF,GAAI,MAAM,QAAQA,CAAK,EACrB,QAAWM,KAAQN,EACjBI,EAAO,IAAIE,CAAI,OAGjBF,EAAO,IAAIJ,CAAK,CAEpB,CAGF,OAAOI,CACT,CTlBA,SAASG,GAAaC,EAAYC,EAAeC,EAAc,CAC7D,IAAMC,EAASC,EAAMJ,CAAE,EAEvBK,GAAU,WAAY,CAAE,MAAO,UAAUF,EAAO,EAAE,GAAI,MAAAF,CAAM,CAAC,EAC7DK,GAAMJ,CAAK,CACb,CAEA,SAASK,GACPC,EACAC,EACAC,EACAC,EACA,CACA,IAAMC,EAAUC,GAAYH,CAAG,EAEzBI,EAGA,CAAC,EAGP,GAAIN,EAAM,OAASO,GAAUN,CAAK,IAChCD,EAAM,KAAOO,GAAUN,CAAK,EAExBD,EAAM,OAAS,IAAI,KAAK,EAAE,YAAY,GAAG,CAC3C,IAAMQ,KAAM,GAAAC,SACV,wBACA,CAAE,IAAK,QAAQT,EAAM,IAAI,EAAG,EAC5BA,EAAM,KAAK,SAAS,CACtB,EACAM,EAAiB,KAAKE,CAAG,CAC3B,CAGF,IAAME,EAAgBP,EAAS,cAAcQ,GAAOV,EAAM,OAAO,CAAC,EAAE,IACjEW,MACQ,GAAAH,SAAEI,GAAa,CACpB,QAAAD,EACA,IAAK,iBAAiBX,EAAM,EAAE,IAAIW,EAAQ,EAAE,GAC5C,KAAM,MACR,CAAC,CAEL,EAEME,KAAM,GAAAL,SAAEM,GAAoB,CAChC,MAAOd,EAAM,KACb,QAASA,EAAM,QACf,QAASA,EAAM,QACf,MAAOA,EAAM,YACb,aAAcS,EACd,SAAAP,EACA,UAAWF,EAAM,UACjB,eAAgBA,EAAM,cACxB,CAAC,EAEKe,KAAS,GAAAP,SAAEQ,GAAY,CAC3B,KAAMhB,EAAM,KACZ,SAAUA,EAAM,aAChB,aAAcA,EAAM,aACpB,iBAAkBiB,GAAoBjB,EAAM,MAAM,EAClD,QAASG,EACT,QAASH,EAAM,QACf,QAASV,GAAa,KAAK,KAAMU,EAAM,GAAIA,EAAM,IAAI,CACvD,CAAC,EAED,OAAAK,EAAiB,QACf,GAAAG,SAAE,MAAO,CACP,IAAK,SAASR,EAAM,EAAE,EACxB,EAAG,CACDe,EACAF,CACF,CAAC,CACH,EAEOR,CACT,CAKA,SAASa,IAAa,CACpB,MAAO,CACL,KAAKC,EAAiC,CACpC,IAAMpB,EAAQ,CAAE,KAAM,IAAK,EACrB,CAAE,OAAAqB,EAAQ,SAAAlB,CAAS,EAAIiB,EAAM,MAE7Bd,EAGA,CAAC,EAGP,QAASJ,EAAM,EAAGA,EAAMmB,EAAO,OAAQnB,IACrCI,EAAiB,KAAK,GAAGP,GAAUC,EAAOqB,EAAOnB,CAAG,EAAGA,EAAKC,CAAQ,CAAC,EAGvE,SAAO,GAAAM,SAAE,0BAA2BH,CAAgB,CACtD,CACF,CACF,CASO,SAASgB,IAAa,CAC3B,MAAO,CACL,QAAS,CACPC,GAAS,iBAAiB,CAC5B,EACA,KAAKH,EAAiC,CACpC,GAAM,CAAE,OAAAC,EAAQ,SAAAlB,EAAU,QAAAqB,CAAQ,EAAIJ,EAAM,MAEtCN,KAAM,GAAAL,SAAE,yBAA0B,IACtC,GAAAA,SAAE,mBAAoB,QAAQ,KAC9B,GAAAA,SAAEgB,EAAU,CACd,CAAC,EAED,SAAO,GAAAhB,SAAE,MAAO,CACd,MAAOe,EAAU,uBAAyB,MAC5C,EAAG,CACDV,KAEA,GAAAL,SAAEU,GAAY,CAAE,OAAAE,EAAQ,SAAAlB,EAAU,QAAAqB,CAAQ,CAAC,CAC7C,CAAC,CACH,CACF,CACF,CUrJA,IAAAE,GAAc,OAUP,SAASC,IAAY,CAC1B,MAAO,CACL,QAAS,CACPC,GAAS,gBAAgB,CAC3B,EACA,KAAKC,EAAgC,CACnC,GAAM,CAAE,QAAAC,CAAQ,EAAID,EAAM,MACpBE,EAAQ,IAAI,KAAK,EAAE,YAAY,EAAI,KAEzC,SAAO,GAAAC,SAAE,MAAO,CACd,MAAOF,EAAU,uBAAyB,MAC5C,EAAG,IACD,GAAAE,SAAE,qBAAsB,IACtB,GAAAA,SAAE,KAAM,OAAO,KACf,GAAAA,SAAE,IAAI,KACN,GAAAA,SACE,IACA,2BAA2BD,CAAK,oNAChC,GAAAC,SAAE,IAAK,CACL,KAAM,gDACN,QAASC,EAAS,iBAAiB,CACrC,EAAG,mCAAmC,CACxC,KACA,GAAAD,SAAE,KAAM,oCAAoC,KAC5C,GAAAA,SACE,IACA,6KACF,KACA,GAAAA,SAAE,KAAM,4CAA4C,KACpD,GAAAA,SACE,IACA,8BACA,GAAAA,SACE,IACA,CAAE,KAAM,wCAAyC,EACjD,YACF,EACA,gDACF,KACA,GAAAA,SAAE,KAAM,mCAAmC,KAC3C,GAAAA,SACE,IACA,UACA,GAAAA,SAAE,IAAK,CAAE,KAAM,wBAAyB,EAAG,kBAAkB,EAC7D,uBACF,CACF,CAAC,CACH,CAAC,CACH,CACF,CACF,CC5DA,IAAAE,GAAc,OCAd,IAAAC,GAAc,OASP,SAASC,IAAQ,CACtB,MAAO,CACL,KAAKC,EAA4B,CAC/B,GAAM,CACJ,QAAAC,EACA,MAAAC,CACF,EAAIF,EAAM,MAEV,GAAI,CAACE,EACH,SAAO,GAAAC,SAAE,MAAO,UAAU,EAG5B,GAAM,CACJ,UAAAC,EACA,cAAAC,EACA,aAAAC,EACA,aAAAC,EACA,iBAAAC,CACF,EAAIN,EAEEO,KAAU,GAAAN,SAAE,SAAU,CAC1B,IAAKG,EACL,KAAM,WACR,CAAC,EAEKI,KAAmB,GAAAP,SAAE,KAAM,IAC/B,GAAAA,SAAE,IAAK,CAAE,KAAMK,CAAiB,EAAG,KAAK,KACxC,GAAAL,SAAE,IAAK,CAAE,KAAME,CAAc,EAAG,KAAK,KACrC,GAAAF,SAAE,IAAK,CAAE,KAAMI,CAAa,EAAG,KAAK,KACpC,GAAAJ,SAAE,IAAK,CAAE,KAAMG,CAAa,EAAG,MAAM,CACvC,CAAC,EAED,SAAO,GAAAH,SAAE,MAAO,CAAE,IAAK,SAASD,EAAM,EAAE,EAAG,EAAG,IAC5C,GAAAC,SAAE,wBAAyB,CACzB,SAAU,GACV,QAAAF,EACA,OAAQG,CACV,EAAGK,CAAO,EACVC,CACF,CAAC,CACH,CACF,CACF,CDxCO,SAASC,IAAa,CAC3B,MAAO,CACL,KAAKC,EAAiC,CACpC,GAAM,CAAE,OAAAC,EAAQ,QAAAC,CAAQ,EAAIF,EAAM,MAC5BG,EAAkBF,EAAO,SAAW,EACtC,UACA,GAAGA,EAAO,MAAM,UAEdG,EAAcH,EAAO,IAAKI,MACvB,GAAAC,SAAEC,GAAO,CAAE,MAAAF,EAAO,QAAS,MAAO,CAAsB,CAChE,EAED,SAAO,GAAAC,SACL,MACA,CACE,MAAOJ,EAAU,uBAAyB,MAC5C,KACA,GAAAI,SAAE,0BAA2B,IAC3B,GAAAA,SAAE,KAAM,QAAQ,KAChB,GAAAA,SAAE,sBAAuBH,CAAe,CAC1C,CAAC,KACD,GAAAG,SAAE,0BAA2BF,CAAW,CAC1C,CACF,CACF,CACF,CEzBO,SAASI,GAAcC,EAAyB,CACrD,IAAMC,EAASD,EAAI,OAAO,CACxB,OAAQ,CAAE,KAAM,OAAQ,CAC1B,CAAC,EAAE,QAAQ,EAEX,OAAOE,GAAWF,EAAKC,CAAM,CAC/B,CCjBA,IAAAE,GAAc,OCqBP,SAASC,GAAgBC,EAA0B,CACxD,IAAMC,EAAO,IAAI,KAAK,SAASD,CAAQ,CAAC,EAClCE,EAAsC,CAC1C,KAAM,UACN,MAAO,OACP,IAAK,UACL,KAAM,UACN,OAAQ,SACV,EAEA,OAAOD,EAAK,mBAAmB,QAASC,CAAO,CACjD,CChCA,IAAAC,GAAc,OAQd,SAASC,GAAYC,EAAiB,CAChCA,EAAQ,SAAS,iBAAiB,GAGtC,MAAMA,CAAO,CACf,CAGA,eAAeC,GACbC,EACAC,EACAC,EACA,CACA,GAAI,CAAC,UAAU,MAAO,CACpBL,GAAY,+BAA+B,EAC3C,MACF,CAEA,GAAI,CACF,MAAM,UAAU,MAAM,CACpB,MAAO,GAAGK,CAAI,0BACd,IAAAD,CACF,CAAC,CACH,OAASE,EAAO,CACd,QAAQ,MAAM,iBAAkBA,CAAK,CACvC,QAAE,CACAH,EAAM,QAAU,EAClB,CACF,CAGA,SAASI,GAAWJ,EAA6B,CAC/C,OAAOA,EAAM,QAAU,eAAiB,SAC1C,CAGO,SAASK,IAAmB,CACjC,IAAMC,EAAa,CACjB,QAAS,EACX,EAEA,MAAO,CACL,KAAKC,EAAuC,CAC1C,GAAM,CAAE,IAAAN,EAAK,KAAAC,CAAK,EAAIK,EAAM,MAE5B,SAAO,GAAAC,SAAE,4BAA6B,CACpC,SAAU,CAAC,UAAU,MACrB,QAAST,GAAW,KAAK,KAAMO,EAAYL,EAAKC,CAAI,CACtD,EAAGE,GAAWE,CAAU,CAAC,CAC3B,CACF,CACF,CC3DA,IAAAG,GAAc,OAMP,SAASC,IAAe,CAC7B,MAAO,CACL,MAAO,CACL,SAAO,GAAAC,SACL,IACA,CAAE,KAAM,UAAW,QAASC,EAAS,SAAS,CAAE,EAChD,UACF,CACF,CACF,CACF,CCZO,SAASC,GAAWC,EAAqB,CAC9C,OAAOA,EAAI,OAAO,CAAC,EAAE,YAAY,EAAIA,EAAI,MAAM,CAAC,CAClD,CAEO,SAASC,GAAUD,EAAqB,CAC7C,OAAIE,GAAQ,IAAIF,CAAG,EACVE,GAAQ,IAAIF,CAAG,EAGjBA,EAAM,GACf,CAuBO,SAASG,GAASA,EAAkB,CACzC,IAAMC,EAASD,EAAS,QAAQ,KAAM,GAAG,EACzC,OAAOE,GAAWD,CAAM,CAC1B,CAKO,SAASE,GAAsBC,EAA6B,CACjE,OAAOA,EAAY,QAAQ,OAAQ,GAAG,CACxC,CJVO,SAASC,IAAY,CAC1B,MAAO,CACL,QAAS,CACPC,GAAS,gBAAgB,CAC3B,EACA,KAAKC,EAA4B,CAC/B,GAAM,CACJ,MAAAC,EACA,OAAAC,EACA,OAAAC,EACA,SAAAC,EACA,QAAAC,CACF,EAAIL,EAAM,MAEJ,CACJ,KAAAM,EACA,QAAAC,EACA,QAAAC,EACA,YAAAC,EACA,YAAAC,EACA,QAAAC,EACA,UAAAC,EACA,eAAAC,CACF,EAAIZ,EAEEa,EAAgBC,GAAc,GAAkB,EAClDF,EACAD,EAEEI,GAAoBP,IAAgB,EACtC,UACA,GAAGA,CAAW,UAEZQ,EAAgBb,EAAS,cAC7BA,EAAS,YAAYc,GAAOP,CAAO,CAAC,CACtC,EAAE,IAAKA,MACE,GAAAQ,SAAEC,GAAa,CACpB,QAAAT,EACA,KAAM,MACR,CAAC,CACF,EAEK,CAAE,GAAAU,EAAG,EAAIC,EAAMrB,EAAM,EAAE,EACvBsB,EAAM,0CAA0CF,EAAE,GAElDG,KAAiB,GAAAL,SAAE,0BAA2B,IAClD,GAAAA,SAAE,KAAMb,CAAI,KACZ,GAAAa,SAAE,wBAAsB,GAAAA,SAAE,OAAQL,CAAa,CAAC,KAChD,GAAAK,SAAE,sBAAuBH,EAAiB,KAC1C,GAAAG,SAAE,0BAA2BF,CAAa,KAC1C,GAAAE,SACE,4BACA,GAAAA,QAAE,MAAMM,GAAsBf,GAAe,EAAE,GAAK,EAAE,CACxD,KACA,GAAAS,SAAEO,GAAkB,CAAE,IAAAH,EAAK,KAAAjB,CAAK,CAAC,EACjC,OACA,GAAAa,SAAEQ,EAAY,EACd,GACF,CAAC,EAEKC,EAAc1B,EAAO,IAAI,CAAC2B,EAAOC,OAC9B,GAAAX,SACLY,GACA,CACE,MAAAF,EACA,QAASG,GAAYF,CAAG,EACxB,YAAa,EACf,CACF,CACD,EACKG,EAAc9B,EAAO,IAAK+B,MACvB,GAAAf,SAAEgB,GAAO,CAAE,MAAAD,EAAO,QAAS,MAAO,CAAsB,CAChE,EAED,SAAO,GAAAf,SACL,MACA,CACE,MAAOd,EAAU,uBAAyB,MAC5C,EACAmB,KACA,GAAAL,SAAE,0BAA2BS,CAAW,KACxC,GAAAT,SAAE,0BAA2Bc,CAAW,CAC1C,CACF,CACF,CACF,CK1HA,IAAAG,GAAc,OAMd,SAASC,IAAa,CACpB,MAAO,CACL,KAAKC,EAAiC,CACpC,GAAM,CAAE,OAAAC,CAAO,EAAID,EAAM,MAGzB,SAAO,GAAAE,SACL,0BACAD,EAAO,IAAI,CAACE,EAAOC,IAAQ,CACzB,IAAMC,EAAUC,GAAYF,CAAG,EAE/B,SAAO,GAAAF,SAAEK,GAAO,CACd,IAAK,SAASJ,EAAM,EAAE,GACtB,MAAAA,EACA,QAAAE,EACA,YAAa,EACf,CAAC,CACH,CAAC,CACH,CACF,CACF,CACF,CAQO,SAASG,IAAa,CAC3B,MAAO,CACL,KAAKR,EAAiC,CACpC,GAAM,CAAE,OAAAC,EAAQ,QAAAQ,CAAQ,EAAIT,EAAM,MAE5BU,EAAY,GAAGT,EAAO,MAAM,SAChCA,EAAO,SAAW,EAAI,GAAK,GAC7B,GAEMU,KAAM,GAAAT,SAAE,0BAA2B,IACvC,GAAAA,SAAE,KAAM,QAAQ,KAChB,GAAAA,SAAE,sBAAuBQ,CAAS,CACpC,CAAC,EAED,SAAO,GAAAR,SAAE,MAAO,CACd,MAAOO,EAAU,uBAAyB,MAC5C,EAAG,CAACE,KAAK,GAAAT,SAAEH,GAAY,CAAE,OAAAE,EAAQ,QAAAQ,CAAQ,CAAC,CAAC,CAAC,CAC9C,CACF,CACF,CCtDA,IAAAG,GAAc,OCAd,IAAAC,GAAc,OAUP,SAASC,IAAc,CAC5B,MAAO,CACL,KAAKC,EAAkC,CACrC,GAAM,CAAE,GAAAC,CAAG,EAAID,EAAM,MAErB,SAAO,GAAAE,SAAE,IAAK,CACZ,KAAM,WAAWD,CAAE,GACnB,QAASE,EAAS,UAAUF,CAAE,EAAE,CAClC,EAAG,SAAS,CACd,CACF,CACF,CCrBA,IAAAG,EAAc,OAcd,SAASC,IAAU,CACjB,MAAO,CACL,KAAKC,EAA8B,CACjC,GAAM,CAAE,KAAAC,CAAK,EAAID,EAAM,MACvB,SAAO,EAAAE,SAAE,kBAAmBD,CAAI,CAClC,CACF,CACF,CAKA,SAASE,IAAc,CACrB,MAAO,CACL,KAAKH,EAA+B,CAClC,GAAM,CAAE,MAAAI,EAAO,SAAAC,CAAS,EAAIL,EAAM,MAE5BM,EAASD,EAAS,aAAa,CAACD,EAAM,KAAK,CAAC,EAClD,OAAIE,EAAO,OAAS,KACX,EAAAJ,SAAE,KAAMI,CAAM,KAGhB,EAAAJ,SAAE,KAAM,SAAS,CAC1B,CACF,CACF,CAKA,SAASK,IAAiB,CACxB,MAAO,CACL,KAAKP,EAA+B,CAClC,GAAM,CAAE,MAAAI,CAAM,EAAIJ,EAAM,MAExB,OAAI,OAAOI,EAAM,OAAU,UAAY,OAAOA,EAAM,QAAW,YACtD,EAAAF,SAAE,KAAM,GAAGE,EAAM,KAAK,MAAMA,EAAM,MAAM,EAAE,KAG5C,EAAAF,SAAE,KAAM,SAAS,CAC1B,CACF,CACF,CAKA,SAASM,IAAc,CACrB,MAAO,CACL,KAAKR,EAA+B,CAClC,GAAM,CAAE,MAAAI,CAAM,EAAIJ,EAAM,MACxB,OAAII,EAAM,cAAgB,aACjB,EAAAF,SAAE,KAAM,SAAS,EACfE,EAAM,cAAgB,OACxB,EAAAF,SAAE,KAAM,aAAa,EAClBE,EAAM,eAGT,EAAAF,SAAE,KAAM,GAAGE,EAAM,WAAW,IAAI,KAFhC,EAAAF,SAAE,KAAM,SAAS,CAI5B,CACF,CACF,CAKA,SAASO,IAAe,CACtB,MAAO,CACL,KAAKT,EAA+B,CAClC,GAAM,CAAE,MAAAI,CAAM,EAAIJ,EAAM,MAClB,CAAE,aAAAU,CAAa,EAAIN,EAEzB,GAAI,OAAOM,GAAiB,SAAU,CACpC,IAAMC,EAAS,WAAWD,CAAY,EACtC,OAAI,MAAMC,CAAM,KACP,EAAAT,SAAE,KAAM,SAAS,EACfS,GAAU,KACZ,EAAAT,SAAE,KAAM,GAAGS,CAAM,IAAI,KAErB,EAAAT,SAAE,KAAM,KAAK,KAAK,MAAM,EAAIS,CAAM,CAAC,IAAI,CAElD,CAEA,SAAO,EAAAT,SAAE,KAAM,SAAS,CAC1B,CACF,CACF,CAKA,SAASU,IAAW,CAClB,MAAO,CACL,KAAKZ,EAA+B,CAClC,GAAM,CAAE,MAAAI,CAAM,EAAIJ,EAAM,MAExB,OAAII,EAAM,QAAU,aACX,EAAAF,SAAE,KAAM,SAAS,EACfE,EAAM,QAAU,SAClB,EAAAF,SAAE,KAAM,yBAAyB,EAC9BE,EAAM,SAIX,EAAAF,SAAE,KAAM,UAAKE,EAAM,KAAK,EAAE,KAHxB,EAAAF,SAAE,KAAM,SAAS,CAI5B,CACF,CACF,CAEO,SAASW,IAAW,CACzB,MAAO,CACL,KAAKb,EAA+B,CAClC,GAAM,CAAE,MAAAI,EAAO,SAAAC,CAAS,EAAIL,EAAM,MAE5Bc,KAAY,EAAAZ,SAAE,KAAM,IACxB,EAAAA,SAAEH,GAAS,CAAE,KAAM,WAAY,CAAC,KAChC,EAAAG,SAAE,QAAM,EAAAA,SAAE,OAAca,GAAgBX,EAAM,SAAS,CAAC,CAAC,CAC3D,CAAC,EAEKE,KAAS,EAAAJ,SAAE,KAAM,IACrB,EAAAA,SAAEH,GAAS,CAAE,KAAM,cAAe,CAAC,KACnC,EAAAG,SAAEC,GAAa,CAAE,MAAAC,EAAO,SAAAC,CAAS,CAAC,CACpC,CAAC,EAEKW,KAAc,EAAAd,SAAE,KAAM,IAC1B,EAAAA,SAAEH,GAAS,CAAE,KAAM,YAAa,CAAC,KACjC,EAAAG,SAAEK,GAAgB,CAAE,MAAAH,EAAO,SAAAC,CAAS,CAAC,CACvC,CAAC,EAEKY,KAAe,EAAAf,SAAE,KAAM,IAC3B,EAAAA,SAAEH,GAAS,CAAE,KAAM,cAAe,CAAC,KACnC,EAAAG,SAAEM,GAAa,CAAE,MAAAJ,EAAO,SAAAC,CAAS,CAAC,CACpC,CAAC,EAEKa,KAAgB,EAAAhB,SAAE,KAAM,IAC5B,EAAAA,SAAEH,GAAS,CAAE,KAAM,eAAgB,CAAC,KACpC,EAAAG,SAAEO,GAAc,CAAE,MAAAL,EAAO,SAAAC,CAAS,CAAC,CACrC,CAAC,EAEKc,KAAY,EAAAjB,SAAE,KAAM,IACxB,EAAAA,SAAEH,GAAS,CAAE,KAAM,UAAW,CAAC,KAC/B,EAAAG,SAAEU,GAAU,CAAE,MAAAR,EAAO,SAAAC,CAAS,CAAC,CACjC,CAAC,EAEKe,KAAO,EAAAlB,SAAE,KAAM,IACnB,EAAAA,SAAEH,GAAS,CAAE,KAAM,KAAM,CAAC,KAC1B,EAAAG,SAAE,KAAME,EAAM,KAAO,SAAS,CAChC,CAAC,EAED,SAAO,EAAAF,SAAE,uBAAwB,CAC/BY,EACAR,EACAU,EACAC,EACAC,EACAC,EACAC,CACF,CAAC,CACH,CACF,CACF,CC/KA,IAAAC,EAAc,OAUd,SAASC,IAAU,CACjB,MAAO,CACL,KAAKC,EAA8B,CACjC,GAAM,CAAE,KAAAC,CAAK,EAAID,EAAM,MACvB,SAAO,EAAAE,SAAE,kBAAmBD,CAAI,CAClC,CACF,CACF,CAQA,SAASE,IAAc,CACrB,MAAO,CACL,KAAKH,EAAqC,CACxC,GAAM,CAAE,MAAAI,CAAM,EAAIJ,EAAM,MAElBK,EAAOC,GACXF,EAAM,aAAeA,EAAM,SAAW,EACxC,EACA,OAAIC,KACK,EAAAH,SAAE,KAAM,EAAAA,QAAE,MAAMG,CAAI,CAAC,KAGvB,EAAAH,SAAE,KAAM,QAAG,CACpB,CACF,CACF,CAGA,SAASK,IAAW,CAClB,MAAO,CACL,KAAKP,EAAqC,CACxC,GAAM,CAAE,MAAAI,EAAO,SAAAI,CAAS,EAAIR,EAAM,MAE5BS,EAAaD,EAAS,aAAaE,GAASN,EAAM,QAAQ,CAAC,EACjE,SAAO,EAAAF,SAAE,KAAMO,EAAW,OAAS,EAAIA,EAAa,QAAG,CACzD,CACF,CACF,CAGA,SAASE,IAAS,CAChB,MAAO,CACL,KAAKX,EAAqC,CACxC,GAAM,CAAE,MAAAI,EAAO,SAAAI,CAAS,EAAIR,EAAM,MAE5BY,EAAUJ,EAAS,aAAa,CAACJ,EAAM,MAAM,CAAC,EACpD,SAAO,EAAAF,SAAE,KAAMU,EAAQ,OAAS,EAAIA,EAAU,QAAG,CACnD,CACF,CACF,CAGA,SAASC,IAAQ,CACf,MAAO,CACL,KAAKb,EAAqC,CACxC,GAAM,CAAE,MAAAI,EAAO,SAAAI,CAAS,EAAIR,EAAM,MAE5Bc,EAASN,EAAS,aAAa,CAACJ,EAAM,KAAK,CAAC,EAClD,SAAO,EAAAF,SAAE,KAAMY,EAAO,OAAS,EAAIA,EAAS,QAAG,CACjD,CACF,CACF,CAGA,SAASC,IAAU,CACjB,MAAO,CACL,KAAKf,EAAqC,CACxC,GAAM,CAAE,MAAAI,EAAO,SAAAI,CAAS,EAAIR,EAAM,MAE5BgB,EAAWR,EAAS,aAAaE,GAASN,EAAM,OAAO,CAAC,EAC9D,SAAO,EAAAF,SAAE,KAAMc,EAAS,OAAS,EAAIA,EAAW,QAAG,CACrD,CACF,CACF,CAGA,SAASC,IAAU,CACjB,MAAO,CACL,KAAKjB,EAAqC,CACxC,GAAM,CAAE,MAAAI,EAAO,SAAAI,CAAS,EAAIR,EAAM,MAE5BkB,EAAaV,EAAS,aAAaE,GAASN,EAAM,OAAO,CAAC,EAChE,SAAO,EAAAF,SAAE,KAAMgB,EAAW,OAAS,EAAIA,EAAa,QAAG,CACzD,CACF,CACF,CAQO,SAASC,IAAY,CAC1B,MAAO,CACL,KAAKnB,EAAgC,CACnC,GAAM,CAAE,MAAAI,EAAO,SAAAI,CAAS,EAAIR,EAAM,MAE5BoB,EAAY,CAAC,EAEnB,OAAIhB,EAAM,aAAeA,EAAM,UAC7BgB,EAAU,QAAK,EAAAlB,SAAE,KAAM,IACrB,EAAAA,SAAEH,GAAS,CAAE,KAAM,aAAc,CAAC,KAClC,EAAAG,SAAEC,GAAa,CAAE,MAAAC,EAAO,SAAAI,CAAS,CAAC,CACpC,CAAC,CAAC,EAGJY,EAAU,QACR,EAAAlB,SAAE,KAAM,IACN,EAAAA,SAAEH,GAAS,CAAE,KAAM,SAAU,CAAC,KAC9B,EAAAG,SAAEe,GAAS,CAAE,MAAAb,EAAO,SAAAI,CAAS,CAAC,CAChC,CAAC,KACD,EAAAN,SAAE,KAAM,IACN,EAAAA,SAAEH,GAAS,CAAE,KAAM,UAAW,CAAC,KAC/B,EAAAG,SAAEK,GAAU,CAAE,MAAAH,EAAO,SAAAI,CAAS,CAAC,CACjC,CAAC,KACD,EAAAN,SAAE,KAAM,IACN,EAAAA,SAAEH,GAAS,CAAE,KAAM,QAAS,CAAC,KAC7B,EAAAG,SAAES,GAAQ,CAAE,MAAAP,EAAO,SAAAI,CAAS,CAAC,CAC/B,CAAC,KACD,EAAAN,SAAE,KAAM,IACN,EAAAA,SAAEH,GAAS,CAAE,KAAM,OAAQ,CAAC,KAC5B,EAAAG,SAAEW,GAAO,CAAE,MAAAT,EAAO,SAAAI,CAAS,CAAC,CAC9B,CAAC,KACD,EAAAN,SAAE,KAAM,IACN,EAAAA,SAAEH,GAAS,CAAE,KAAM,SAAU,CAAC,KAC9B,EAAAG,SAAEa,GAAS,CAAE,MAAAX,EAAO,SAAAI,CAAS,CAAC,CAChC,CAAC,CACH,KAEO,EAAAN,SAAE,uBAAwBkB,CAAS,CAC5C,CACF,CACF,CHtIO,SAASC,IAAY,CAC1B,MAAO,CACL,KAAKC,EAAgC,CACnC,GAAM,CAAE,MAAAC,EAAO,SAAAC,EAAU,QAAAC,CAAQ,EAAIH,EAAM,MAGrCI,KAAS,GAAAC,SAAE,eAAgB,IAC/B,GAAAA,SAAE,IAAK,CAAE,KAAMJ,EAAM,UAAW,IAAK,YAAa,EAAG,QAAQ,EAC7D,OACA,GAAAI,SAAE,IAAK,CAAE,KAAMJ,EAAM,OAAQ,IAAK,YAAa,EAAG,OAAO,EACzD,OAEA,GAAAI,SAAEC,GAAa,CAAE,GAAIL,EAAM,OAAQ,CAAC,CACtC,CAAC,EAEKM,KAAQ,GAAAF,SAAEG,GAAU,CAAE,MAAAP,EAAO,SAAAC,CAAS,CAAC,EACvCO,KAAa,GAAAJ,SAAEK,GAAW,CAAE,MAAAT,EAAO,SAAAC,CAAS,CAAC,EAEnD,SAAO,GAAAG,SAAE,UAAW,IAClB,GAAAA,SAAE,KAAM,OAAO,KACf,GAAAA,SAAEM,GAAO,CACP,MAAAV,EACA,QAAS,QACT,YAAa,EACf,CAAC,EACDG,KACA,GAAAC,SACE,MACA,CACE,MAAOF,EAAU,uBAAyB,MAC5C,KACA,GAAAE,SAAE,KAAM,mBAAmB,EAC3BI,KACA,GAAAJ,SAAE,KAAM,WAAW,EACnBE,CACF,CACF,CAAC,CACH,CACF,CACF,CIrDA,IAAAK,GAAc,OCAd,IAAAC,GAAc,OCAd,IAAAC,GAAc,OCAd,IAAAC,GAAc,OAEP,SAASC,IAAe,CAC7B,MAAO,CACL,KAAKC,EAAgD,CACnD,GAAM,CAAE,KAAAC,EAAM,KAAAC,CAAK,EAAIF,EAAM,MAC7B,SAAO,GAAAG,SAAE,IAAK,CACZ,KAAAF,EACA,OAAQ,SACR,IAAK,UACP,EAAGC,CAAI,CACT,CACF,CACF,CDLO,SAASE,IAAY,CAC1B,MAAO,CACL,KAAKC,EAA4C,CAC/C,GAAM,CAAE,OAAAC,CAAO,EAAID,EAAM,MAEzB,GAAIC,EAAO,SAAW,EACpB,SAAO,GAAAC,SAAE,IAAI,EAGf,GAAM,CAACC,CAAK,EAAIF,EACVG,EAAS,CAAC,EAEVC,EAAYC,EAAIH,EAAM,SAAS,EACjCE,GACFD,EAAO,QACL,GAAAF,SAAE,QAAM,GAAAA,SAAEK,GAAc,CAAE,KAAMF,EAAW,KAAM,aAAc,CAAC,CAAC,CACnE,EAGF,IAAMG,EAAYF,EAAIH,EAAM,YAAY,EACxC,OAAIK,GACFJ,EAAO,QACL,GAAAF,SAAE,QAAM,GAAAA,SAAEK,GAAc,CAAE,KAAMC,EAAW,KAAM,aAAc,CAAC,CAAC,CACnE,KAIK,GAAAN,SAAE,eAAgBE,CAAM,CACjC,CACF,CACF,CD/BO,SAASK,IAAgB,CAE9B,IAAMC,EAAU,IAAI,IAAI,CACtBC,EAAW,UACXA,EAAW,QACXA,EAAW,OACXA,EAAW,KACXA,EAAW,MACb,CAAC,EAED,MAAO,CACL,KAAKC,EAAyC,CAC5C,GAAM,CAAE,MAAAC,CAAM,EAAID,EAAM,MAClB,CAAE,KAAAE,CAAK,EAAIC,EAAMC,EAAIH,EAAM,EAAE,CAAW,EAExCI,KAAS,GAAAC,SAAEC,GAAW,CAAE,OAAQ,CAACN,CAAK,CAAE,CAAC,EACzCO,EAAQN,IAASH,EAAW,QAC9B,GAAGU,GAAaR,CAAK,CAAC,IAAIG,EAAIH,EAAM,IAAI,CAAC,GACzCG,EAAIH,EAAM,IAAI,EAElB,SAAO,GAAAK,SAAE,2BAA4B,IACnC,GAAAA,SAAE,sBAAuBE,CAAK,EAC9BH,CACF,CAAC,CACH,CACF,CACF,CDnBA,SAASK,GAAeC,EAAoBC,EAAqBC,EAAa,CAC5E,IAAMC,EAAKC,EAAIH,EAAM,EAAE,EAEvB,GAAI,CAACE,EACH,MAAO,CAAC,EAGV,IAAME,EAAaL,EAAS,eAAeG,CAAE,EAC7C,GAAI,CAACE,EACH,MAAO,CAAC,EAGV,IAAMC,KAAM,GAAAC,SAAEC,GAAe,CAAE,MAAAP,CAAM,CAAC,EAEhC,CAAE,GAAIQ,EAAS,KAAAC,CAAK,EAAIC,EAAMR,CAAE,EAGtC,MAAO,IAAC,GAAAI,SAAEK,GAAY,CACpB,SAAUP,EAAW,UACrB,aAAcA,EAAW,aACzB,iBAAkBQ,GAAoBR,GAAY,aAAa,EAC/D,QAASS,GAAYZ,CAAG,EACxB,KAAM,OACN,MAAOI,EACP,QAASS,EAAS,UAAUL,CAAI,IAAID,CAAO,EAAE,CAC/C,CAAC,CAAC,CACJ,CAMA,SAASO,IAAa,CACpB,MAAO,CACL,KAAKC,EAAgE,CACnE,GAAM,CAAE,SAAAjB,EAAU,OAAAkB,CAAO,EAAID,EAAM,MAE7BE,EAAmBD,EAAO,QAAQ,CAACjB,EAAOC,KAC9C,QAAQ,IAAI,2BAA4BD,CAAK,EACtCF,GAAeC,EAAUC,EAAOC,CAAG,EAC3C,EAED,SAAO,GAAAK,SAAE,0BAA2BY,CAAgB,CACtD,CACF,CACF,CAMA,SAASC,IAAe,CACtB,MAAO,CACL,KAAKH,EAAkC,CACrC,GAAM,CAAE,KAAAP,CAAK,EAAIO,EAAM,MACvB,SAAO,GAAAV,SACL,mBACA,GAAGc,GAAWC,GAAUZ,CAAI,CAAC,CAAC,EAChC,CACF,CACF,CACF,CAKA,SAASa,IAAsB,CAC7B,MAAO,CACL,KAAKN,EAAkC,CACrC,GAAM,CAAE,KAAAP,CAAK,EAAIO,EAAM,MACvB,SAAO,GAAAV,SAAE,IAAK,CACZ,KAAM,WAAWG,CAAI,KACrB,QAASK,EAAS,UAAUL,CAAI,IAAI,CACtC,EAAG,WAAWA,CAAI,SAAS,CAC7B,CACF,CACF,CAaO,SAASc,IAAc,CAC5B,MAAO,CACL,KAAKP,EAAkC,CACrC,GAAM,CAAE,KAAAP,EAAM,OAAAQ,EAAQ,SAAAlB,EAAU,QAAAyB,CAAQ,EAAIR,EAAM,MAE5CX,EAAM,IACV,GAAAC,SAAEa,GAAc,CAAE,KAAAV,CAAK,CAAC,CAC1B,EAEA,OAAKgB,GAAiB,IAAIhB,CAAI,GAC5BJ,EAAI,QACF,GAAAC,SAAE,yBAA0B,IAC1B,GAAAA,SAAEgB,GAAqB,CAAE,KAAAb,CAAK,CAAC,CACjC,CAAC,CACH,KAGK,GAAAH,SAAE,MAAO,CACd,MAAOkB,EAAU,uBAAyB,MAC5C,EAAG,IACD,GAAAlB,SAAE,yBAA0BD,CAAG,KAC/B,GAAAC,SAAES,GAAY,CAAE,SAAAhB,EAAU,OAAAkB,CAAO,CAAC,CACpC,CAAC,CACH,CACF,CACF,CIhIA,IAAAS,GAAc,OAQd,SAASC,IAAc,CACrB,MAAO,CACL,KAAKC,EAAkC,CACrC,SAAO,GAAAC,SACL,QACA,GAAAA,SAAE,IAAK,CACL,MAAO,eACP,QAASC,EAASF,EAAM,MAAM,KAAK,CACrC,EAAGA,EAAM,MAAM,IAAI,CACrB,CACF,CACF,CACF,CAMO,SAASG,IAAe,CAC7B,MAAO,CACL,KAAKH,EAAmC,CACtC,GAAM,CAAE,QAAAI,CAAQ,EAAIJ,EAAM,MAE1B,SAAO,GAAAC,SAAE,MAAO,CACd,MAAOG,EAAU,uBAAyB,MAC5C,EAAG,IACD,GAAAH,SAAE,KAAM,UAAU,KAClB,GAAAA,SAAE,IAAI,KACN,GAAAA,SAAE,IAAK,mDAAmD,KAC1D,GAAAA,SAAE,IAAI,KACN,GAAAA,SACE,aACA,GAAAA,SAAE,KAAM,IACN,GAAAA,SAAEF,GAAa,CAAE,MAAO,iBAAkB,KAAM,QAAS,CAAC,KAC1D,GAAAE,SAAEF,GAAa,CAAE,MAAO,mBAAoB,KAAM,WAAY,CAAC,KAC/D,GAAAE,SAAEF,GAAa,CAAE,MAAO,gBAAiB,KAAM,OAAQ,CAAC,KACxD,GAAAE,SAAEF,GAAa,CAAE,MAAO,kBAAmB,KAAM,SAAU,CAAC,KAC5D,GAAAE,SAAEF,GAAa,CAAE,MAAO,mBAAoB,KAAM,UAAW,CAAC,KAC9D,GAAAE,SAAEF,GAAa,CAAE,MAAO,qBAAsB,KAAM,YAAa,CAAC,KAClE,GAAAE,SAAEF,GAAa,CAAE,MAAO,kBAAmB,KAAM,SAAU,CAAC,CAC9D,CAAC,CACH,CACF,CAAC,CACH,CACF,CACF,CCrDA,IAAAM,EAAc,OCEd,IAAAC,GAAc,OAOd,SAASC,GAAaC,EAAaC,EAAgC,CACjE,IAAMC,EAASC,GAASH,CAAG,EAG3B,GAAIE,EAAO,KAAO,IAChB,OAAOE,GAAWC,GAAUH,EAAO,IAAI,CAAC,EAG1C,GAAID,EAAO,SAAW,EACpB,OAAOD,EAGT,GAAM,CAACM,CAAK,EAAIL,EACVM,EAAOC,EAAIF,EAAM,IAAI,GAAKJ,EAAO,GAEvC,OAAIA,EAAO,OAASO,EAAW,QACtB,GAAGC,GAAaJ,CAAK,CAAC,IAAIC,CAAI,GAC5BL,EAAO,OAASO,EAAW,MAC7B,GAAGE,GAAWL,CAAK,CAAC,IAAIC,CAAI,GAG9BA,CACT,CAOO,SAASK,IAAa,CAC3B,MAAO,CACL,KAAKC,EAAiC,CACpC,GAAM,CAAE,IAAAb,EAAK,OAAAC,CAAO,EAAIY,EAAM,MACxBC,EAAQf,GAAaC,EAAKC,CAAM,EAEtC,OAAAc,GAASD,CAAK,KAEP,GAAAE,SAAE,KAAMF,CAAK,CACtB,CACF,CACF,CAEO,SAASG,IAAgB,CAC9B,MAAO,CACL,KAAKJ,EAAiC,CACpC,IAAMX,EAASgB,EAAML,EAAM,MAAM,GAAG,EAEpC,OAAOM,GAAc,IAAIjB,EAAO,IAAI,GAAKA,EAAO,KAAO,OACnD,GAAAc,SACA,OACA,CAAE,MAAO,kBAAkBd,EAAO,IAAI,WAAY,EAClDkB,GAASlB,EAAO,EAAE,CACpB,KACE,GAAAc,SAAE,MAAM,CACd,CACF,CACF,CCjEA,IAAAK,GAAc,OAUP,SAASC,IAAa,CAC3B,MAAO,CACL,KAAKC,EAAiC,CACpC,GAAM,CAAE,KAAAC,EAAM,SAAAC,CAAS,EAAIF,EAAM,MAO3BG,EANYD,EAAS,cAAcD,CAAI,EAAE,KAC7C,CAACG,EAAMC,KACGC,EAAIF,EAAK,IAAI,GAAK,IAAI,cAAcE,EAAID,EAAK,IAAI,GAAK,EAAE,CAEpE,EAE0B,IAAKE,GAAa,CAC1C,IAAMC,KAAQ,GAAAC,SAAEC,GAAW,CACzB,IAAKJ,EAAIC,EAAS,EAAE,EACpB,MAAOA,CACT,CAAC,EACD,SAAO,GAAAE,SAAE,KAAM,CAAE,IAAK,SAASF,EAAS,EAAE,EAAG,EAAGC,CAAK,CACvD,CAAC,EAED,SAAO,GAAAC,SAAE,KAAMN,CAAO,CACxB,CACF,CACF,CC9BA,IAAAQ,GAAc,OAId,SAASC,GAAeC,EAAcC,EAAc,CAClDC,GAAU,WAAY,CACpB,MAAO,YAAYF,CAAI,EACzB,CAAC,EACDG,GAAMF,CAAK,CACb,CAIO,SAASG,IAAc,CAC5B,MAAO,CACL,KAAKC,EAAkC,CACrC,IAAIL,EAAO,GACX,MAAI,SAAUK,EAAM,MAClBL,EAAOK,EAAM,MAAM,KAGnBL,EADeM,EAAMD,EAAM,MAAM,GAAG,EACtB,QAGT,GAAAE,SAAE,IAAK,CACZ,KAAM,aAAaP,CAAI,GACvB,QAASD,GAAe,KAAK,KAAMC,CAAI,CACzC,EAAGQ,GAAWR,CAAI,CAAC,CACrB,CACF,CACF,CC/BA,IAAAS,GAAc,OCAd,IAAAC,GAAc,OAgBP,SAASC,IAAc,CAC5B,MAAO,CACL,KAAKC,EAAkC,CACrC,GAAM,CAAE,IAAAC,EAAK,MAAAC,CAAM,EAAIF,EAAM,MACvB,CAAE,KAAAG,EAAM,GAAAC,CAAG,EAAIC,EAAMJ,CAAG,EAExBK,EAAOC,EAAIL,EAAM,IAAI,GAAKE,EAE1BI,EAAO,GADCC,GAAWR,EAAKK,EAAMJ,CAAK,CACpB,IAAKI,CAAI,GAE9B,SAAO,GAAAI,SAAE,IAAK,CACZ,MAAO,CAAC,aAAc,GAAGP,CAAI,OAAO,EAAE,KAAK,GAAG,CAChD,EAAGK,CAAI,CACT,CACF,CACF,CDlBO,SAASG,IAAe,CAC7B,MAAO,CACL,KAAKC,EAAmC,CACtC,GAAM,CAAE,KAAAC,EAAM,SAAAC,CAAS,EAAIF,EAAM,MAG3BG,EAFWD,EAAS,aAAaD,CAAI,EAEhB,IAAKG,GAAY,CAC1C,IAAMC,EAAKC,EAAIF,EAAQ,EAAE,EAEzB,SAAO,GAAAG,SAAE,KAAM,CACb,IAAK,WAAWF,CAAE,EACpB,KAAG,GAAAE,SAAEC,GAAa,CAAE,IAAKH,EAAI,MAAOD,CAAQ,CAAC,CAAC,CAChD,CAAC,EAED,SAAO,GAAAG,SAAE,KAAMJ,CAAS,CAC1B,CACF,CACF,CE9BA,IAAAM,GAAc,OCAd,IAAAC,GAAc,OAUP,SAASC,IAAa,CAC3B,MAAO,CACL,KAAKC,EAAiC,CACpC,GAAM,CAAE,IAAAC,EAAK,MAAAC,CAAM,EAAIF,EAAM,MACvB,CAAE,KAAAG,EAAM,GAAAC,CAAG,EAAIC,EAAMJ,CAAG,EAExBK,EAAOC,EAAIL,EAAM,IAAI,GAAKE,EAEhC,SAAO,GAAAI,SAAE,IAAK,CACZ,KAAM,kCAAkCJ,CAAE,GAC1C,OAAQ,SACR,IAAK,sBACL,MAAO,CAAC,aAAc,GAAGD,CAAI,OAAO,EAAE,KAAK,GAAG,CAChD,EAAGG,CAAI,CACT,CACF,CACF,CDhBO,SAASG,IAAa,CAC3B,MAAO,CACL,KAAKC,EAAiC,CACpC,GAAM,CAAE,KAAAC,EAAM,SAAAC,CAAS,EAAIF,EAAM,MAG3BG,EADUD,EAAS,YAAYD,CAAI,EAChB,IAAKG,GAAW,CACvC,IAAMC,EAAMC,EAAIF,EAAO,EAAE,EAEzB,SAAO,GAAAG,SAAE,QAAM,GAAAA,SAAEC,GAAY,CAAE,IAAAH,EAAK,MAAOD,CAAO,CAAC,CAAC,CACtD,CAAC,EAED,SAAO,GAAAG,SAAE,KAAMJ,CAAQ,CACzB,CACF,CACF,CNkBA,SAASM,IAAgB,CACvB,MAAO,CACL,KAAKC,EAAgC,CACnC,IAAMC,EAAuC,CAAC,EACxC,CAAE,IAAAC,EAAK,OAAAC,EAAQ,SAAAC,CAAS,EAAIJ,EAAM,MAExCC,EAAS,kBAAiB,EAAAI,SAAEC,GAAa,CAAE,IAAAJ,CAAI,CAAC,EAEhD,IAAMK,EAAYC,GAAcC,EAAe,GAAIN,CAAM,EAMzD,GAJII,EAAU,KAAO,IACnBN,EAAS,YAAY,KAAI,EAAAI,SAAEK,GAAY,CAAE,SAAAN,EAAU,KAAMG,CAAU,CAAC,GAGlEJ,EAAO,SAAW,EACpB,OAGF,GAAM,CAACQ,CAAK,EAAIR,EAGZQ,EAAM,WACRV,EAAS,YAAY,KAAI,EAAAI,SAAEO,GAAc,CACvC,KAAMC,GAAOF,EAAM,QAAQ,EAC3B,SAAAP,CACF,CAAC,GAGCO,EAAM,WACRV,EAAS,YAAc,EAAAI,SAAEK,GAAY,CACnC,SAAAN,EACA,KAAMS,GAAOF,EAAM,QAAQ,CAC7B,CAAC,GAGCA,EAAM,WACRV,EAAS,UAAY,EAAAI,SAAES,GAAY,CACjC,KAAM,IAAI,IAAIC,GAASJ,EAAM,QAAQ,CAAC,EACtC,SAAAP,CACF,CAAC,GAOH,IAAMY,EAAQ,OAAO,QAAQf,CAAQ,EAAE,IAAI,CAAC,CAACgB,EAAKC,CAAK,OAC9C,EAAAb,SAAE,KAAM,IACb,EAAAA,SAAE,kBAAmBY,CAAG,KACxB,EAAAZ,SAAE,KAAMa,CAAK,CACf,CAAC,CACF,EAED,SAAO,EAAAb,SAAE,MAAO,IACd,EAAAA,SAAE,KAAM,SAAS,KACjB,EAAAA,SAAE,uBAAwBW,CAAK,CACjC,CAAC,CACH,CACF,CACF,CAEA,SAASG,GAAaC,EAAYC,EAAeC,EAAc,CAC7D,IAAMC,EAASC,EAAMJ,CAAE,EAEvBK,GAAU,WAAY,CAAE,MAAO,UAAUF,EAAO,EAAE,GAAI,MAAAF,CAAM,CAAC,EAC7DK,GAAMJ,CAAK,CACb,CAEA,SAASK,IAAe,CACtB,MAAO,CACL,KAAK3B,EAAgC,CACnC,GAAM,CAAE,OAAAG,EAAQ,SAAAC,CAAS,EAAIJ,EAAM,MAE7B4B,EAAOpB,GAAc,KAAML,CAAM,EAGjC0B,EAFSzB,EAAS,qBAAqB,IAAI,IAAIwB,CAAI,CAAC,EAEnC,IAAKE,GAAU,CAIpC,IAAMC,EAHY3B,EAAS,cAAcS,GAAOiB,EAAM,OAAO,CAAC,EAG9B,IAAKE,MAC5B,EAAA3B,SAAE4B,GAAa,CACpB,QAAAD,EACA,IAAK,iBAAiBF,EAAM,EAAE,IAAIE,EAAQ,EAAE,GAC5C,KAAM,MACR,CAAC,CACF,EAEKE,KAAM,EAAA7B,SAAE8B,GAAoB,CAChC,MAAOL,EAAM,KACb,QAASA,EAAM,QACf,QAASA,EAAM,QACf,MAAOA,EAAM,YACb,aAAcC,EACd,UAAWD,EAAM,UACjB,eAAgBA,EAAM,cACxB,CAAC,EAEKM,KAAS,EAAA/B,SAAEgC,GAAY,CAC3B,SAAUP,EAAM,aAChB,aAAcA,EAAM,aACpB,iBAAkBQ,GAAoBR,EAAM,MAAM,EAClD,QAAS,OACT,QAASA,EAAM,QACf,QAASX,GAAa,KAAK,KAAMW,EAAM,GAAIA,EAAM,IAAI,EACrD,KAAM,OACN,SAAO,EAAAzB,SAAE,GAAG,CACd,CAAC,EAED,SAAO,EAAAA,SACL,MACA+B,EACAF,CACF,CACF,CAAC,EAED,SAAO,EAAA7B,SACL,0BACAwB,CACF,CACF,CACF,CACF,CAEA,SAASU,IAAe,CACtB,MAAO,CACL,KAAKvC,EAAgC,CACnC,GAAM,CAAE,OAAAG,EAAQ,SAAAC,CAAS,EAAIJ,EAAM,MAE7B4B,EAAOpB,GAAc,KAAML,CAAM,EACjCqC,EAASpC,EAAS,qBAAqBwB,CAAI,EAEjD,SAAO,EAAAvB,SACL,0BACAmC,EAAO,IAAI,CAACC,EAAOC,IAAQ,CACzB,IAAMC,EAAUC,GAAYF,CAAG,EAE/B,SAAO,EAAArC,SAAEwC,GAAO,CACd,IAAK,SAASJ,EAAM,EAAE,GACtB,MAAAA,EACA,QAAAE,EACA,YAAa,EACf,CAAC,CACH,CAAC,CACH,CACF,CACF,CACF,CAEO,SAASG,IAAY,CAC1B,MAAO,CACL,KAAK9C,EAAgC,CACnC,GAAM,CAAE,IAAAE,EAAK,OAAAC,EAAQ,SAAAC,EAAU,QAAA2C,CAAQ,EAAI/C,EAAM,MAEjD,SAAO,EAAAK,SAAE,MAAO,CACd,MAAO0C,EAAU,uBAAyB,MAC5C,EAAG,IACD,EAAA1C,SAAE,qBAAsB,IACtB,EAAAA,SAAE2C,GAAY,CAAE,IAAA9C,EAAK,OAAAC,CAAO,CAAC,KAC7B,EAAAE,SAAE4C,GAAe,CAAE,IAAA/C,CAAI,CAAC,KACxB,EAAAG,SAAE,IAAI,KACN,EAAAA,SAAE6C,GAAW,CAAE,OAAA/C,CAAO,CAAC,KACvB,EAAAE,SAAEN,GAAe,CAAE,IAAAG,EAAK,OAAAC,EAAQ,SAAAC,EAAU,QAAA2C,CAAQ,CAAC,KACnD,EAAA1C,SAAE,KAAM,QAAQ,KAChB,EAAAA,SAAEkC,GAAc,CAAE,IAAArC,EAAK,OAAAC,EAAQ,SAAAC,EAAU,QAAA2C,CAAQ,CAAC,KAClD,EAAA1C,SAAE,KAAM,QAAQ,KAChB,EAAAA,SAAEsB,GAAc,CAAE,IAAAzB,EAAK,OAAAC,EAAQ,SAAAC,EAAU,QAAA2C,CAAQ,CAAC,CACpD,CAAC,CACH,CAAC,CACH,CACF,CACF,CpDpLA,IAAMI,EAAQ,MAAMC,GAAU,EAE9BC,GAAO,WAAaC,GAAiB,CACnC,GAAM,CAAE,MAAAC,CAAM,EAAKD,EAAsB,OACzC,QAAQ,KAAK,wBAAwBC,CAAK,EAAE,EAE5CJ,EAAM,eAAiB,GACvB,EAAAK,QAAE,MAAM,IAAID,CAAK,CACnB,CAAC,EAEDF,GAAO,eAAgB,IAAM,CAC3BF,EAAM,SAAW,CAACA,EAAM,QAC1B,CAAC,EAEDE,GAAO,oBAAqB,IAAM,CAChCF,EAAM,eAAiB,CAACA,EAAM,cAChC,CAAC,EAGM,SAASM,IAAmC,CACjD,MAAO,CACL,QAAS,CACT,EACA,MAAO,CACL,SAAO,EAAAD,SACL,iBACA,CAAE,MAAOL,EAAM,SAAW,YAAc,MAAU,EAClD,IACE,EAAAK,SAAEE,GAAQP,CAAK,KACf,EAAAK,SAAE,oBAAqB,CACrB,MAAOL,EAAM,eAAiB,kBAAoB,MACpD,EAAG,IACD,EAAAK,SAAEG,GAAS,CAAE,QAASR,EAAM,cAAe,CAAC,KAC5C,EAAAK,SAAEI,GAAY,CACZ,OAAQC,GAAcV,EAAM,IAAI,EAChC,SAAUA,EAAM,SAChB,QAASA,EAAM,cACjB,CAAC,CACH,CAAC,CACH,CACF,CACF,CACF,CACF,CAGO,SAASW,IAAkC,CAChD,MAAO,CACL,QAAS,CACP,IAAMC,EAAK,EAAAP,QAAE,MAAM,MAAM,IAAI,EAC7BL,EAAM,aAAe,mBAAgBY,CAAE,EACzC,EACA,MAAO,CACL,GAAI,CAACZ,EAAM,aACT,SAAO,EAAAK,SAAE,IAAK,mBAAmB,EAEnC,IAAMQ,EAAQC,GAAUd,EAAM,KAAMA,EAAM,YAAY,EAChDe,EAASC,GAAyBhB,EAAM,KAAMA,EAAM,YAAY,EAChEiB,EAASC,GAAyBlB,EAAM,KAAMA,EAAM,YAAY,EAEtE,GAAI,CAACa,EACH,SAAO,EAAAR,SAAE,IAAK,iBAAiB,EAGjC,GAAM,CAAE,SAAAc,EAAU,UAAAC,CAAU,EAAIC,GAC9BrB,EAAM,KACNA,EAAM,YACR,EAEA,SAAO,EAAAK,SACL,iBACA,CAAE,MAAOL,EAAM,SAAW,YAAc,MAAU,EAClD,IACE,EAAAK,SAAEE,GAAQP,CAAK,KACf,EAAAK,SAAE,oBAAqB,CACrB,MAAOL,EAAM,eAAiB,kBAAoB,MACpD,EAAG,IACD,EAAAK,SAAEG,GAAS,CAAE,QAASR,EAAM,cAAe,CAAC,KAC5C,EAAAK,SAAEiB,GAAW,CACX,MAAAT,EACA,SAAAM,EACA,QAASN,EAAM,SAAW,CAAC,EAC3B,UAAAO,EACA,OAAAL,EACA,OAAAE,EACA,SAAUjB,EAAM,SAChB,QAASA,EAAM,cACjB,CAAC,CACH,CAAC,CACH,CACF,CACF,CACF,CACF,CAGO,SAASuB,IAAkC,CAChD,MAAO,CACL,MAAO,CACL,SAAO,EAAAlB,SACL,iBACA,CAAE,MAAOL,EAAM,SAAW,YAAc,MAAU,EAClD,IACE,EAAAK,SAAEE,GAAQP,CAAK,KACf,EAAAK,SAAE,oBAAqB,CACrB,MAAOL,EAAM,eAAiB,kBAAoB,MACpD,EAAG,IACD,EAAAK,SAAEG,GAAS,CAAE,QAASR,EAAM,cAAe,CAAC,KAC5C,EAAAK,SAAEmB,GAAW,CAAE,QAASxB,EAAM,cAAe,CAAC,CAChD,CAAC,CACH,CACF,CACF,CACF,CACF,CAGO,SAASyB,IAAmC,CACjD,MAAO,CACL,MAAO,CACL,SAAO,EAAApB,SACL,iBACA,CAAE,MAAOL,EAAM,SAAW,YAAc,MAAU,EAClD,IACE,EAAAK,SAAEE,GAAQP,CAAK,KACf,EAAAK,SAAE,oBAAqB,CACrB,MAAOL,EAAM,eAAiB,kBAAoB,MACpD,EAAG,IACD,EAAAK,SAAEG,GAAS,CAAE,QAASR,EAAM,cAAe,CAAC,KAC5C,EAAAK,SAAEqB,GAAY,CACZ,OAAQC,GAAc3B,EAAM,IAAI,EAChC,QAASA,EAAM,cACjB,CAAC,CACH,CAAC,CACH,CACF,CACF,CACF,CACF,CAGO,SAAS4B,IAAmC,CACjD,MAAO,CACL,MAAO,CACL,SAAO,EAAAvB,SACL,iBACA,CAAE,MAAOL,EAAM,SAAW,YAAc,MAAU,EAClD,IACE,EAAAK,SAAEE,GAAQP,CAAK,KACf,EAAAK,SAAE,oBAAqB,CACrB,MAAOL,EAAM,eAAiB,kBAAoB,MACpD,EAAG,IACD,EAAAK,SAAEG,GAAS,CAAE,QAASR,EAAM,cAAe,CAAC,KAC5C,EAAAK,SAAEwB,GAAY,CACZ,OAAQC,GAAc9B,EAAM,IAAI,EAChC,QAASA,EAAM,cACjB,CAAC,CACH,CAAC,CACH,CACF,CACF,CACF,CACF,CAGO,SAAS+B,IAAkC,CAChD,IAAIC,EAAyB,CAAC,EAE9B,MAAO,CACL,MAAO,CACL,IAAMC,EAAO,EAAA5B,QAAE,MAAM,MAAM,MAAM,EAIjC,GAHAL,EAAM,WAAa,aAAUiC,CAAI,GAElBC,EAAMlC,EAAM,UAAU,EAC1B,KAAO,IAChBgC,EAASG,GAAoBnC,EAAM,KAAMiC,EAAK,MAAM,GAAG,EAAE,CAAC,CAAC,MACtD,CACL,IAAMG,EAAQC,GAAUrC,EAAM,KAAMA,EAAM,UAAU,EAChDoC,IACFJ,EAAS,CAACI,CAAK,EAEnB,CAEA,OAAKpC,EAAM,cAIJ,EAAAK,SACL,iBACA,CAAE,MAAOL,EAAM,SAAW,YAAc,MAAU,EAClD,IACE,EAAAK,SAAEE,GAAQP,CAAK,KACf,EAAAK,SAAE,oBAAqB,CACrB,MAAOL,EAAM,eAAiB,kBAAoB,MACpD,EAAG,IACD,EAAAK,SAAEG,GAAS,CAAE,QAASR,EAAM,cAAe,CAAC,KAC5C,EAAAK,SAAEiC,GAAW,CACX,IAAKtC,EAAM,WACX,OAAAgC,EACA,SAAUhC,EAAM,SAChB,QAASA,EAAM,cACjB,CAAC,CACH,CAAC,CACH,CACF,KApBS,EAAAK,SAAE,IAAK,mBAAmB,CAqBrC,CACF,CACF,CAGO,SAASkC,IAAkC,CAChD,MAAO,CACL,QAAS,CACP,IAAM3B,EAAK,EAAAP,QAAE,MAAM,MAAM,IAAI,EAC7BL,EAAM,aAAe,mBAAgBY,CAAE,EACzC,EACA,MAAO,CACL,GAAI,CAACZ,EAAM,aACT,SAAO,EAAAK,SAAE,IAAK,mBAAmB,EAEnC,IAAMmC,EAAQC,GAAUzC,EAAM,KAAMA,EAAM,YAAY,EAEtD,OAAKwC,KAIE,EAAAnC,SACL,iBACA,CAAE,MAAOL,EAAM,SAAW,YAAc,MAAU,EAClD,IACE,EAAAK,SAAEE,GAAQP,CAAK,KACf,EAAAK,SAAE,oBAAqB,CACrB,MAAOL,EAAM,eAAiB,kBAAoB,MACpD,EAAG,IACD,EAAAK,SAAEG,GAAS,CAAE,QAASR,EAAM,cAAe,CAAC,KAC5C,EAAAK,SAAEqC,GAAW,CAAE,MAAAF,EAAO,SAAUxC,EAAM,SAAU,QAASA,EAAM,cAAe,CAAC,CACjF,CAAC,CACH,CACF,KAfS,EAAAK,SAAE,IAAK,iBAAiB,CAgBnC,CACF,CACF,CAGO,SAASsC,IAAoC,CAClD,MAAO,CACL,QAAS,CACP,IAAMC,EAAO,EAAAvC,QAAE,MAAM,MAAM,MAAM,EACjCL,EAAM,YAAc4C,CACtB,EAEA,MAAO,CACL,GAAI,CAAC5C,EAAM,YACT,SAAO,EAAAK,SAAE,IAAK,kBAAkB,EAGlC,IAAM2B,EAASG,GAAoBnC,EAAM,KAAMA,EAAM,WAAW,EAEhE,SAAO,EAAAK,SACL,iBACA,CAAE,MAAOL,EAAM,SAAW,YAAc,MAAU,EAClD,IACE,EAAAK,SAAEE,GAAQP,CAAK,KACf,EAAAK,SAAE,oBAAqB,CACrB,MAAOL,EAAM,eAAiB,kBAAoB,MACpD,EAAG,IACD,EAAAK,SAAEG,GAAS,CAAE,QAASR,EAAM,cAAe,CAAC,KAC5C,EAAAK,SAAEwC,GAAa,CACb,KAAM7C,EAAM,YACZ,OAAAgC,EACA,SAAUhC,EAAM,SAChB,QAASA,EAAM,cACjB,CAAC,CACH,CAAC,CACH,CACF,CACF,CACF,CACF,CAEO,SAAS8C,IAAqC,CACnD,MAAO,CACL,MAAO,CACL,SAAO,EAAAzC,SACL,iBACA,CAAE,MAAOL,EAAM,SAAW,YAAc,MAAU,EAClD,IACE,EAAAK,SAAEE,GAAQP,CAAK,KACf,EAAAK,SAAE,oBAAqB,CACrB,MAAOL,EAAM,eAAiB,kBAAoB,MACpD,EAAG,IACD,EAAAK,SAAEG,GAAS,CAAE,QAASR,EAAM,cAAe,CAAC,KAC5C,EAAAK,SAAE0C,GAAc,CAAE,QAAS/C,EAAM,cAAe,CAAC,CACnD,CAAC,CACH,CACF,CACF,CACF,CACF,CD/TA,GAAAgD,QAAE,MAAM,SAAS,KAAM,UAAW,CAChC,UAAWC,GACX,SAAUC,GACV,UAAWC,GACX,UAAWC,GACX,aAAcC,GACd,eAAgBC,GAChB,aAAcC,GACd,iBAAkBC,GAClB,YAAaC,EACf,CAAC",
  "names": ["require_vnode", "__commonJSMin", "exports", "module", "Vnode", "tag", "key", "attrs", "children", "text", "dom", "node", "input", "numKeyed", "i", "require_hyperscriptVnode", "__commonJSMin", "exports", "module", "Vnode", "attrs", "children", "require_hasOwn", "__commonJSMin", "exports", "module", "require_emptyAttrs", "__commonJSMin", "exports", "module", "require_cachedAttrsIsStaticMap", "__commonJSMin", "exports", "module", "emptyAttrs", "require_hyperscript", "__commonJSMin", "exports", "module", "Vnode", "hyperscriptVnode", "hasOwn", "emptyAttrs", "cachedAttrsIsStaticMap", "selectorParser", "selectorCache", "isEmpty", "object", "key", "isFormAttributeKey", "compileSelector", "selector", "match", "tag", "classes", "attrs", "isStatic", "type", "value", "attrValue", "execSelector", "state", "vnode", "className", "hyperscript", "children", "require_trust", "__commonJSMin", "exports", "module", "Vnode", "html", "require_fragment", "__commonJSMin", "exports", "module", "Vnode", "hyperscriptVnode", "attrs", "children", "vnode", "require_hyperscript", "__commonJSMin", "exports", "module", "hyperscript", "require_delayedRemoval", "__commonJSMin", "exports", "module", "require_domFor", "__commonJSMin", "exports", "module", "delayedRemoval", "domFor", "vnode", "dom", "domSize", "generation", "nextSibling", "require_render", "__commonJSMin", "exports", "module", "Vnode", "delayedRemoval", "domFor", "cachedAttrsIsStaticMap", "nameSpace", "currentRedraw", "currentRender", "getDocument", "dom", "getNameSpace", "vnode", "checkState", "original", "callHook", "activeElement", "createNodes", "parent", "vnodes", "start", "end", "hooks", "nextSibling", "ns", "i", "createNode", "tag", "initLifecycle", "createText", "createHTML", "createFragment", "createElement", "createComponent", "insertDOM", "possibleParents", "match", "temp", "fragment", "child", "children", "attrs", "is", "element", "setAttrs", "maybeSetContentEditable", "setLateSelectAttrs", "initComponent", "sentinel", "updateNodes", "old", "removeNodes", "isOldKeyed", "isKeyed", "oldStart", "oldEnd", "map", "o", "v", "oe", "ve", "topSibling", "updateNode", "getNextSibling", "moveDOM", "originalNextSibling", "vnodesLength", "oldIndices", "li", "pos", "matched", "lisIndices", "getKeyMap", "oldIndex", "makeLisIndices", "commonLength", "removeNode", "oldTag", "shouldNotUpdate", "updateLifecycle", "updateText", "updateHTML", "updateFragment", "updateElement", "updateComponent", "removeDOM", "domSize", "updateAttrs", "key", "lisTemp", "result", "u", "il", "c", "target", "content", "tryBlockRemove", "source", "counter", "generation", "tryResumeRemove", "onremove", "setAttr", "value", "isLifecycleMethod", "isFormAttribute", "updateEvent", "updateStyle", "hasPropertyKey", "removeAttr", "nsLastIndex", "normalized", "val", "attr", "style", "EventDict", "ev", "handler", "self", "force", "currentDOM", "redraw", "prevRedraw", "prevDOM", "active", "namespace", "require_render", "__commonJSMin", "exports", "module", "require_mount_redraw", "__commonJSMin", "exports", "module", "Vnode", "render", "schedule", "console", "subscriptions", "pending", "offset", "sync", "redraw", "e", "mount", "root", "component", "index", "require_mount_redraw", "__commonJSMin", "exports", "module", "render", "require_build", "__commonJSMin", "exports", "module", "object", "args", "key", "destructure", "value", "i", "require_build", "__commonJSMin", "exports", "module", "buildQueryString", "template", "params", "queryIndex", "hashIndex", "queryEnd", "pathEnd", "path", "query", "resolved", "m", "key", "variadic", "newQueryIndex", "newHashIndex", "newQueryEnd", "newPathEnd", "result", "querystring", "require_request", "__commonJSMin", "exports", "module", "buildPathname", "hasOwn", "$window", "oncompletion", "PromiseProxy", "executor", "makeRequest", "url", "args", "resolve", "reject", "method", "body", "assumeJSON", "responseType", "xhr", "aborted", "isTimeout", "original", "replacedAbort", "abort", "hasHeader", "key", "ev", "success", "response", "message", "i", "completeErrorResponse", "error", "e", "name", "promise", "count", "complete", "wrap", "then", "next", "require_request", "__commonJSMin", "exports", "module", "mountRedraw", "require_decodeURIComponentSafe", "__commonJSMin", "exports", "module", "validUtf8Encodings", "str", "require_parse", "__commonJSMin", "exports", "module", "decodeURIComponentSafe", "string", "entries", "counters", "data", "entry", "key", "value", "levels", "cursor", "j", "level", "nextLevel", "isNumber", "desc", "require_parse", "__commonJSMin", "exports", "module", "parseQueryString", "url", "queryIndex", "hashIndex", "queryEnd", "pathEnd", "path", "require_compileTemplate", "__commonJSMin", "exports", "module", "parsePathname", "template", "templateData", "templateKeys", "keys", "regexp", "m", "key", "extra", "data", "i", "values", "require_censor", "__commonJSMin", "exports", "module", "hasOwn", "magic", "attrs", "extras", "result", "key", "require_router", "__commonJSMin", "exports", "module", "Vnode", "hyperscript", "decodeURIComponentSafe", "buildPathname", "parsePathname", "compileTemplate", "censor", "$window", "mountRedraw", "p", "scheduled", "ready", "hasBeenResolved", "dom", "compiled", "fallbackRoute", "currentResolver", "component", "attrs", "currentPath", "lastUpdate", "RouterRoot", "fireAsync", "vnode", "SKIP", "route", "resolveRoute", "prefix", "path", "data", "reject", "e", "loop", "i", "payload", "matchedRoute", "localComp", "update", "comp", "root", "defaultRoute", "routes", "defaultData", "options", "state", "title", "child", "onclick", "href", "result", "key", "require_route", "__commonJSMin", "exports", "module", "mountRedraw", "require_mithril", "__commonJSMin", "exports", "module", "hyperscript", "mountRedraw", "request", "router", "m", "import_mithril", "import_mithril", "import_mithril", "broadcast", "label", "detail", "listen", "callback", "block", "event", "navigate", "route", "BurgerMenu", "onclick", "_", "broadcast", "m", "HeaderBrandText", "BRAND_TEXT", "navigate", "RSSIcon", "SVG_PATH", "ThemeSwitch", "vnode", "text", "Header", "load", "IndexedSet", "_IndexedSet", "#idx", "#map", "#reverseMap", "value", "index", "idx", "newSet", "key", "TribbleParser", "line", "match", "src", "rel", "tgt", "id", "parseUrn", "urn", "delimited", "type", "remainder", "idx", "queryString", "id", "qs", "asUrn", "value", "namespace", "IndexPerformanceMetrics", "_IndexPerformanceMetrics", "clone", "hashTriple", "triple", "src", "rel", "tgt", "hashValue", "i", "Index", "_Index", "triples", "IndexedSet", "tripleHash", "tripleIndex", "metadata", "qsIdx", "hash", "jdx", "source", "relation", "target", "parsedSource", "parsedTarget", "sourceIdx", "targetIdx", "sourceTypeIdx", "sourceIdIdx", "targetTypeIdx", "targetIdIdx", "sourceQsIndices", "targetQsIndices", "sourceTypeSet", "sourceIdSet", "key", "val", "sourceQsSet", "relationSet", "targetTypeSet", "targetIdSet", "targetQsSet", "index", "indexedTriple", "typeIdx", "idIdx", "uniqueSourceIndices", "sources", "sourceStr", "uniqueTargetIndices", "targets", "targetStr", "newIndex", "cloneMap", "original", "newMap", "valueSet", "cloneRelationMap", "isUrn", "parseNodeSearch", "search", "subsearch", "parseRelation", "parseSearch", "out", "TribbleDB", "_TribbleDB", "validations", "objects", "obj", "relations", "sub", "messages", "validator", "res", "allTriples", "listOnly", "firstId", "relationName", "objs", "relationRef", "fnc", "seen", "result", "other", "opts", "matchingTriples", "sourceParsed", "urns", "results", "thing", "parser", "set1", "set2", "item", "params", "parsed", "candidateIndices", "relationNames", "relName", "ids", "sourceIds", "intersection", "targetIds", "tripleIdx", "sourceMatches", "sourceQuery", "targetMatches", "targetQuery", "queries", "position", "query", "queryMatches", "typeSet", "idUnion", "nodeId", "idSet", "qsKeys", "qsSets", "qsSet", "qsIntersection", "queryResult", "transformedTriples", "originalHashes", "transformedHashes", "transformedByHash", "triplesToDelete", "triplesToAdd", "streamTribbles", "url", "parser", "TribbleParser", "res", "decoder", "reader", "buffer", "tripleBuffer", "value", "done", "lines", "line", "triple", "tdb", "loadTriples", "schema", "perTriple", "x", "TribbleDB", "triples", "KnownRelations", "KnownTypes", "NonListableTypes", "PLURALS", "CDN_RELATIONS", "KnownRelations", "RelationSymmetries", "CURIES", "CURIE_REGEX", "ENDPOINT", "PLACE_FEATURES_TO_EMOJI", "CAMERA_MODELS", "PHONE_MODELS", "BinomialTypes", "KnownTypes", "expandCdnUrls", "triple", "src", "rel", "tgt", "CDN_RELATIONS", "candidate", "ENDPOINT", "expandUrns", "addYear", "tdb", "years", "KnownRelations", "_", "date", "year", "addInverseRelations", "triples", "to", "from", "RelationSymmetries", "results", "CURIE_CACHE", "expandCurie", "curies", "value", "cached", "CURIE_REGEX", "match", "prefix", "id", "result", "expandTripleCuries", "CURIES", "buildLocationTrees", "treeState", "nodes", "srcNode", "tgtNode", "HARD_CODED_TRIPLES", "deriveTriples", "tripleProcessors", "outputTriples", "fn", "nextStep", "postIndexing", "addNestedLocations", "recurse", "path", "urn", "node", "totalPath", "idx", "jdx", "parent", "nodeId", "logParseWarning", "issues", "message", "issue", "store$4", "getGlobalConfig", "config$1", "store$4", "store$3", "getGlobalMessage", "lang", "store$3", "store$2", "getSchemaMessage", "lang", "store$2", "store$1", "getSpecificMessage", "reference", "lang", "store$1", "_stringify", "input", "type", "_addIssue", "context", "label", "dataset", "config$1", "other", "expected", "received", "issue", "isSchema", "message$1", "getSpecificMessage", "getSchemaMessage", "getGlobalMessage", "_getStandardProps", "context", "value$1", "getGlobalConfig", "_joinExpects", "values$1", "separator", "list", "integer", "message$1", "dataset", "config$1", "_addIssue", "transform", "operation", "dataset", "url", "message$1", "input", "dataset", "config$1", "_addIssue", "getFallback", "schema", "dataset", "config$1", "getDefault", "schema", "dataset", "config$1", "any", "_getStandardProps", "dataset", "array", "item", "message$1", "config$1", "input", "key", "value$1", "itemDataset", "pathItem", "issue", "_addIssue", "number", "message$1", "_getStandardProps", "dataset", "config$1", "_addIssue", "object", "entries$1", "input", "key", "valueSchema", "value$1", "getDefault", "valueDataset", "pathItem", "issue", "getFallback", "optional", "wrapped", "default_", "_getStandardProps", "dataset", "config$1", "getDefault", "string", "message$1", "_getStandardProps", "dataset", "config$1", "_addIssue", "_subIssues", "datasets", "issues", "dataset", "union", "options", "message$1", "_joinExpects", "option", "_getStandardProps", "config$1", "validDataset", "typedDatasets", "untypedDatasets", "schema", "optionDataset", "_addIssue", "pipe", "pipe$1", "_getStandardProps", "dataset", "config$1", "item", "safeParse", "schema", "input", "config$1", "dataset", "getGlobalConfig", "import_mithril", "import_mithril", "arrayify", "value", "one", "placeEmoji", "thing", "feature", "one", "featureId", "asUrn", "PLACE_FEATURES_TO_EMOJI", "placeFeatureEmoji", "featureUrn", "countryEmoji", "birdEmoji", "cameraEmoji", "id", "CAMERA_MODELS", "PHONE_MODELS", "thingEmoji", "urn", "_", "type", "KnownTypes", "ThingLink", "vnode", "urn", "thing", "type", "id", "asUrn", "name", "candidate", "one", "emoji", "thingEmoji", "m", "navigate", "readThing", "tdb", "urn", "id", "type", "asUrn", "readParsedThing", "parser", "thing", "readThings", "urns", "things", "readParsedThings", "parsedThings", "parsed", "readNamedTypeThings", "thinga", "thingb", "firstName", "secondName", "first", "one", "second", "toThingLinks", "m", "ThingLink", "parseObject", "schema", "type", "_", "object", "result", "safeParse", "logParseWarning", "parseByType", "typeParsers", "tdb", "thing", "asUrn", "one", "parser", "readOne", "id", "readParsedThing", "readMany", "urns", "readParsedThings", "readers", "v", "string", "array", "object", "optional", "union", "any", "pipe", "url", "integer", "number", "transform", "AlbumSchema", "CountrySchema", "UnescoSchema", "PlaceSchema", "PhotoSchema", "MammalSchema", "ReptileSchema", "FishSchema", "AmphibianSchema", "InsectSchema", "SubjectSchema", "BirdSchema", "VideoSchema", "StatsSchema", "FeatureSchema", "parseFeature", "parseObject", "FeatureSchema", "parseCountry", "CountrySchema", "parseUnesco", "UnescoSchema", "parsePhoto", "PhotoSchema", "parseBird", "BirdSchema", "parseMammal", "MammalSchema", "parseReptile", "ReptileSchema", "parseAmphibian", "AmphibianSchema", "parseInsect", "InsectSchema", "parseFish", "FishSchema", "parseVideo", "VideoSchema", "parsePlace", "PlaceSchema", "parseAlbum", "AlbumSchema", "parseSubject", "parseByType", "KnownTypes", "parseLocation", "parseStats", "stats", "safeParse", "StatsSchema", "readCountry", "readCountries", "readers", "parseCountry", "readPlace", "readPlaces", "parsePlace", "readLocation", "readLocations", "parseLocation", "readUnesco", "readUnescos", "parseUnesco", "readAlbum", "readAlbums", "parseAlbum", "readMammal", "readMammals", "parseMammal", "readReptile", "readReptiles", "parseReptile", "readInsect", "readInsects", "parseInsect", "readFish", "readFishes", "parseFish", "readSubject", "readSubjects", "parseSubject", "readAmphibian", "readAmphibians", "parseAmphibian", "readVideo", "readVideos", "parseVideo", "readPhoto", "readPhotos", "parsePhoto", "readFeature", "readFeatures", "parseFeature", "loadingMode", "idx", "viewportWidth", "viewportHeight", "imageDimension", "maxImagesPerRow", "maxRowsInFold", "COLOURS_CACHE", "encodeBitmapDataURL", "colours", "coloursList", "colour", "canvas", "ctx", "readAllPhotos", "tdb", "photos", "readPhotos", "photoa", "photob", "readThingsByPhotoIds", "photoIds", "locations", "subjects", "photoId", "pid", "asUrn", "obj", "KnownRelations", "location", "subject", "loc", "subj", "readSubjects", "readLocations", "readPhotosByThingIds", "thingsUrns", "thingUrn", "type", "id", "results", "result", "readThingCover", "source", "readPhoto", "sortByRating", "ratingA", "chooseThingCover", "cover", "albumYear", "album", "readAllAlbums", "tdb", "ids", "KnownTypes", "readAlbums", "album0", "album1", "readAlbumPhotoIds", "id", "KnownRelations", "asUrn", "readAlbumPhotosByAlbumId", "readPhotos", "readAlbumVideoIds", "readAlbumVideosByAlbumId", "readVideos", "readThingsByAlbumId", "readThingsByPhotoIds", "readAlbumsByThingIds", "thingsUrns", "photoIds", "thingUrn", "type", "results", "result", "albumIds", "photoId", "pid", "albums", "NAME_TO_URN_CACHE", "namesToUrns", "tdb", "names", "urns", "name", "cachedUrn", "namesCursor", "KnownRelations", "urn", "_", "loadData", "schema", "tdb", "loadTriples", "deriveTriples", "postIndexing", "HARD_CODED_TRIPLES", "loadServices", "readAlbum", "readCountry", "readPlace", "readPhoto", "readMammal", "readReptile", "readAmphibian", "readInsect", "readVideo", "readLocation", "readUnesco", "readLocations", "readFeatures", "readPhotos", "readUnescos", "readThings", "readCountries", "namesToUrns", "chooseThingCover", "readPhotosByThingIds", "readAlbumsByThingIds", "toThingLinks", "loadState", "data", "load", "import_mithril", "SidebarItem", "vnode", "m", "navigate", "Sidebar", "classes", "visible", "cls", "import_mithril", "import_mithril", "AlbumStats", "stats", "parseStats", "m", "import_mithril", "isSmallerThan", "width", "setTitle", "title", "PhotoAlbumMetadata", "vnode", "title", "minDate", "maxDate", "count", "countryLinks", "dateRange", "shortDateRange", "text", "dateRangeText", "isSmallerThan", "m", "import_mithril", "import_mithril", "import_mithril", "InfoSVG", "vnode", "colour", "m", "MetadataIcon", "id", "broadcast", "loadImage", "url", "event", "broadcast", "$placeholder", "Image", "vnode", "thumbnailUrl", "loading", "onclick", "m", "PlaceholderImage", "thumbnailDataUrl", "ImagePair", "imageUrl", "formatId", "id", "parseUrn", "Photo", "photo", "interactive", "fullImage", "mosaicColours", "encodeBitmapDataURL", "$mdIcon", "MetadataIcon", "$imagePair", "block", "TRIPS", "TripTag", "vnode", "trip", "tripIndex", "m", "PhotoAlbum", "imageUrl", "thumbnailUrl", "thumbnailDataUrl", "loading", "child", "minDate", "onclick", "ImagePair", "import_mithril", "urnToUrl", "urn", "type", "id", "asUrn", "CountryLink", "vnode", "country", "mode", "id", "name", "m", "flag", "countryEmoji", "parsed", "asUrn", "onclick", "navigate", "urnToUrl", "setify", "value", "setOf", "property", "objects", "result", "obj", "elem", "onAlbumClick", "id", "title", "event", "parsed", "asUrn", "broadcast", "block", "drawAlbum", "state", "album", "idx", "services", "loading", "loadingMode", "$albumComponents", "albumYear", "$h2", "m", "$countryLinks", "setify", "country", "CountryLink", "$md", "PhotoAlbumMetadata", "$album", "PhotoAlbum", "encodeBitmapDataURL", "AlbumsList", "vnode", "albums", "AlbumsPage", "setTitle", "visible", "AlbumStats", "import_mithril", "AboutPage", "setTitle", "vnode", "visible", "years", "m", "navigate", "import_mithril", "import_mithril", "Video", "vnode", "preload", "video", "m", "posterUrl", "videoUrl1080p", "videoUrl480p", "videoUrl720p", "videoUrlUnscaled", "$source", "$resolutionLinks", "VideosPage", "vnode", "videos", "visible", "videoLengthText", "$videosList", "video", "m", "Video", "readAllVideos", "tdb", "videos", "readVideos", "import_mithril", "formatCreatedAt", "dateTime", "date", "options", "import_mithril", "handleError", "message", "shareAlbum", "state", "url", "name", "error", "buttonText", "AlbumShareButton", "localState", "vnode", "m", "import_mithril", "AlbumsButton", "m", "navigate", "capitalise", "str", "pluralise", "PLURALS", "binomial", "pretty", "capitalise", "preprocessDescription", "description", "AlbumPage", "setTitle", "vnode", "album", "photos", "videos", "services", "visible", "name", "minDate", "maxDate", "photosCount", "description", "country", "dateRange", "shortDateRange", "dateRangeText", "isSmallerThan", "photoCountMessage", "$countryLinks", "setify", "m", "CountryLink", "id", "asUrn", "url", "$albumMetadata", "preprocessDescription", "AlbumShareButton", "AlbumsButton", "$photosList", "photo", "idx", "Photo", "loadingMode", "$videosList", "video", "Video", "import_mithril", "PhotosList", "vnode", "photos", "m", "photo", "idx", "loading", "loadingMode", "Photo", "PhotosPage", "visible", "countText", "$md", "import_mithril", "import_mithril", "AlbumButton", "vnode", "id", "m", "navigate", "import_mithril", "Heading", "vnode", "text", "m", "CameraModel", "photo", "services", "$model", "ExifDimensions", "FocalLength", "ShutterSpeed", "exposureTime", "parsed", "Aperture", "ExifData", "$dateTime", "formatCreatedAt", "$dimensions", "$focalLength", "$shutterSpeed", "$aperture", "$iso", "import_mithril", "Heading", "vnode", "text", "m", "Description", "photo", "html", "preprocessDescription", "Location", "services", "$locations", "arrayify", "Rating", "$rating", "Style", "$style", "Subject", "$subject", "Country", "$countries", "PhotoInfo", "infoItems", "PhotoPage", "vnode", "photo", "services", "visible", "$links", "m", "AlbumButton", "$exif", "ExifData", "$photoInfo", "PhotoInfo", "Photo", "import_mithril", "import_mithril", "import_mithril", "import_mithril", "ExternalLink", "vnode", "href", "text", "m", "ThingUrls", "vnode", "things", "m", "thing", "$links", "wikipedia", "one", "ExternalLink", "birdwatch", "ThingMetadata", "animals", "KnownTypes", "vnode", "thing", "type", "asUrn", "one", "$links", "m", "ThingUrls", "title", "countryEmoji", "drawThingAlbum", "services", "thing", "idx", "id", "one", "coverPhoto", "$md", "m", "ThingMetadata", "thingId", "type", "asUrn", "PhotoAlbum", "encodeBitmapDataURL", "loadingMode", "navigate", "AlbumsList", "vnode", "things", "$albumComponents", "ListingTitle", "capitalise", "pluralise", "ListingThingsButton", "ListingPage", "visible", "NonListableTypes", "import_mithril", "ListingItem", "vnode", "m", "navigate", "ListingsPage", "visible", "import_mithril", "import_mithril", "computeTitle", "urn", "things", "parsed", "parseUrn", "capitalise", "pluralise", "thing", "name", "one", "KnownTypes", "countryEmoji", "placeEmoji", "ThingTitle", "vnode", "title", "setTitle", "m", "ThingSubtitle", "asUrn", "BinomialTypes", "binomial", "import_mithril", "PlacesList", "vnode", "urns", "services", "$places", "loca", "locb", "one", "location", "$link", "m", "ThingLink", "import_mithril", "onListingClick", "type", "event", "broadcast", "block", "ListingLink", "vnode", "asUrn", "m", "capitalise", "import_mithril", "import_mithril", "FeatureLink", "vnode", "urn", "thing", "type", "id", "asUrn", "name", "one", "text", "thingEmoji", "m", "FeaturesList", "vnode", "urns", "services", "$features", "feature", "id", "one", "m", "FeatureLink", "import_mithril", "import_mithril", "UnescoLink", "vnode", "urn", "thing", "type", "id", "asUrn", "name", "one", "m", "UnescoList", "vnode", "urns", "services", "$unescos", "unesco", "urn", "one", "m", "UnescoLink", "ThingMetadata", "vnode", "metadata", "urn", "things", "services", "m", "ListingLink", "locatedIn", "setOf", "KnownRelations", "PlacesList", "thing", "FeaturesList", "setify", "UnescoList", "arrayify", "$rows", "key", "value", "onAlbumClick", "id", "title", "event", "parsed", "asUrn", "broadcast", "block", "AlbumSection", "urns", "$albums", "album", "$countryLinks", "country", "CountryLink", "$md", "PhotoAlbumMetadata", "$album", "PhotoAlbum", "encodeBitmapDataURL", "PhotoSection", "photos", "photo", "idx", "loading", "loadingMode", "Photo", "ThingPage", "visible", "ThingTitle", "ThingSubtitle", "ThingUrls", "state", "loadState", "listen", "event", "route", "m", "AlbumsApp", "Header", "Sidebar", "AlbumsPage", "readAllAlbums", "AlbumApp", "id", "album", "readAlbum", "photos", "readAlbumPhotosByAlbumId", "videos", "readAlbumVideosByAlbumId", "subjects", "locations", "readThingsByAlbumId", "AlbumPage", "AboutApp", "AboutPage", "VideosApp", "VideosPage", "readAllVideos", "PhotosApp", "PhotosPage", "readAllPhotos", "ThingApp", "things", "pair", "asUrn", "readNamedTypeThings", "thing", "readThing", "ThingPage", "PhotoApp", "photo", "readPhoto", "PhotoPage", "ListingApp", "type", "ListingPage", "ListingsApp", "ListingsPage", "m", "AlbumsApp", "AboutApp", "VideosApp", "PhotosApp", "AlbumApp", "ThingApp", "PhotoApp", "ListingApp", "ListingsApp"]
}
