{
  "version": 3,
  "sources": ["../../sw.js"],
  "sourcesContent": ["const CACHE_NAME = \"sw-cache\";\nconst CACHEABLE_RESOURCES = [\n  \"/icons/android-chrome-192x192.png\",\n  \"/icons/android-chrome-512x512.png\",\n  \"/icons/apple-touch-icon.png\",\n  \"/icons/favicon-16x16.png\",\n  \"/icons/favicon-32x32.png\",\n  \"/favicon.ico\",\n  \"/favicon-32x32.png\",\n  // removed the font, it seemed to do something weird here\n];\n\n// -- let's not cache list of images / albums here. Our CDN will cache them for us,\n// -- and we'll attach them to the window so they'll persist within a page load but not reloads.\nconst UNCACHEABLE_RESOURCES = [];\n\nself.addEventListener(\"install\", function (event) {\n  // -- on install, cache every cacheable resource explicity listed.\n\n  event.waitUntil(\n    caches.open(CACHE_NAME).then(function (cache) {\n      return Promise.all(\n        CACHEABLE_RESOURCES.map((resource) => cache.add(resource)),\n      );\n    }),\n  );\n});\n\nfunction isCacheable(url) {\n  /*\n   * We can cache fonts\n   */\n  if (url.includes(\".woff2\")) {\n    return true;\n  }\n\n  const manifestEntries = [\n    \"tribbles\",\n  ];\n\n  /*\n   * We can cache tribbles (main data source), as it has a publication ID to cache-bust between versions\n   */\n  for (const entry of manifestEntries) {\n    if (url.includes(`/manifest/${entry}`)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nself.addEventListener(\"fetch\", function (event) {\n  const url = event.request.url;\n\n  // -- do nothing for uncacheable resources\n  for (const resource of UNCACHEABLE_RESOURCES) {\n    if (url.includes(resource)) {\n      return;\n    }\n  }\n\n  event.respondWith(\n    caches.match(event.request).then(function (response) {\n      if (response) {\n        return response;\n      }\n\n      return fetch(event.request)\n        .then(function (networkResponse) {\n          // -- just return the result directly\n          if (!isCacheable(url)) {\n            return networkResponse;\n          }\n\n          // -- cache thumbnails and artifacts\n          return caches.open(CACHE_NAME).then(function (cache) {\n            cache.put(event.request, networkResponse.clone());\n            return networkResponse;\n          });\n        }).catch((err) => {\n          console.error(err);\n        });\n    }),\n  );\n});\n"],
  "mappings": "AAAA,IAAMA,EAAa,WACbC,EAAsB,CAC1B,oCACA,oCACA,8BACA,2BACA,2BACA,eACA,oBAEF,EAIMC,EAAwB,CAAC,EAE/B,KAAK,iBAAiB,UAAW,SAAUC,EAAO,CAGhDA,EAAM,UACJ,OAAO,KAAKH,CAAU,EAAE,KAAK,SAAUI,EAAO,CAC5C,OAAO,QAAQ,IACbH,EAAoB,IAAKI,GAAaD,EAAM,IAAIC,CAAQ,CAAC,CAC3D,CACF,CAAC,CACH,CACF,CAAC,EAED,SAASC,EAAYC,EAAK,CAIxB,GAAIA,EAAI,SAAS,QAAQ,EACvB,MAAO,GAGT,IAAMC,EAAkB,CACtB,UACF,EAKA,QAAWC,KAASD,EAClB,GAAID,EAAI,SAAS,aAAaE,CAAK,EAAE,EACnC,MAAO,GAIX,MAAO,EACT,CAEA,KAAK,iBAAiB,QAAS,SAAUN,EAAO,CAC9C,IAAMI,EAAMJ,EAAM,QAAQ,IAG1B,QAAWE,KAAYH,EACrB,GAAIK,EAAI,SAASF,CAAQ,EACvB,OAIJF,EAAM,YACJ,OAAO,MAAMA,EAAM,OAAO,EAAE,KAAK,SAAUO,EAAU,CACnD,OAAIA,GAIG,MAAMP,EAAM,OAAO,EACvB,KAAK,SAAUQ,EAAiB,CAE/B,OAAKL,EAAYC,CAAG,EAKb,OAAO,KAAKP,CAAU,EAAE,KAAK,SAAUI,EAAO,CACnD,OAAAA,EAAM,IAAID,EAAM,QAASQ,EAAgB,MAAM,CAAC,EACzCA,CACT,CAAC,EAPQA,CAQX,CAAC,EAAE,MAAOC,GAAQ,CAChB,QAAQ,MAAMA,CAAG,CACnB,CAAC,CACL,CAAC,CACH,CACF,CAAC",
  "names": ["CACHE_NAME", "CACHEABLE_RESOURCES", "UNCACHEABLE_RESOURCES", "event", "cache", "resource", "isCacheable", "url", "manifestEntries", "entry", "response", "networkResponse", "err"]
}
