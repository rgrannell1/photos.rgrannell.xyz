{
  "version": 3,
  "sources": ["../../node_modules/mithril/render/vnode.js", "../../node_modules/mithril/render/hyperscriptVnode.js", "../../node_modules/mithril/util/hasOwn.js", "../../node_modules/mithril/render/emptyAttrs.js", "../../node_modules/mithril/render/cachedAttrsIsStaticMap.js", "../../node_modules/mithril/render/hyperscript.js", "../../node_modules/mithril/render/trust.js", "../../node_modules/mithril/render/fragment.js", "../../node_modules/mithril/hyperscript.js", "../../node_modules/mithril/render/domFor.js", "../../node_modules/mithril/render/render.js", "../../node_modules/mithril/render.js", "../../node_modules/mithril/api/mount-redraw.js", "../../node_modules/mithril/mount-redraw.js", "../../node_modules/mithril/querystring/build.js", "../../node_modules/mithril/pathname/build.js", "../../node_modules/mithril/request/request.js", "../../node_modules/mithril/request.js", "../../node_modules/mithril/querystring/parse.js", "../../node_modules/mithril/pathname/parse.js", "../../node_modules/mithril/pathname/compileTemplate.js", "../../node_modules/mithril/util/censor.js", "../../node_modules/mithril/api/router.js", "../../node_modules/mithril/route.js", "../../node_modules/mithril/index.js", "../../ts/index.ts", "../../ts/app.ts", "../../ts/components/header.ts", "../../ts/commons/events.ts", "../../ts/services/dark-mode.ts", "../../node_modules/@rgrannell1/tribbledb/dist/mod.js", "../../ts/semantic/data.ts", "../../ts/constants.ts", "../../ts/commons/strings.ts", "../../ts/semantic/derive.ts", "../../ts/commons/logger.ts", "../../node_modules/valibot/dist/index.mjs", "../../ts/commons/things.ts", "../../ts/components/thing-link.ts", "../../ts/commons/arrays.ts", "../../ts/services/emoji.ts", "../../ts/commons/parser.ts", "../../ts/schemas.ts", "../../ts/services/parsers.ts", "../../ts/services/readers.ts", "../../ts/services/photos.ts", "../../ts/services/albums.ts", "../../ts/services/names.ts", "../../ts/state.ts", "../../ts/components/sidebar.ts", "../../ts/pages/albums.ts", "../../ts/components/album-stats.ts", "../../ts/components/photo-album-metadata.ts", "../../ts/services/window.ts", "../../ts/services/dates.ts", "../../ts/components/photo-album.ts", "../../ts/components/photo.ts", "../../ts/components/metadata-icon.ts", "../../ts/components/place-links.ts", "../../ts/models/urn.ts", "../../ts/commons/sets.ts", "../../ts/pages/about.ts", "../../ts/pages/videos.ts", "../../ts/components/video.ts", "../../ts/services/videos.ts", "../../ts/pages/album.ts", "../../ts/components/album-share-button.ts", "../../ts/components/albums-button.ts", "../../ts/pages/photos.ts", "../../ts/pages/photo.ts", "../../ts/components/album-button.ts", "../../ts/components/exif-data.ts", "../../ts/components/photo-info.ts", "../../ts/pages/listing.ts", "../../ts/components/thing-metadata.ts", "../../ts/components/thing-urls.ts", "../../ts/components/external-link.ts", "../../ts/pages/listings.ts", "../../ts/pages/thing.ts", "../../ts/components/thing-title.ts", "../../ts/components/places-list.ts", "../../ts/components/listing-link.ts", "../../ts/components/features-list.ts", "../../ts/components/feature-link.ts", "../../ts/components/unesco-list.ts", "../../ts/components/unesco-link.ts"],
  "sourcesContent": ["\"use strict\"\n\nfunction Vnode(tag, key, attrs, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, is: undefined, domSize: undefined, state: undefined, events: undefined, instance: undefined}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node == null || typeof node === \"boolean\") return null\n\tif (typeof node === \"object\") return node\n\treturn Vnode(\"#\", undefined, undefined, String(node), undefined, undefined)\n}\nVnode.normalizeChildren = function(input) {\n\tvar children = []\n\tif (input.length) {\n\t\tvar isKeyed = input[0] != null && input[0].key != null\n\t\t// Note: this is a *very* perf-sensitive check.\n\t\t// Fun fact: merging the loop like this is somehow faster than splitting\n\t\t// it, noticeably so.\n\t\tfor (var i = 1; i < input.length; i++) {\n\t\t\tif ((input[i] != null && input[i].key != null) !== isKeyed) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\tisKeyed && (input[i] == null || typeof input[i] === \"boolean\")\n\t\t\t\t\t\t? \"In fragments, vnodes must either all have keys or none have keys. You may wish to consider using an explicit keyed empty fragment, m.fragment({key: ...}), instead of a hole.\"\n\t\t\t\t\t\t: \"In fragments, vnodes must either all have keys or none have keys.\"\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0; i < input.length; i++) {\n\t\t\tchildren[i] = Vnode.normalize(input[i])\n\t\t}\n\t}\n\treturn children\n}\n\nmodule.exports = Vnode\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\n\n// Note: the processing of variadic parameters is perf-sensitive.\n//\n// In native ES6, it might be preferable to define hyperscript and fragment\n// factories with a final ...args parameter and call hyperscriptVnode(...args),\n// since modern engines can optimize spread calls.\n//\n// However, benchmarks showed this was not faster. As a result, spread is used\n// only in the parameter lists of hyperscript and fragment, while an array is\n// passed to hyperscriptVnode.\nmodule.exports = function(attrs, children) {\n\tif (attrs == null || typeof attrs === \"object\" && attrs.tag == null && !Array.isArray(attrs)) {\n\t\tif (children.length === 1 && Array.isArray(children[0])) children = children[0]\n\t} else {\n\t\tchildren = children.length === 0 && Array.isArray(attrs) ? attrs : [attrs, ...children]\n\t\tattrs = undefined\n\t}\n\n\treturn Vnode(\"\", attrs && attrs.key, attrs, children)\n}\n", "// This exists so I'm only saving it once.\n\"use strict\"\n\nmodule.exports = {}.hasOwnProperty\n", "\"use strict\"\n\n// This is an attrs object that is used by default when attrs is undefined or null.\nmodule.exports = {}\n", "\"use strict\"\n\nvar emptyAttrs = require(\"./emptyAttrs\")\n\n// This Map manages the following:\n// - Whether an attrs is cached attrs generated by compileSelector().\n// - Whether the cached attrs is \"static\", i.e., does not contain any form attributes.\n// These information will be useful to skip updating attrs in render().\n//\n// Since the attrs used as keys in this map are not released from the selectorCache object,\n// there is no risk of memory leaks. Therefore, Map is used here instead of WeakMap.\nmodule.exports = new Map([[emptyAttrs, true]])\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\nvar hyperscriptVnode = require(\"./hyperscriptVnode\")\nvar hasOwn = require(\"../util/hasOwn\")\nvar emptyAttrs = require(\"./emptyAttrs\")\nvar cachedAttrsIsStaticMap = require(\"./cachedAttrsIsStaticMap\")\n\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = Object.create(null)\n\nfunction isEmpty(object) {\n\tfor (var key in object) if (hasOwn.call(object, key)) return false\n\treturn true\n}\n\nfunction isFormAttributeKey(key) {\n\treturn key === \"value\" || key === \"checked\" || key === \"selectedIndex\" || key === \"selected\"\n}\n\nfunction compileSelector(selector) {\n\tvar match, tag = \"div\", classes = [], attrs = {}, isStatic = true\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") tag = value\n\t\telse if (type === \"#\") attrs.id = value\n\t\telse if (type === \".\") classes.push(value)\n\t\telse if (match[3][0] === \"[\") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\")\n\t\t\tif (match[4] === \"class\") classes.push(attrValue)\n\t\t\telse {\n\t\t\t\tattrs[match[4]] = attrValue === \"\" ? attrValue : attrValue || true\n\t\t\t\tif (isFormAttributeKey(match[4])) isStatic = false\n\t\t\t}\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(\" \")\n\tif (isEmpty(attrs)) attrs = emptyAttrs\n\telse cachedAttrsIsStaticMap.set(attrs, isStatic)\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs, is: attrs.is}\n}\n\nfunction execSelector(state, vnode) {\n\tvnode.tag = state.tag\n\n\tvar attrs = vnode.attrs\n\tif (attrs == null) {\n\t\tvnode.attrs = state.attrs\n\t\tvnode.is = state.is\n\t\treturn vnode\n\t}\n\n\tvar hasClass = hasOwn.call(attrs, \"class\")\n\tvar className = hasClass ? attrs.class : attrs.className\n\n\tif (state.attrs !== emptyAttrs) {\n\t\tattrs = Object.assign({}, state.attrs, attrs)\n\n\t\tif (className != null || state.attrs.className != null) attrs.className =\n\t\t\tclassName != null\n\t\t\t\t? state.attrs.className != null\n\t\t\t\t\t? String(state.attrs.className) + \" \" + String(className)\n\t\t\t\t\t: className\n\t\t\t\t: state.attrs.className\n\t} else {\n\t\tif (className != null) attrs.className = className\n\t}\n\n\tif (hasClass) attrs.class = null\n\n\t// workaround for #2622 (reorder keys in attrs to set \"type\" first)\n\t// The DOM does things to inputs based on the \"type\", so it needs set first.\n\t// See: https://github.com/MithrilJS/mithril.js/issues/2622\n\tif (state.tag === \"input\" && hasOwn.call(attrs, \"type\")) {\n\t\tattrs = Object.assign({type: attrs.type}, attrs)\n\t}\n\n\t// This reduces the complexity of the evaluation of \"is\" within the render function.\n\tvnode.is = attrs.is\n\n\tvnode.attrs = attrs\n\n\treturn vnode\n}\n\nfunction hyperscript(selector, attrs, ...children) {\n\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t}\n\n\tvar vnode = hyperscriptVnode(attrs, children)\n\n\tif (typeof selector === \"string\") {\n\t\tvnode.children = Vnode.normalizeChildren(vnode.children)\n\t\tif (selector !== \"[\") return execSelector(selectorCache[selector] || compileSelector(selector), vnode)\n\t}\n\n\tif (vnode.attrs == null) vnode.attrs = {}\n\tvnode.tag = selector\n\treturn vnode\n}\n\nmodule.exports = hyperscript\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\n\nmodule.exports = function(html) {\n\tif (html == null) html = \"\"\n\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined)\n}\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\nvar hyperscriptVnode = require(\"./hyperscriptVnode\")\n\nmodule.exports = function(attrs, ...children) {\n\tvar vnode = hyperscriptVnode(attrs, children)\n\n\tif (vnode.attrs == null) vnode.attrs = {}\n\tvnode.tag = \"[\"\n\tvnode.children = Vnode.normalizeChildren(vnode.children)\n\treturn vnode\n}\n", "\"use strict\"\n\nvar hyperscript = require(\"./render/hyperscript\")\n\nhyperscript.trust = require(\"./render/trust\")\nhyperscript.fragment = require(\"./render/fragment\")\n\nmodule.exports = hyperscript\n", "\"use strict\"\n\nvar delayedRemoval = new WeakMap\n\nfunction *domFor(vnode) {\n\t// To avoid unintended mangling of the internal bundler,\n\t// parameter destructuring is not used here.\n\tvar dom = vnode.dom\n\tvar domSize = vnode.domSize\n\tvar generation = delayedRemoval.get(dom)\n\tif (dom != null) do {\n\t\tvar nextSibling = dom.nextSibling\n\n\t\tif (delayedRemoval.get(dom) === generation) {\n\t\t\tyield dom\n\t\t\tdomSize--\n\t\t}\n\n\t\tdom = nextSibling\n\t}\n\twhile (domSize)\n}\n\nmodule.exports = {\n\tdelayedRemoval: delayedRemoval,\n\tdomFor: domFor,\n}\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\nvar df = require(\"../render/domFor\")\nvar delayedRemoval = df.delayedRemoval\nvar domFor = df.domFor\nvar cachedAttrsIsStaticMap = require(\"./cachedAttrsIsStaticMap\")\n\nmodule.exports = function() {\n\tvar nameSpace = {\n\t\tsvg: \"http://www.w3.org/2000/svg\",\n\t\tmath: \"http://www.w3.org/1998/Math/MathML\"\n\t}\n\n\tvar currentRedraw\n\tvar currentRender\n\n\tfunction getDocument(dom) {\n\t\treturn dom.ownerDocument;\n\t}\n\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\n\t//sanity check to discourage people from doing `vnode.state = ...`\n\tfunction checkState(vnode, original) {\n\t\tif (vnode.state !== original) throw new Error(\"'vnode.state' must not be modified.\")\n\t}\n\n\t//Note: the hook is passed as the `this` argument to allow proxying the\n\t//arguments without requiring a full array allocation to do so. It also\n\t//takes advantage of the fact the current `vnode` is the first argument in\n\t//all lifecycle methods.\n\tfunction callHook(vnode) {\n\t\tvar original = vnode.state\n\t\ttry {\n\t\t\treturn this.apply(original, arguments)\n\t\t} finally {\n\t\t\tcheckState(vnode, original)\n\t\t}\n\t}\n\n\t// IE11 (at least) throws an UnspecifiedError when accessing document.activeElement when\n\t// inside an iframe. Catch and swallow this error, and heavy-handidly return null.\n\tfunction activeElement(dom) {\n\t\ttry {\n\t\t\treturn getDocument(dom).activeElement\n\t\t} catch (e) {\n\t\t\treturn null\n\t\t}\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === \"string\") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase \"#\": createText(parent, vnode, nextSibling); break\n\t\t\t\tcase \"<\": createHTML(parent, vnode, ns, nextSibling); break\n\t\t\t\tcase \"[\": createFragment(parent, vnode, hooks, ns, nextSibling); break\n\t\t\t\tdefault: createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = getDocument(parent).createTextNode(vnode.children)\n\t\tinsertDOM(parent, vnode.dom, nextSibling)\n\t}\n\tvar possibleParents = {caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\"}\n\tfunction createHTML(parent, vnode, ns, nextSibling) {\n\t\tvar match = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\t// not using the proper parent makes the child element(s) vanish.\n\t\t//     var div = document.createElement(\"div\")\n\t\t//     div.innerHTML = \"<td>i</td><td>j</td>\"\n\t\t//     console.log(div.innerHTML)\n\t\t// --> \"ij\", no <td> in sight.\n\t\tvar temp = getDocument(parent).createElement(possibleParents[match[1]] || \"div\")\n\t\tif (ns === \"http://www.w3.org/2000/svg\") {\n\t\t\ttemp.innerHTML = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\">\" + vnode.children + \"</svg>\"\n\t\t\ttemp = temp.firstChild\n\t\t} else {\n\t\t\ttemp.innerHTML = vnode.children\n\t\t}\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\t// Capture nodes to remove, so we don't confuse them.\n\t\tvar fragment = getDocument(parent).createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertDOM(parent, fragment, nextSibling)\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = getDocument(parent).createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertDOM(parent, fragment, nextSibling)\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs = vnode.attrs\n\t\tvar is = vnode.is\n\n\t\tns = getNameSpace(vnode) || ns\n\n\t\tvar element = ns ?\n\t\t\tis ? getDocument(parent).createElementNS(ns, tag, {is: is}) : getDocument(parent).createElementNS(ns, tag) :\n\t\t\tis ? getDocument(parent).createElement(tag, {is: is}) : getDocument(parent).createElement(tag)\n\t\tvnode.dom = element\n\n\t\tif (attrs != null) {\n\t\t\tsetAttrs(vnode, attrs, ns)\n\t\t}\n\n\t\tinsertDOM(parent, element, nextSibling)\n\n\t\tif (!maybeSetContentEditable(vnode)) {\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tif (vnode.tag === \"select\" && attrs != null) setLateSelectAttrs(vnode, attrs)\n\t\t\t}\n\t\t}\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === \"function\") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === \"function\") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tinitLifecycle(vnode.state, vnode, hooks)\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tcreateNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t}\n\t}\n\n\t//update\n\t/**\n\t * @param {Element|Fragment} parent - the parent element\n\t * @param {Vnode[] | null} old - the list of vnodes of the last `render()` call for\n\t *                               this part of the tree\n\t * @param {Vnode[] | null} vnodes - as above, but for the current `render()` call.\n\t * @param {Function[]} hooks - an accumulator of post-render hooks (oncreate/onupdate)\n\t * @param {Element | null} nextSibling - the next DOM node if we're dealing with a\n\t *                                       fragment that is not the last item in its\n\t *                                       parent\n\t * @param {'svg' | 'math' | String | null} ns) - the current XML namespace, if any\n\t * @returns void\n\t */\n\t// This function diffs and patches lists of vnodes, both keyed and unkeyed.\n\t//\n\t// We will:\n\t//\n\t// 1. describe its general structure\n\t// 2. focus on the diff algorithm optimizations\n\t// 3. discuss DOM node operations.\n\n\t// ## Overview:\n\t//\n\t// The updateNodes() function:\n\t// - deals with trivial cases\n\t// - determines whether the lists are keyed or unkeyed based on the first non-null node\n\t//   of each list.\n\t// - diffs them and patches the DOM if needed (that's the brunt of the code)\n\t// - manages the leftovers: after diffing, are there:\n\t//   - old nodes left to remove?\n\t// \t - new nodes to insert?\n\t// \t deal with them!\n\t//\n\t// The lists are only iterated over once, with an exception for the nodes in `old` that\n\t// are visited in the fourth part of the diff and in the `removeNodes` loop.\n\n\t// ## Diffing\n\t//\n\t// Reading https://github.com/localvoid/ivi/blob/ddc09d06abaef45248e6133f7040d00d3c6be853/packages/ivi/src/vdom/implementation.ts#L617-L837\n\t// may be good for context on longest increasing subsequence-based logic for moving nodes.\n\t//\n\t// In order to diff keyed lists, one has to\n\t//\n\t// 1) match nodes in both lists, per key, and update them accordingly\n\t// 2) create the nodes present in the new list, but absent in the old one\n\t// 3) remove the nodes present in the old list, but absent in the new one\n\t// 4) figure out what nodes in 1) to move in order to minimize the DOM operations.\n\t//\n\t// To achieve 1) one can create a dictionary of keys => index (for the old list), then iterate\n\t// over the new list and for each new vnode, find the corresponding vnode in the old list using\n\t// the map.\n\t// 2) is achieved in the same step: if a new node has no corresponding entry in the map, it is new\n\t// and must be created.\n\t// For the removals, we actually remove the nodes that have been updated from the old list.\n\t// The nodes that remain in that list after 1) and 2) have been performed can be safely removed.\n\t// The fourth step is a bit more complex and relies on the longest increasing subsequence (LIS)\n\t// algorithm.\n\t//\n\t// the longest increasing subsequence is the list of nodes that can remain in place. Imagine going\n\t// from `1,2,3,4,5` to `4,5,1,2,3` where the numbers are not necessarily the keys, but the indices\n\t// corresponding to the keyed nodes in the old list (keyed nodes `e,d,c,b,a` => `b,a,e,d,c` would\n\t//  match the above lists, for example).\n\t//\n\t// In there are two increasing subsequences: `4,5` and `1,2,3`, the latter being the longest. We\n\t// can update those nodes without moving them, and only call `insertNode` on `4` and `5`.\n\t//\n\t// @localvoid adapted the algo to also support node deletions and insertions (the `lis` is actually\n\t// the longest increasing subsequence *of old nodes still present in the new list*).\n\t//\n\t// It is a general algorithm that is fireproof in all circumstances, but it requires the allocation\n\t// and the construction of a `key => oldIndex` map, and three arrays (one with `newIndex => oldIndex`,\n\t// the `LIS` and a temporary one to create the LIS).\n\t//\n\t// So we cheat where we can: if the tails of the lists are identical, they are guaranteed to be part of\n\t// the LIS and can be updated without moving them.\n\t//\n\t// If two nodes are swapped, they are guaranteed not to be part of the LIS, and must be moved (with\n\t// the exception of the last node if the list is fully reversed).\n\t//\n\t// ## Finding the next sibling.\n\t//\n\t// `updateNode()` and `createNode()` expect a nextSibling parameter to perform DOM operations.\n\t// When the list is being traversed top-down, at any index, the DOM nodes up to the previous\n\t// vnode reflect the content of the new list, whereas the rest of the DOM nodes reflect the old\n\t// list. The next sibling must be looked for in the old list using `getNextSibling(... oldStart + 1 ...)`.\n\t//\n\t// In the other scenarios (swaps, upwards traversal, map-based diff),\n\t// the new vnodes list is traversed upwards. The DOM nodes at the bottom of the list reflect the\n\t// bottom part of the new vnodes list, and we can use the `v.dom`  value of the previous node\n\t// as the next sibling (cached in the `nextSibling` variable).\n\n\n\t// ## DOM node moves\n\t//\n\t// In most scenarios `updateNode()` and `createNode()` perform the DOM operations. However,\n\t// this is not the case if the node moved (second and fourth part of the diff algo). We move\n\t// the old DOM nodes before updateNode runs because it enables us to use the cached `nextSibling`\n\t// variable rather than fetching it using `getNextSibling()`.\n\n\tfunction updateNodes(parent, old, vnodes, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null || old.length === 0) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null || vnodes.length === 0) removeNodes(parent, old, 0, old.length)\n\t\telse {\n\t\t\tvar isOldKeyed = old[0] != null && old[0].key != null\n\t\t\tvar isKeyed = vnodes[0] != null && vnodes[0].key != null\n\t\t\tvar start = 0, oldStart = 0\n\t\t\tif (!isOldKeyed) while (oldStart < old.length && old[oldStart] == null) oldStart++\n\t\t\tif (!isKeyed) while (start < vnodes.length && vnodes[start] == null) start++\n\t\t\tif (isOldKeyed !== isKeyed) {\n\t\t\t\tremoveNodes(parent, old, oldStart, old.length)\n\t\t\t\tcreateNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)\n\t\t\t} else if (!isKeyed) {\n\t\t\t\t// Don't index past the end of either list (causes deopts).\n\t\t\t\tvar commonLength = old.length < vnodes.length ? old.length : vnodes.length\n\t\t\t\t// Rewind if necessary to the first non-null index on either side.\n\t\t\t\t// We could alternatively either explicitly create or remove nodes when `start !== oldStart`\n\t\t\t\t// but that would be optimizing for sparse lists which are more rare than dense ones.\n\t\t\t\tstart = start < oldStart ? start : oldStart\n\t\t\t\tfor (; start < commonLength; start++) {\n\t\t\t\t\to = old[start]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t\tif (o === v || o == null && v == null) continue\n\t\t\t\t\telse if (o == null) createNode(parent, v, hooks, ns, getNextSibling(old, start + 1, nextSibling))\n\t\t\t\t\telse if (v == null) removeNode(parent, o)\n\t\t\t\t\telse updateNode(parent, o, v, hooks, getNextSibling(old, start + 1, nextSibling), ns)\n\t\t\t\t}\n\t\t\t\tif (old.length > commonLength) removeNodes(parent, old, start, old.length)\n\t\t\t\tif (vnodes.length > commonLength) createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)\n\t\t\t} else {\n\t\t\t\t// keyed diff\n\t\t\t\tvar oldEnd = old.length - 1, end = vnodes.length - 1, map, o, v, oe, ve, topSibling\n\n\t\t\t\t// bottom-up\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t\tif (oe.key !== ve.key) break\n\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\t// top-down\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\to = old[oldStart]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t\tif (o.key !== v.key) break\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tif (o !== v) updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), ns)\n\t\t\t\t}\n\t\t\t\t// swaps and list reversals\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\tif (start === end) break\n\t\t\t\t\tif (o.key !== ve.key || oe.key !== v.key) break\n\t\t\t\t\ttopSibling = getNextSibling(old, oldStart, nextSibling)\n\t\t\t\t\tmoveDOM(parent, oe, topSibling)\n\t\t\t\t\tif (oe !== v) updateNode(parent, oe, v, hooks, topSibling, ns)\n\t\t\t\t\tif (++start <= --end) moveDOM(parent, o, nextSibling)\n\t\t\t\t\tif (o !== ve) updateNode(parent, o, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldStart++; oldEnd--\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t\to = old[oldStart]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t}\n\t\t\t\t// bottom up once again\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\tif (oe.key !== ve.key) break\n\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t}\n\t\t\t\tif (start > end) removeNodes(parent, old, oldStart, oldEnd + 1)\n\t\t\t\telse if (oldStart > oldEnd) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\t\telse {\n\t\t\t\t\t// inspired by ivi https://github.com/ivijs/ivi/ by Boris Kaul\n\t\t\t\t\tvar originalNextSibling = nextSibling, vnodesLength = end - start + 1, oldIndices = new Array(vnodesLength), li=0, i=0, pos = 2147483647, matched = 0, map, lisIndices\n\t\t\t\t\tfor (i = 0; i < vnodesLength; i++) oldIndices[i] = -1\n\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\tif (map == null) map = getKeyMap(old, oldStart, oldEnd + 1)\n\t\t\t\t\t\tve = vnodes[i]\n\t\t\t\t\t\tvar oldIndex = map[ve.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tpos = (oldIndex < pos) ? oldIndex : -1 // becomes -1 if nodes were re-ordered\n\t\t\t\t\t\t\toldIndices[i-start] = oldIndex\n\t\t\t\t\t\t\toe = old[oldIndex]\n\t\t\t\t\t\t\told[oldIndex] = null\n\t\t\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\t\t\tmatched++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnextSibling = originalNextSibling\n\t\t\t\t\tif (matched !== oldEnd - oldStart + 1) removeNodes(parent, old, oldStart, oldEnd + 1)\n\t\t\t\t\tif (matched === 0) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (pos === -1) {\n\t\t\t\t\t\t\t// the indices of the indices of the items that are part of the\n\t\t\t\t\t\t\t// longest increasing subsequence in the oldIndices list\n\t\t\t\t\t\t\tlisIndices = makeLisIndices(oldIndices)\n\t\t\t\t\t\t\tli = lisIndices.length - 1\n\t\t\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\t\t\tv = vnodes[i]\n\t\t\t\t\t\t\t\tif (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (lisIndices[li] === i - start) li--\n\t\t\t\t\t\t\t\t\telse moveDOM(parent, v, nextSibling)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (v.dom != null) nextSibling = vnodes[i].dom\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\t\t\tv = vnodes[i]\n\t\t\t\t\t\t\t\tif (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\t\tif (v.dom != null) nextSibling = vnodes[i].dom\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag && old.is === vnode.is) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode.events = old.events\n\t\t\tif (shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tupdateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase \"#\": updateText(old, vnode); break\n\t\t\t\t\tcase \"<\": updateHTML(parent, old, vnode, ns, nextSibling); break\n\t\t\t\t\tcase \"[\": updateFragment(parent, old, vnode, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(parent, old)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, ns, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\tremoveDOM(parent, old)\n\t\t\tcreateHTML(parent, vnode, ns, nextSibling)\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction updateFragment(parent, old, vnode, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\n\t\tif (old.attrs != vnode.attrs || (vnode.attrs != null && !cachedAttrsIsStaticMap.get(vnode.attrs))) {\n\t\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\t}\n\t\tif (!maybeSetContentEditable(vnode)) {\n\t\t\tupdateNodes(element, old.children, vnode.children, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, ns) {\n\t\tvnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tupdateLifecycle(vnode.state, vnode, hooks)\n\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(parent, old.instance)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction getKeyMap(vnodes, start, end) {\n\t\tvar map = Object.create(null)\n\t\tfor (; start < end; start++) {\n\t\t\tvar vnode = vnodes[start]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key = vnode.key\n\t\t\t\tif (key != null) map[key] = start\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\t// Lifted from ivi https://github.com/ivijs/ivi/\n\t// takes a list of unique numbers (-1 is special and can\n\t// occur multiple times) and returns an array with the indices\n\t// of the items that are part of the longest increasing\n\t// subsequence\n\tvar lisTemp = []\n\tfunction makeLisIndices(a) {\n\t\tvar result = [0]\n\t\tvar u = 0, v = 0, i = 0\n\t\tvar il = lisTemp.length = a.length\n\t\tfor (var i = 0; i < il; i++) lisTemp[i] = a[i]\n\t\tfor (var i = 0; i < il; ++i) {\n\t\t\tif (a[i] === -1) continue\n\t\t\tvar j = result[result.length - 1]\n\t\t\tif (a[j] < a[i]) {\n\t\t\t\tlisTemp[i] = j\n\t\t\t\tresult.push(i)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tu = 0\n\t\t\tv = result.length - 1\n\t\t\twhile (u < v) {\n\t\t\t\t// Fast integer average without overflow.\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tvar c = (u >>> 1) + (v >>> 1) + (u & v & 1)\n\t\t\t\tif (a[result[c]] < a[i]) {\n\t\t\t\t\tu = c + 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv = c\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] < a[result[u]]) {\n\t\t\t\tif (u > 0) lisTemp[i] = result[u - 1]\n\t\t\t\tresult[u] = i\n\t\t\t}\n\t\t}\n\t\tu = result.length\n\t\tv = result[u - 1]\n\t\twhile (u-- > 0) {\n\t\t\tresult[u] = v\n\t\t\tv = lisTemp[v]\n\t\t}\n\t\tlisTemp.length = 0\n\t\treturn result\n\t}\n\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\n\t// This handles fragments with zombie children (removed from vdom, but persisted in DOM through onbeforeremove)\n\tfunction moveDOM(parent, vnode, nextSibling) {\n\t\tif (vnode.dom != null) {\n\t\t\tvar target\n\t\t\tif (vnode.domSize == null) {\n\t\t\t\t// don't allocate for the common case\n\t\t\t\ttarget = vnode.dom\n\t\t\t} else {\n\t\t\t\ttarget = getDocument(parent).createDocumentFragment()\n\t\t\t\tfor (var dom of domFor(vnode)) target.appendChild(dom)\n\t\t\t}\n\t\t\tinsertDOM(parent, target, nextSibling)\n\t\t}\n\t}\n\n\tfunction insertDOM(parent, dom, nextSibling) {\n\t\tif (nextSibling != null) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\n\tfunction maybeSetContentEditable(vnode) {\n\t\tif (vnode.attrs == null || (\n\t\t\tvnode.attrs.contenteditable == null && // attribute\n\t\t\tvnode.attrs.contentEditable == null // property\n\t\t)) return false\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === \"<\") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (children != null && children.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted.\")\n\t\treturn true\n\t}\n\n\t//remove\n\tfunction removeNodes(parent, vnodes, start, end) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) removeNode(parent, vnode)\n\t\t}\n\t}\n\tfunction tryBlockRemove(parent, vnode, source, counter) {\n\t\tvar original = vnode.state\n\t\tvar result = callHook.call(source.onbeforeremove, vnode)\n\t\tif (result == null) return\n\n\t\tvar generation = currentRender\n\t\tfor (var dom of domFor(vnode)) delayedRemoval.set(dom, generation)\n\t\tcounter.v++\n\n\t\tPromise.resolve(result).finally(function () {\n\t\t\tcheckState(vnode, original)\n\t\t\ttryResumeRemove(parent, vnode, counter)\n\t\t})\n\t}\n\tfunction tryResumeRemove(parent, vnode, counter) {\n\t\tif (--counter.v === 0) {\n\t\t\tonremove(vnode)\n\t\t\tremoveDOM(parent, vnode)\n\t\t}\n\t}\n\tfunction removeNode(parent, vnode) {\n\t\tvar counter = {v: 1}\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode.state.onbeforeremove === \"function\") tryBlockRemove(parent, vnode, vnode.state, counter)\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === \"function\") tryBlockRemove(parent, vnode, vnode.attrs, counter)\n\t\ttryResumeRemove(parent, vnode, counter)\n\t}\n\tfunction removeDOM(parent, vnode) {\n\t\tif (vnode.dom == null) return\n\t\tif (vnode.domSize == null) {\n\t\t\tparent.removeChild(vnode.dom)\n\t\t} else {\n\t\t\tfor (var dom of domFor(vnode)) parent.removeChild(dom)\n\t\t}\n\t}\n\n\tfunction onremove(vnode) {\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode.state.onremove === \"function\") callHook.call(vnode.state.onremove, vnode)\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === \"function\") callHook.call(vnode.attrs.onremove, vnode)\n\t\tif (typeof vnode.tag !== \"string\") {\n\t\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\t} else {\n\t\t\tif (vnode.events != null) vnode.events._ = null\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//attrs\n\tfunction setAttrs(vnode, attrs, ns) {\n\t\tfor (var key in attrs) {\n\t\t\tsetAttr(vnode, key, null, attrs[key], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key, old, value, ns) {\n\t\tif (key === \"key\" || value == null || isLifecycleMethod(key) || (old === value && !isFormAttribute(vnode, key)) && typeof value !== \"object\") return\n\t\tif (key[0] === \"o\" && key[1] === \"n\") return updateEvent(vnode, key, value)\n\t\tif (key.slice(0, 6) === \"xlink:\") vnode.dom.setAttributeNS(\"http://www.w3.org/1999/xlink\", key.slice(6), value)\n\t\telse if (key === \"style\") updateStyle(vnode.dom, old, value)\n\t\telse if (hasPropertyKey(vnode, key, ns)) {\n\t\t\tif (key === \"value\") {\n\t\t\t\t// Only do the coercion if we're actually going to check the value.\n\t\t\t\t/* eslint-disable no-implicit-coercion */\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\t//setting input[type=file][value] to same value causes an error to be generated if it's non-empty\n\t\t\t\t//minlength/maxlength validation isn't performed on script-set values(#2256)\n\t\t\t\tif ((vnode.tag === \"input\" || vnode.tag === \"textarea\") && vnode.dom.value === \"\" + value) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === \"select\" && old !== null && vnode.dom.value === \"\" + value) return\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === \"option\" && old !== null && vnode.dom.value === \"\" + value) return\n\t\t\t\t//setting input[type=file][value] to different value is an error if it's non-empty\n\t\t\t\t// Not ideal, but it at least works around the most common source of uncaught exceptions for now.\n\t\t\t\tif (vnode.tag === \"input\" && vnode.attrs.type === \"file\" && \"\" + value !== \"\") { console.error(\"`value` is read-only on file inputs!\"); return }\n\t\t\t\t/* eslint-enable no-implicit-coercion */\n\t\t\t}\n\t\t\t// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.\n\t\t\tif (vnode.tag === \"input\" && key === \"type\") vnode.dom.setAttribute(key, value)\n\t\t\telse vnode.dom[key] = value\n\t\t} else {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tif (value) vnode.dom.setAttribute(key, \"\")\n\t\t\t\telse vnode.dom.removeAttribute(key)\n\t\t\t}\n\t\t\telse vnode.dom.setAttribute(key === \"className\" ? \"class\" : key, value)\n\t\t}\n\t}\n\tfunction removeAttr(vnode, key, old, ns) {\n\t\tif (key === \"key\" || old == null || isLifecycleMethod(key)) return\n\t\tif (key[0] === \"o\" && key[1] === \"n\") updateEvent(vnode, key, undefined)\n\t\telse if (key === \"style\") updateStyle(vnode.dom, old, null)\n\t\telse if (\n\t\t\thasPropertyKey(vnode, key, ns)\n\t\t\t&& key !== \"className\"\n\t\t\t&& key !== \"title\" // creates \"null\" as title\n\t\t\t&& !(key === \"value\" && (\n\t\t\t\tvnode.tag === \"option\"\n\t\t\t\t|| vnode.tag === \"select\" && vnode.dom.selectedIndex === -1 && vnode.dom === activeElement(vnode.dom)\n\t\t\t))\n\t\t\t&& !(vnode.tag === \"input\" && key === \"type\")\n\t\t) {\n\t\t\tvnode.dom[key] = null\n\t\t} else {\n\t\t\tvar nsLastIndex = key.indexOf(\":\")\n\t\t\tif (nsLastIndex !== -1) key = key.slice(nsLastIndex + 1)\n\t\t\tif (old !== false) vnode.dom.removeAttribute(key === \"className\" ? \"class\" : key)\n\t\t}\n\t}\n\tfunction setLateSelectAttrs(vnode, attrs) {\n\t\tif (\"value\" in attrs) {\n\t\t\tif(attrs.value === null) {\n\t\t\t\tif (vnode.dom.selectedIndex !== -1) vnode.dom.value = null\n\t\t\t} else {\n\t\t\t\tvar normalized = \"\" + attrs.value // eslint-disable-line no-implicit-coercion\n\t\t\t\tif (vnode.dom.value !== normalized || vnode.dom.selectedIndex === -1) {\n\t\t\t\t\tvnode.dom.value = normalized\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (\"selectedIndex\" in attrs) setAttr(vnode, \"selectedIndex\", null, attrs.selectedIndex, undefined)\n\t}\n\tfunction updateAttrs(vnode, old, attrs, ns) {\n\t\t// Some attributes may NOT be case-sensitive (e.g. data-***),\n\t\t// so removal should be done first to prevent accidental removal for newly setting values.\n\t\tvar val\n\t\tif (old != null) {\n\t\t\tif (old === attrs && !cachedAttrsIsStaticMap.has(attrs)) {\n\t\t\t\tconsole.warn(\"Don't reuse attrs object, use new object for every redraw, this will throw in next major\")\n\t\t\t}\n\t\t\tfor (var key in old) {\n\t\t\t\tif (((val = old[key]) != null) && (attrs == null || attrs[key] == null)) {\n\t\t\t\t\tremoveAttr(vnode, key, val, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (attrs != null) {\n\t\t\tfor (var key in attrs) {\n\t\t\t\tsetAttr(vnode, key, old && old[key], attrs[key], ns)\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && (vnode.dom === activeElement(vnode.dom) || vnode.tag === \"option\" && vnode.dom.parentNode === activeElement(vnode.dom))\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\"\n\t}\n\tfunction hasPropertyKey(vnode, key, ns) {\n\t\t// Filter out namespaced keys\n\t\treturn ns === undefined && (\n\t\t\t// If it's a custom element, just keep it.\n\t\t\tvnode.tag.indexOf(\"-\") > -1 || vnode.is ||\n\t\t\t// If it's a normal element, let's try to avoid a few browser bugs.\n\t\t\tkey !== \"href\" && key !== \"list\" && key !== \"form\" && key !== \"width\" && key !== \"height\"// && key !== \"type\"\n\t\t\t// Defer the property check until *after* we check everything.\n\t\t) && key in vnode.dom\n\t}\n\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) {\n\t\t\t// Styles are equivalent, do nothing.\n\t\t} else if (style == null) {\n\t\t\t// New style is missing, just clear it.\n\t\t\telement.style = \"\"\n\t\t} else if (typeof style !== \"object\") {\n\t\t\t// New style is a string, let engine deal with patching.\n\t\t\telement.style = style\n\t\t} else if (old == null || typeof old !== \"object\") {\n\t\t\t// `old` is missing or a string, `style` is an object.\n\t\t\telement.style = \"\"\n\t\t\t// Add new style properties\n\t\t\tfor (var key in style) {\n\t\t\t\tvar value = style[key]\n\t\t\t\tif (value != null) {\n\t\t\t\t\tif (key.includes(\"-\")) element.style.setProperty(key, String(value))\n\t\t\t\t\telse element.style[key] = String(value)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Both old & new are (different) objects.\n\t\t\t// Remove style properties that no longer exist\n\t\t\t// Style properties may have two cases(dash-case and camelCase),\n\t\t\t// so removal should be done first to prevent accidental removal for newly setting values.\n\t\t\tfor (var key in old) {\n\t\t\t\tif (old[key] != null && style[key] == null) {\n\t\t\t\t\tif (key.includes(\"-\")) element.style.removeProperty(key)\n\t\t\t\t\telse element.style[key] = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update style properties that have changed\n\t\t\tfor (var key in style) {\n\t\t\t\tvar value = style[key]\n\t\t\t\tif (value != null && (value = String(value)) !== String(old[key])) {\n\t\t\t\t\tif (key.includes(\"-\")) element.style.setProperty(key, value)\n\t\t\t\t\telse element.style[key] = value\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Here's an explanation of how this works:\n\t// 1. The event names are always (by design) prefixed by `on`.\n\t// 2. The EventListener interface accepts either a function or an object\n\t//    with a `handleEvent` method.\n\t// 3. The object does not inherit from `Object.prototype`, to avoid\n\t//    any potential interference with that (e.g. setters).\n\t// 4. The event name is remapped to the handler before calling it.\n\t// 5. In function-based event handlers, `ev.target === this`. We replicate\n\t//    that below.\n\t// 6. In function-based event handlers, `return false` prevents the default\n\t//    action and stops event propagation. We replicate that below.\n\tfunction EventDict() {\n\t\t// Save this, so the current redraw is correctly tracked.\n\t\tthis._ = currentRedraw\n\t}\n\tEventDict.prototype = Object.create(null)\n\tEventDict.prototype.handleEvent = function (ev) {\n\t\tvar handler = this[\"on\" + ev.type]\n\t\tvar result\n\t\tif (typeof handler === \"function\") result = handler.call(ev.currentTarget, ev)\n\t\telse if (typeof handler.handleEvent === \"function\") handler.handleEvent(ev)\n\t\tvar self = this\n\t\tif (self._ != null) {\n\t\t\tif (ev.redraw !== false) (0, self._)()\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\tPromise.resolve(result).then(function () {\n\t\t\t\t\tif (self._ != null && ev.redraw !== false) (0, self._)()\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif (result === false) {\n\t\t\tev.preventDefault()\n\t\t\tev.stopPropagation()\n\t\t}\n\t}\n\n\t//event\n\tfunction updateEvent(vnode, key, value) {\n\t\tif (vnode.events != null) {\n\t\t\tvnode.events._ = currentRedraw\n\t\t\tif (vnode.events[key] === value) return\n\t\t\tif (value != null && (typeof value === \"function\" || typeof value === \"object\")) {\n\t\t\t\tif (vnode.events[key] == null) vnode.dom.addEventListener(key.slice(2), vnode.events, false)\n\t\t\t\tvnode.events[key] = value\n\t\t\t} else {\n\t\t\t\tif (vnode.events[key] != null) vnode.dom.removeEventListener(key.slice(2), vnode.events, false)\n\t\t\t\tvnode.events[key] = undefined\n\t\t\t}\n\t\t} else if (value != null && (typeof value === \"function\" || typeof value === \"object\")) {\n\t\t\tvnode.events = new EventDict()\n\t\t\tvnode.dom.addEventListener(key.slice(2), vnode.events, false)\n\t\t\tvnode.events[key] = value\n\t\t}\n\t}\n\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === \"function\") callHook.call(source.oninit, vnode)\n\t\tif (typeof source.oncreate === \"function\") hooks.push(callHook.bind(source.oncreate, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === \"function\") hooks.push(callHook.bind(source.onupdate, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tdo {\n\t\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === \"function\") {\n\t\t\t\tvar force = callHook.call(vnode.attrs.onbeforeupdate, vnode, old)\n\t\t\t\tif (force !== undefined && !force) break\n\t\t\t}\n\t\t\tif (typeof vnode.tag !== \"string\" && typeof vnode.state.onbeforeupdate === \"function\") {\n\t\t\t\tvar force = callHook.call(vnode.state.onbeforeupdate, vnode, old)\n\t\t\t\tif (force !== undefined && !force) break\n\t\t\t}\n\t\t\treturn false\n\t\t} while (false); // eslint-disable-line no-constant-condition\n\t\tvnode.dom = old.dom\n\t\tvnode.domSize = old.domSize\n\t\tvnode.instance = old.instance\n\t\t// One would think having the actual latest attributes would be ideal,\n\t\t// but it doesn't let us properly diff based on our current internal\n\t\t// representation. We have to save not only the old DOM info, but also\n\t\t// the attributes used to create it, as we diff *that*, not against the\n\t\t// DOM directly (with a few exceptions in `setAttr`). And, of course, we\n\t\t// need to save the children and text as they are conceptually not\n\t\t// unlike special \"attributes\" internally.\n\t\tvnode.attrs = old.attrs\n\t\tvnode.children = old.children\n\t\tvnode.text = old.text\n\t\treturn true\n\t}\n\n\tvar currentDOM\n\n\treturn function(dom, vnodes, redraw) {\n\t\tif (!dom) throw new TypeError(\"DOM element being rendered to does not exist.\")\n\t\tif (currentDOM != null && dom.contains(currentDOM)) {\n\t\t\tthrow new TypeError(\"Node is currently being rendered to and thus is locked.\")\n\t\t}\n\t\tvar prevRedraw = currentRedraw\n\t\tvar prevDOM = currentDOM\n\t\tvar hooks = []\n\t\tvar active = activeElement(dom)\n\t\tvar namespace = dom.namespaceURI\n\n\t\tcurrentDOM = dom\n\t\tcurrentRedraw = typeof redraw === \"function\" ? redraw : undefined\n\t\tcurrentRender = {}\n\t\ttry {\n\t\t\t// First time rendering into a node clears it out\n\t\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\t\t\tvnodes = Vnode.normalizeChildren(Array.isArray(vnodes) ? vnodes : [vnodes])\n\t\t\tupdateNodes(dom, dom.vnodes, vnodes, hooks, null, namespace === \"http://www.w3.org/1999/xhtml\" ? undefined : namespace)\n\t\t\tdom.vnodes = vnodes\n\t\t\t// `document.activeElement` can return null: https://html.spec.whatwg.org/multipage/interaction.html#dom-document-activeelement\n\t\t\tif (active != null && activeElement(dom) !== active && typeof active.focus === \"function\") active.focus()\n\t\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\t} finally {\n\t\t\tcurrentRedraw = prevRedraw\n\t\t\tcurrentDOM = prevDOM\n\t\t}\n\t}\n}\n", "\"use strict\"\n\nmodule.exports = require(\"./render/render\")(typeof window !== \"undefined\" ? window : null)\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\n\nmodule.exports = function(render, schedule, console) {\n\tvar subscriptions = []\n\tvar pending = false\n\tvar offset = -1\n\n\tfunction sync() {\n\t\tfor (offset = 0; offset < subscriptions.length; offset += 2) {\n\t\t\ttry { render(subscriptions[offset], Vnode(subscriptions[offset + 1]), redraw) }\n\t\t\tcatch (e) { console.error(e) }\n\t\t}\n\t\toffset = -1\n\t}\n\n\tfunction redraw() {\n\t\tif (!pending) {\n\t\t\tpending = true\n\t\t\tschedule(function() {\n\t\t\t\tpending = false\n\t\t\t\tsync()\n\t\t\t})\n\t\t}\n\t}\n\n\tredraw.sync = sync\n\n\tfunction mount(root, component) {\n\t\tif (component != null && component.view == null && typeof component !== \"function\") {\n\t\t\tthrow new TypeError(\"m.mount expects a component, not a vnode.\")\n\t\t}\n\n\t\tvar index = subscriptions.indexOf(root)\n\t\tif (index >= 0) {\n\t\t\tsubscriptions.splice(index, 2)\n\t\t\tif (index <= offset) offset -= 2\n\t\t\trender(root, [])\n\t\t}\n\n\t\tif (component != null) {\n\t\t\tsubscriptions.push(root, component)\n\t\t\trender(root, Vnode(component), redraw)\n\t\t}\n\t}\n\n\treturn {mount: mount, redraw: redraw}\n}\n", "\"use strict\"\n\nvar render = require(\"./render\")\n\nmodule.exports = require(\"./api/mount-redraw\")(render, typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : null, typeof console !== \"undefined\" ? console : null)\n", "\"use strict\"\n\nmodule.exports = function(object) {\n\tif (Object.prototype.toString.call(object) !== \"[object Object]\") return \"\"\n\n\tvar args = []\n\tfor (var key in object) {\n\t\tdestructure(key, object[key])\n\t}\n\n\treturn args.join(\"&\")\n\n\tfunction destructure(key, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === \"[object Object]\") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key) + (value != null && value !== \"\" ? \"=\" + encodeURIComponent(value) : \"\"))\n\t}\n}\n", "\"use strict\"\n\nvar buildQueryString = require(\"../querystring/build\")\n\n// Returns `path` from `template` + `params`\nmodule.exports = function(template, params) {\n\tif ((/:([^\\/\\.-]+)(\\.{3})?:/).test(template)) {\n\t\tthrow new SyntaxError(\"Template parameter names must be separated by either a '/', '-', or '.'.\")\n\t}\n\tif (params == null) return template\n\tvar queryIndex = template.indexOf(\"?\")\n\tvar hashIndex = template.indexOf(\"#\")\n\tvar queryEnd = hashIndex < 0 ? template.length : hashIndex\n\tvar pathEnd = queryIndex < 0 ? queryEnd : queryIndex\n\tvar path = template.slice(0, pathEnd)\n\tvar query = {}\n\n\tObject.assign(query, params)\n\n\tvar resolved = path.replace(/:([^\\/\\.-]+)(\\.{3})?/g, function(m, key, variadic) {\n\t\tdelete query[key]\n\t\t// If no such parameter exists, don't interpolate it.\n\t\tif (params[key] == null) return m\n\t\t// Escape normal parameters, but not variadic ones.\n\t\treturn variadic ? params[key] : encodeURIComponent(String(params[key]))\n\t})\n\n\t// In case the template substitution adds new query/hash parameters.\n\tvar newQueryIndex = resolved.indexOf(\"?\")\n\tvar newHashIndex = resolved.indexOf(\"#\")\n\tvar newQueryEnd = newHashIndex < 0 ? resolved.length : newHashIndex\n\tvar newPathEnd = newQueryIndex < 0 ? newQueryEnd : newQueryIndex\n\tvar result = resolved.slice(0, newPathEnd)\n\n\tif (queryIndex >= 0) result += template.slice(queryIndex, queryEnd)\n\tif (newQueryIndex >= 0) result += (queryIndex < 0 ? \"?\" : \"&\") + resolved.slice(newQueryIndex, newQueryEnd)\n\tvar querystring = buildQueryString(query)\n\tif (querystring) result += (queryIndex < 0 && newQueryIndex < 0 ? \"?\" : \"&\") + querystring\n\tif (hashIndex >= 0) result += template.slice(hashIndex)\n\tif (newHashIndex >= 0) result += (hashIndex < 0 ? \"\" : \"&\") + resolved.slice(newHashIndex)\n\treturn result\n}\n", "\"use strict\"\n\nvar buildPathname = require(\"../pathname/build\")\nvar hasOwn = require(\"../util/hasOwn\")\n\nmodule.exports = function($window, oncompletion) {\n\tfunction PromiseProxy(executor) {\n\t\treturn new Promise(executor)\n\t}\n\n\tfunction makeRequest(url, args) {\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\turl = buildPathname(url, args.params)\n\t\t\tvar method = args.method != null ? args.method.toUpperCase() : \"GET\"\n\t\t\tvar body = args.body\n\t\t\tvar assumeJSON = (args.serialize == null || args.serialize === JSON.serialize) && !(body instanceof $window.FormData || body instanceof $window.URLSearchParams)\n\t\t\tvar responseType = args.responseType || (typeof args.extract === \"function\" ? \"\" : \"json\")\n\n\t\t\tvar xhr = new $window.XMLHttpRequest(), aborted = false, isTimeout = false\n\t\t\tvar original = xhr, replacedAbort\n\t\t\tvar abort = xhr.abort\n\n\t\t\txhr.abort = function() {\n\t\t\t\taborted = true\n\t\t\t\tabort.call(this)\n\t\t\t}\n\n\t\t\txhr.open(method, url, args.async !== false, typeof args.user === \"string\" ? args.user : undefined, typeof args.password === \"string\" ? args.password : undefined)\n\n\t\t\tif (assumeJSON && body != null && !hasHeader(args, \"content-type\")) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\t\t}\n\t\t\tif (typeof args.deserialize !== \"function\" && !hasHeader(args, \"accept\")) {\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tif (args.timeout) xhr.timeout = args.timeout\n\t\t\txhr.responseType = responseType\n\n\t\t\tfor (var key in args.headers) {\n\t\t\t\tif (hasOwn.call(args.headers, key)) {\n\t\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txhr.onreadystatechange = function(ev) {\n\t\t\t\t// Don't throw errors on xhr.abort().\n\t\t\t\tif (aborted) return\n\n\t\t\t\tif (ev.target.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar success = (ev.target.status >= 200 && ev.target.status < 300) || ev.target.status === 304 || (/^file:\\/\\//i).test(url)\n\t\t\t\t\t\t// When the response type isn't \"\" or \"text\",\n\t\t\t\t\t\t// `xhr.responseText` is the wrong thing to use.\n\t\t\t\t\t\t// Browsers do the right thing and throw here, and we\n\t\t\t\t\t\t// should honor that and do the right thing by\n\t\t\t\t\t\t// preferring `xhr.response` where possible/practical.\n\t\t\t\t\t\tvar response = ev.target.response, message\n\n\t\t\t\t\t\tif (responseType === \"json\") {\n\t\t\t\t\t\t\t// For IE and Edge, which don't implement\n\t\t\t\t\t\t\t// `responseType: \"json\"`.\n\t\t\t\t\t\t\tif (!ev.target.responseType && typeof args.extract !== \"function\") {\n\t\t\t\t\t\t\t\t// Handle no-content which will not parse.\n\t\t\t\t\t\t\t\ttry { response = JSON.parse(ev.target.responseText) }\n\t\t\t\t\t\t\t\tcatch (e) { response = null }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!responseType || responseType === \"text\") {\n\t\t\t\t\t\t\t// Only use this default if it's text. If a parsed\n\t\t\t\t\t\t\t// document is needed on old IE and friends (all\n\t\t\t\t\t\t\t// unsupported), the user should use a custom\n\t\t\t\t\t\t\t// `config` instead. They're already using this at\n\t\t\t\t\t\t\t// their own risk.\n\t\t\t\t\t\t\tif (response == null) response = ev.target.responseText\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof args.extract === \"function\") {\n\t\t\t\t\t\t\tresponse = args.extract(ev.target, args)\n\t\t\t\t\t\t\tsuccess = true\n\t\t\t\t\t\t} else if (typeof args.deserialize === \"function\") {\n\t\t\t\t\t\t\tresponse = args.deserialize(response)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (success) {\n\t\t\t\t\t\t\tif (typeof args.type === \"function\") {\n\t\t\t\t\t\t\t\tif (Array.isArray(response)) {\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < response.length; i++) {\n\t\t\t\t\t\t\t\t\t\tresponse[i] = new args.type(response[i])\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse response = new args.type(response)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolve(response)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar completeErrorResponse = function() {\n\t\t\t\t\t\t\t\ttry { message = ev.target.responseText }\n\t\t\t\t\t\t\t\tcatch (e) { message = response }\n\t\t\t\t\t\t\t\tvar error = new Error(message)\n\t\t\t\t\t\t\t\terror.code = ev.target.status\n\t\t\t\t\t\t\t\terror.response = response\n\t\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (xhr.status === 0) {\n\t\t\t\t\t\t\t\t// Use setTimeout to push this code block onto the event queue\n\t\t\t\t\t\t\t\t// This allows `xhr.ontimeout` to run in the case that there is a timeout\n\t\t\t\t\t\t\t\t// Without this setTimeout, `xhr.ontimeout` doesn't have a chance to reject\n\t\t\t\t\t\t\t\t// as `xhr.onreadystatechange` will run before it\n\t\t\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\t\t\tif (isTimeout) return\n\t\t\t\t\t\t\t\t\tcompleteErrorResponse()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t} else completeErrorResponse()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txhr.ontimeout = function (ev) {\n\t\t\t\tisTimeout = true\n\t\t\t\tvar error = new Error(\"Request timed out\")\n\t\t\t\terror.code = ev.target.status\n\t\t\t\treject(error)\n\t\t\t}\n\n\t\t\tif (typeof args.config === \"function\") {\n\t\t\t\txhr = args.config(xhr, args, url) || xhr\n\n\t\t\t\t// Propagate the `abort` to any replacement XHR as well.\n\t\t\t\tif (xhr !== original) {\n\t\t\t\t\treplacedAbort = xhr.abort\n\t\t\t\t\txhr.abort = function() {\n\t\t\t\t\t\taborted = true\n\t\t\t\t\t\treplacedAbort.call(this)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (body == null) xhr.send()\n\t\t\telse if (typeof args.serialize === \"function\") xhr.send(args.serialize(body))\n\t\t\telse if (body instanceof $window.FormData || body instanceof $window.URLSearchParams) xhr.send(body)\n\t\t\telse xhr.send(JSON.stringify(body))\n\t\t})\n\t}\n\n\t// In case the global Promise is some userland library's where they rely on\n\t// `foo instanceof this.constructor`, `this.constructor.resolve(value)`, or\n\t// similar. Let's *not* break them.\n\tPromiseProxy.prototype = Promise.prototype\n\tPromiseProxy.__proto__ = Promise // eslint-disable-line no-proto\n\n\tfunction hasHeader(args, name) {\n\t\tfor (var key in args.headers) {\n\t\t\tif (hasOwn.call(args.headers, key) && key.toLowerCase() === name) return true\n\t\t}\n\t\treturn false\n\t}\n\n\treturn {\n\t\trequest: function(url, args) {\n\t\t\tif (typeof url !== \"string\") { args = url; url = url.url }\n\t\t\telse if (args == null) args = {}\n\t\t\tvar promise = makeRequest(url, args)\n\t\t\tif (args.background === true) return promise\n\t\t\tvar count = 0\n\t\t\tfunction complete() {\n\t\t\t\tif (--count === 0 && typeof oncompletion === \"function\") oncompletion()\n\t\t\t}\n\n\t\t\treturn wrap(promise)\n\n\t\t\tfunction wrap(promise) {\n\t\t\t\tvar then = promise.then\n\t\t\t\t// Set the constructor, so engines know to not await or resolve\n\t\t\t\t// this as a native promise. At the time of writing, this is\n\t\t\t\t// only necessary for V8, but their behavior is the correct\n\t\t\t\t// behavior per spec. See this spec issue for more details:\n\t\t\t\t// https://github.com/tc39/ecma262/issues/1577. Also, see the\n\t\t\t\t// corresponding comment in `request/tests/test-request.js` for\n\t\t\t\t// a bit more background on the issue at hand.\n\t\t\t\tpromise.constructor = PromiseProxy\n\t\t\t\tpromise.then = function() {\n\t\t\t\t\tcount++\n\t\t\t\t\tvar next = then.apply(promise, arguments)\n\t\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\t\tcomplete()\n\t\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t\t})\n\t\t\t\t\treturn wrap(next)\n\t\t\t\t}\n\t\t\t\treturn promise\n\t\t\t}\n\t\t}\n\t}\n}\n", "\"use strict\"\n\nvar mountRedraw = require(\"./mount-redraw\")\n\nmodule.exports = require(\"./request/request\")(typeof window !== \"undefined\" ? window : null, mountRedraw.redraw)\n", "\"use strict\"\n\nfunction decodeURIComponentSave(str) {\n\ttry {\n\t\treturn decodeURIComponent(str)\n\t} catch(err) {\n\t\treturn str\n\t}\n}\n\nmodule.exports = function(string) {\n\tif (string === \"\" || string == null) return {}\n\tif (string.charAt(0) === \"?\") string = string.slice(1)\n\n\tvar entries = string.split(\"&\"), counters = {}, data = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split(\"=\")\n\t\tvar key = decodeURIComponentSave(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponentSave(entry[1]) : \"\"\n\n\t\tif (value === \"true\") value = true\n\t\telse if (value === \"false\") value = false\n\n\t\tvar levels = key.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data\n\t\tif (key.indexOf(\"[\") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == \"\" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tif (level === \"\") {\n\t\t\t\tvar key = levels.slice(0, j).join()\n\t\t\t\tif (counters[key] == null) {\n\t\t\t\t\tcounters[key] = Array.isArray(cursor) ? cursor.length : 0\n\t\t\t\t}\n\t\t\t\tlevel = counters[key]++\n\t\t\t}\n\t\t\t// Disallow direct prototype pollution\n\t\t\telse if (level === \"__proto__\") break\n\t\t\tif (j === levels.length - 1) cursor[level] = value\n\t\t\telse {\n\t\t\t\t// Read own properties exclusively to disallow indirect\n\t\t\t\t// prototype pollution\n\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(cursor, level)\n\t\t\t\tif (desc != null) desc = desc.value\n\t\t\t\tif (desc == null) cursor[level] = desc = isNumber ? [] : {}\n\t\t\t\tcursor = desc\n\t\t\t}\n\t\t}\n\t}\n\treturn data\n}\n", "\"use strict\"\n\nvar parseQueryString = require(\"../querystring/parse\")\n\n// Returns `{path, params}` from `url`\nmodule.exports = function(url) {\n\tvar queryIndex = url.indexOf(\"?\")\n\tvar hashIndex = url.indexOf(\"#\")\n\tvar queryEnd = hashIndex < 0 ? url.length : hashIndex\n\tvar pathEnd = queryIndex < 0 ? queryEnd : queryIndex\n\tvar path = url.slice(0, pathEnd).replace(/\\/{2,}/g, \"/\")\n\n\tif (!path) path = \"/\"\n\telse {\n\t\tif (path[0] !== \"/\") path = \"/\" + path\n\t}\n\treturn {\n\t\tpath: path,\n\t\tparams: queryIndex < 0\n\t\t\t? {}\n\t\t\t: parseQueryString(url.slice(queryIndex + 1, queryEnd)),\n\t}\n}\n", "\"use strict\"\n\nvar parsePathname = require(\"./parse\")\n\n// Compiles a template into a function that takes a resolved path (without query\n// strings) and returns an object containing the template parameters with their\n// parsed values. This expects the input of the compiled template to be the\n// output of `parsePathname`. Note that it does *not* remove query parameters\n// specified in the template.\nmodule.exports = function(template) {\n\tvar templateData = parsePathname(template)\n\tvar templateKeys = Object.keys(templateData.params)\n\tvar keys = []\n\tvar regexp = new RegExp(\"^\" + templateData.path.replace(\n\t\t// I escape literal text so people can use things like `:file.:ext` or\n\t\t// `:lang-:locale` in routes. This is all merged into one pass so I\n\t\t// don't also accidentally escape `-` and make it harder to detect it to\n\t\t// ban it from template parameters.\n\t\t/:([^\\/.-]+)(\\.{3}|\\.(?!\\.)|-)?|[\\\\^$*+.()|\\[\\]{}]/g,\n\t\tfunction(m, key, extra) {\n\t\t\tif (key == null) return \"\\\\\" + m\n\t\t\tkeys.push({k: key, r: extra === \"...\"})\n\t\t\tif (extra === \"...\") return \"(.*)\"\n\t\t\tif (extra === \".\") return \"([^/]+)\\\\.\"\n\t\t\treturn \"([^/]+)\" + (extra || \"\")\n\t\t}\n\t) + \"\\\\/?$\")\n\treturn function(data) {\n\t\t// First, check the params. Usually, there isn't any, and it's just\n\t\t// checking a static set.\n\t\tfor (var i = 0; i < templateKeys.length; i++) {\n\t\t\tif (templateData.params[templateKeys[i]] !== data.params[templateKeys[i]]) return false\n\t\t}\n\t\t// If no interpolations exist, let's skip all the ceremony\n\t\tif (!keys.length) return regexp.test(data.path)\n\t\tvar values = regexp.exec(data.path)\n\t\tif (values == null) return false\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tdata.params[keys[i].k] = keys[i].r ? values[i + 1] : decodeURIComponent(values[i + 1])\n\t\t}\n\t\treturn true\n\t}\n}\n", "\"use strict\"\n\n// Note: this is mildly perf-sensitive.\n//\n// It does *not* use `delete` - dynamic `delete`s usually cause objects to bail\n// out into dictionary mode and just generally cause a bunch of optimization\n// issues within engines.\n//\n// Ideally, I would've preferred to do this, if it weren't for the optimization\n// issues:\n//\n// ```js\n// const hasOwn = require(\"./hasOwn\")\n// const magic = [\n//     \"key\", \"oninit\", \"oncreate\", \"onbeforeupdate\", \"onupdate\",\n//     \"onbeforeremove\", \"onremove\",\n// ]\n// module.exports = (attrs, extras) => {\n//     const result = Object.assign(Object.create(null), attrs)\n//     for (const key of magic) delete result[key]\n//     if (extras != null) for (const key of extras) delete result[key]\n//     return result\n// }\n// ```\n\nvar hasOwn = require(\"./hasOwn\")\n// Words in RegExp literals are sometimes mangled incorrectly by the internal bundler, so use RegExp().\nvar magic = new RegExp(\"^(?:key|oninit|oncreate|onbeforeupdate|onupdate|onbeforeremove|onremove)$\")\n\nmodule.exports = function(attrs, extras) {\n\tvar result = {}\n\n\tif (extras != null) {\n\t\tfor (var key in attrs) {\n\t\t\tif (hasOwn.call(attrs, key) && !magic.test(key) && extras.indexOf(key) < 0) {\n\t\t\t\tresult[key] = attrs[key]\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var key in attrs) {\n\t\t\tif (hasOwn.call(attrs, key) && !magic.test(key)) {\n\t\t\t\tresult[key] = attrs[key]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n", "\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\nvar m = require(\"../render/hyperscript\")\n\nvar buildPathname = require(\"../pathname/build\")\nvar parsePathname = require(\"../pathname/parse\")\nvar compileTemplate = require(\"../pathname/compileTemplate\")\nvar censor = require(\"../util/censor\")\n\nfunction decodeURIComponentSave(component) {\n\ttry {\n\t\treturn decodeURIComponent(component)\n\t} catch(e) {\n\t\treturn component\n\t}\n}\n\nmodule.exports = function($window, mountRedraw) {\n\tvar callAsync = $window == null\n\t\t// In case Mithril.js' loaded globally without the DOM, let's not break\n\t\t? null\n\t\t: typeof $window.setImmediate === \"function\" ? $window.setImmediate : $window.setTimeout\n\tvar p = Promise.resolve()\n\n\tvar scheduled = false\n\n\tvar ready = false\n\tvar hasBeenResolved = false\n\n\tvar dom, compiled, fallbackRoute\n\n\tvar currentResolver, component, attrs, currentPath, lastUpdate\n\n\tvar RouterRoot = {\n\t\tonremove: function() {\n\t\t\tready = hasBeenResolved = false\n\t\t\t$window.removeEventListener(\"popstate\", fireAsync, false)\n\t\t},\n\t\tview: function() {\n\t\t\t// The route has already been resolved.\n\t\t\t// Therefore, the following early return is not needed.\n\t\t\t// if (!hasBeenResolved) return\n\n\t\t\tvar vnode = Vnode(component, attrs.key, attrs)\n\t\t\tif (currentResolver) return currentResolver.render(vnode)\n\t\t\t// Wrap in a fragment to preserve existing key semantics\n\t\t\treturn [vnode]\n\t\t},\n\t}\n\n\tvar SKIP = route.SKIP = {}\n\n\tfunction resolveRoute() {\n\t\tscheduled = false\n\t\t// Consider the pathname holistically. The prefix might even be invalid,\n\t\t// but that's not our problem.\n\t\tvar prefix = $window.location.hash\n\t\tif (route.prefix[0] !== \"#\") {\n\t\t\tprefix = $window.location.search + prefix\n\t\t\tif (route.prefix[0] !== \"?\") {\n\t\t\t\tprefix = $window.location.pathname + prefix\n\t\t\t\tif (prefix[0] !== \"/\") prefix = \"/\" + prefix\n\t\t\t}\n\t\t}\n\t\t// This seemingly useless `.concat()` speeds up the tests quite a bit,\n\t\t// since the representation is consistently a relatively poorly\n\t\t// optimized cons string.\n\t\tvar path = prefix.concat()\n\t\t\t.replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponentSave)\n\t\t\t.slice(route.prefix.length)\n\t\tvar data = parsePathname(path)\n\n\t\tObject.assign(data.params, $window.history.state)\n\n\t\tfunction reject(e) {\n\t\t\tconsole.error(e)\n\t\t\troute.set(fallbackRoute, null, {replace: true})\n\t\t}\n\n\t\tloop(0)\n\t\tfunction loop(i) {\n\t\t\tfor (; i < compiled.length; i++) {\n\t\t\t\tif (compiled[i].check(data)) {\n\t\t\t\t\tvar payload = compiled[i].component\n\t\t\t\t\tvar matchedRoute = compiled[i].route\n\t\t\t\t\tvar localComp = payload\n\t\t\t\t\tvar update = lastUpdate = function(comp) {\n\t\t\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\t\t\tif (comp === SKIP) return loop(i + 1)\n\t\t\t\t\t\tcomponent = comp != null && (typeof comp.view === \"function\" || typeof comp === \"function\")? comp : \"div\"\n\t\t\t\t\t\tattrs = data.params, currentPath = path, lastUpdate = null\n\t\t\t\t\t\tcurrentResolver = payload.render ? payload : null\n\t\t\t\t\t\tif (hasBeenResolved) mountRedraw.redraw()\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\thasBeenResolved = true\n\t\t\t\t\t\t\tmountRedraw.mount(dom, RouterRoot)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// There's no understating how much I *wish* I could\n\t\t\t\t\t// use `async`/`await` here...\n\t\t\t\t\tif (payload.view || typeof payload === \"function\") {\n\t\t\t\t\t\tpayload = {}\n\t\t\t\t\t\tupdate(localComp)\n\t\t\t\t\t}\n\t\t\t\t\telse if (payload.onmatch) {\n\t\t\t\t\t\tp.then(function () {\n\t\t\t\t\t\t\treturn payload.onmatch(data.params, path, matchedRoute)\n\t\t\t\t\t\t}).then(update, path === fallbackRoute ? null : reject)\n\t\t\t\t\t}\n\t\t\t\t\telse update(/* \"div\" */)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (path === fallbackRoute) {\n\t\t\t\tthrow new Error(\"Could not resolve default route \" + fallbackRoute + \".\")\n\t\t\t}\n\t\t\troute.set(fallbackRoute, null, {replace: true})\n\t\t}\n\t}\n\n\tfunction fireAsync() {\n\t\tif (!scheduled) {\n\t\t\tscheduled = true\n\t\t\t// TODO: just do `mountRedraw.redraw()` here and elide the timer\n\t\t\t// dependency. Note that this will muck with tests a *lot*, so it's\n\t\t\t// not as easy of a change as it sounds.\n\t\t\tcallAsync(resolveRoute)\n\t\t}\n\t}\n\n\tfunction route(root, defaultRoute, routes) {\n\t\tif (!root) throw new TypeError(\"DOM element being rendered to does not exist.\")\n\n\t\tcompiled = Object.keys(routes).map(function(route) {\n\t\t\tif (route[0] !== \"/\") throw new SyntaxError(\"Routes must start with a '/'.\")\n\t\t\tif ((/:([^\\/\\.-]+)(\\.{3})?:/).test(route)) {\n\t\t\t\tthrow new SyntaxError(\"Route parameter names must be separated with either '/', '.', or '-'.\")\n\t\t\t}\n\t\t\treturn {\n\t\t\t\troute: route,\n\t\t\t\tcomponent: routes[route],\n\t\t\t\tcheck: compileTemplate(route),\n\t\t\t}\n\t\t})\n\t\tfallbackRoute = defaultRoute\n\t\tif (defaultRoute != null) {\n\t\t\tvar defaultData = parsePathname(defaultRoute)\n\n\t\t\tif (!compiled.some(function (i) { return i.check(defaultData) })) {\n\t\t\t\tthrow new ReferenceError(\"Default route doesn't match any known routes.\")\n\t\t\t}\n\t\t}\n\t\tdom = root\n\n\t\t$window.addEventListener(\"popstate\", fireAsync, false)\n\n\t\tready = true\n\n\t\t// The RouterRoot component is mounted when the route is first resolved.\n\t\tresolveRoute()\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\n\t\tpath = buildPathname(path, data)\n\t\tif (ready) {\n\t\t\tfireAsync()\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, route.prefix + path)\n\t\t\telse $window.history.pushState(state, title, route.prefix + path)\n\t\t}\n\t\telse {\n\t\t\t$window.location.href = route.prefix + path\n\t\t}\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = \"#!\"\n\troute.Link = {\n\t\tview: function(vnode) {\n\t\t\t// Omit the used parameters from the rendered element - they are\n\t\t\t// internal. Also, censor the various lifecycle methods.\n\t\t\t//\n\t\t\t// We don't strip the other parameters because for convenience we\n\t\t\t// let them be specified in the selector as well.\n\t\t\tvar child = m(\n\t\t\t\tvnode.attrs.selector || \"a\",\n\t\t\t\tcensor(vnode.attrs, [\"options\", \"params\", \"selector\", \"onclick\"]),\n\t\t\t\tvnode.children\n\t\t\t)\n\t\t\tvar options, onclick, href\n\n\t\t\t// Let's provide a *right* way to disable a route link, rather than\n\t\t\t// letting people screw up accessibility on accident.\n\t\t\t//\n\t\t\t// The attribute is coerced so users don't get surprised over\n\t\t\t// `disabled: 0` resulting in a button that's somehow routable\n\t\t\t// despite being visibly disabled.\n\t\t\tif (child.attrs.disabled = Boolean(child.attrs.disabled)) {\n\t\t\t\tchild.attrs.href = null\n\t\t\t\tchild.attrs[\"aria-disabled\"] = \"true\"\n\t\t\t\t// If you *really* do want add `onclick` on a disabled link, use\n\t\t\t\t// an `oncreate` hook to add it.\n\t\t\t} else {\n\t\t\t\toptions = vnode.attrs.options\n\t\t\t\tonclick = vnode.attrs.onclick\n\t\t\t\t// Easier to build it now to keep it isomorphic.\n\t\t\t\thref = buildPathname(child.attrs.href, vnode.attrs.params)\n\t\t\t\tchild.attrs.href = route.prefix + href\n\t\t\t\tchild.attrs.onclick = function(e) {\n\t\t\t\t\tvar result\n\t\t\t\t\tif (typeof onclick === \"function\") {\n\t\t\t\t\t\tresult = onclick.call(e.currentTarget, e)\n\t\t\t\t\t} else if (onclick == null || typeof onclick !== \"object\") {\n\t\t\t\t\t\t// do nothing\n\t\t\t\t\t} else if (typeof onclick.handleEvent === \"function\") {\n\t\t\t\t\t\tonclick.handleEvent(e)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Adapted from React Router's implementation:\n\t\t\t\t\t// https://github.com/ReactTraining/react-router/blob/520a0acd48ae1b066eb0b07d6d4d1790a1d02482/packages/react-router-dom/modules/Link.js\n\t\t\t\t\t//\n\t\t\t\t\t// Try to be flexible and intuitive in how we handle links.\n\t\t\t\t\t// Fun fact: links aren't as obvious to get right as you\n\t\t\t\t\t// would expect. There's a lot more valid ways to click a\n\t\t\t\t\t// link than this, and one might want to not simply click a\n\t\t\t\t\t// link, but right click or command-click it to copy the\n\t\t\t\t\t// link target, etc. Nope, this isn't just for blind people.\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Skip if `onclick` prevented default\n\t\t\t\t\t\tresult !== false && !e.defaultPrevented &&\n\t\t\t\t\t\t// Ignore everything but left clicks\n\t\t\t\t\t\t(e.button === 0 || e.which === 0 || e.which === 1) &&\n\t\t\t\t\t\t// Let the browser handle `target=_blank`, etc.\n\t\t\t\t\t\t(!e.currentTarget.target || e.currentTarget.target === \"_self\") &&\n\t\t\t\t\t\t// No modifier keys\n\t\t\t\t\t\t!e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey\n\t\t\t\t\t) {\n\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\te.redraw = false\n\t\t\t\t\t\troute.set(href, null, options)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn child\n\t\t},\n\t}\n\troute.param = function(key) {\n\t\treturn attrs && key != null ? attrs[key] : attrs\n\t}\n\n\treturn route\n}\n", "\"use strict\"\n\nvar mountRedraw = require(\"./mount-redraw\")\n\nmodule.exports = require(\"./api/router\")(typeof window !== \"undefined\" ? window : null, mountRedraw)\n", "\"use strict\"\n\nvar hyperscript = require(\"./hyperscript\")\nvar request = require(\"./request\")\nvar mountRedraw = require(\"./mount-redraw\")\nvar domFor = require(\"./render/domFor\")\n\nvar m = function m() { return hyperscript.apply(this, arguments) }\nm.m = hyperscript\nm.trust = hyperscript.trust\nm.fragment = hyperscript.fragment\nm.Fragment = \"[\"\nm.mount = mountRedraw.mount\nm.route = require(\"./route\")\nm.render = require(\"./render\")\nm.redraw = mountRedraw.redraw\nm.request = request.request\nm.parseQueryString = require(\"./querystring/parse\")\nm.buildQueryString = require(\"./querystring/build\")\nm.parsePathname = require(\"./pathname/parse\")\nm.buildPathname = require(\"./pathname/build\")\nm.vnode = require(\"./render/vnode\")\nm.censor = require(\"./util/censor\")\nm.domFor = domFor.domFor\n\nmodule.exports = m\n", "import m from \"mithril\";\nimport {\n  AboutApp,\n  AlbumApp,\n  AlbumsApp,\n  ListingApp,\n  ListingsApp,\n  PhotoApp,\n  PhotosApp,\n  ThingApp,\n  VideosApp,\n} from \"./app.ts\";\n\nm.route(document.body, \"/albums\", {\n  \"/albums\": AlbumsApp,\n  \"/about\": AboutApp,\n  \"/videos\": VideosApp,\n  \"/photos\": PhotosApp,\n  \"/album/:id\": AlbumApp,\n  \"/thing/:pair\": ThingApp,\n  \"/photo/:id\": PhotoApp,\n  \"/listing/:type\": ListingApp,\n  \"/listings\": ListingsApp,\n});\n", "/*\n * Mithril's Router wants components, so for the moment each page has a\n * wrapper app.\n */\n\nimport m from \"mithril\";\nimport { Header } from \"./components/header.ts\";\nimport { loadState } from \"./state.ts\";\nimport { Sidebar } from \"./components/sidebar.ts\";\nimport { AlbumsPage } from \"./pages/albums.ts\";\nimport {\n  readAlbumPhotosByAlbumId,\n  readAlbumVideosByAlbumId,\n  readAllAlbums,\n  readThingsByAlbumId,\n} from \"./services/albums.ts\";\nimport { AboutPage } from \"./pages/about.ts\";\nimport { VideosPage } from \"./pages/videos.ts\";\nimport { readAllVideos } from \"./services/videos.ts\";\nimport { listen } from \"./commons/events.ts\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport type { TripleObject } from \"@rgrannell1/tribbledb\";\nimport { AlbumPage } from \"./pages/album.ts\";\nimport { PhotosPage } from \"./pages/photos.ts\";\nimport { PhotoPage } from \"./pages/photo.ts\";\nimport { readAllPhotos } from \"./services/photos.ts\";\nimport { readAlbum, readPhoto } from \"./services/readers.ts\";\nimport { ListingPage } from \"./pages/listing.ts\";\nimport { ListingsPage } from \"./pages/listings.ts\";\nimport { readNamedTypeThings, readThing } from \"./commons/things.ts\";\nimport type { Album } from \"./types.ts\";\nimport { ThingPage } from \"./pages/thing.ts\";\n\ntype AppAttrs = {};\nconst state = await loadState();\n\nlisten(\"navigate\", (event: Event) => {\n  const { route } = (event as CustomEvent).detail;\n  console.info(`navigating to route: ${route}`);\n\n  m.route.set(route);\n});\n\nlisten(\"switch_theme\", () => {\n  state.darkMode = !state.darkMode;\n});\n\nlisten(\"click_burger_menu\", () => {\n  state.sidebarVisible = !state.sidebarVisible;\n});\n\n/* */\nexport function AlbumsApp(): m.Component<AppAttrs> {\n  return {\n    oninit() {\n    },\n    view() {\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(AlbumsPage, {\n              albums: readAllAlbums(state.data),\n              services: state.services,\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function AlbumApp(): m.Component<AppAttrs> {\n  return {\n    oninit() {\n      const id = m.route.param(\"id\");\n      state.currentAlbum = `urn:r\u00F3:album:${id}`;\n    },\n    view() {\n      if (!state.currentAlbum) {\n        return m(\"p\", \"No album selected\");\n      }\n      const album = readAlbum(state.data, state.currentAlbum) as Album;\n      const photos = readAlbumPhotosByAlbumId(state.data, state.currentAlbum);\n      const videos = readAlbumVideosByAlbumId(state.data, state.currentAlbum);\n\n      if (!album) {\n        return m(\"p\", \"Album not found\");\n      }\n\n      const { subjects, locations } = readThingsByAlbumId(\n        state.data,\n        state.currentAlbum,\n      );\n\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(AlbumPage, {\n              album,\n              subjects,\n              country: album.country || [],\n              locations,\n              photos,\n              videos,\n              services: state.services,\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function AboutApp(): m.Component<AppAttrs> {\n  return {\n    view() {\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(AboutPage),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function VideosApp(): m.Component<AppAttrs> {\n  return {\n    view() {\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(VideosPage, {\n              videos: readAllVideos(state.data),\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function PhotosApp(): m.Component<AppAttrs> {\n  return {\n    view() {\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(PhotosPage, {\n              photos: readAllPhotos(state.data),\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function ThingApp(): m.Component<AppAttrs> {\n  let things: TripleObject[] = [];\n\n  return {\n    view() {\n      const pair = m.route.param(\"pair\");\n      state.currentUrn = `urn:r\u00F3:${pair}`;\n\n      const parsed = asUrn(state.currentUrn);\n      if (parsed.id === \"*\") {\n        things = readNamedTypeThings(state.data, pair.split(\":\")[0]);\n      } else {\n        const thing = readThing(state.data, state.currentUrn);\n        if (thing) {\n          things = [thing];\n        }\n      }\n\n      if (!state.currentUrn) {\n        return m(\"p\", \"No thing selected\");\n      }\n\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(ThingPage, {\n              urn: state.currentUrn,\n              things,\n              services: state.services,\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function PhotoApp(): m.Component<AppAttrs> {\n  return {\n    oninit() {\n      const id = m.route.param(\"id\");\n      state.currentPhoto = `urn:r\u00F3:photo:${id}`;\n    },\n    view() {\n      if (!state.currentPhoto) {\n        return m(\"p\", \"No photo selected\");\n      }\n      const photo = readPhoto(state.data, state.currentPhoto);\n\n      if (!photo) {\n        return m(\"p\", \"Photo not found\");\n      }\n\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(PhotoPage, { photo, services: state.services }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nexport function ListingApp(): m.Component<AppAttrs> {\n  return {\n    oninit() {\n      const type = m.route.param(\"type\");\n      state.currentType = type;\n    },\n\n    view() {\n      if (!state.currentType) {\n        return m(\"p\", \"No type selected\");\n      }\n\n      const things = readNamedTypeThings(state.data, state.currentType);\n\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(ListingPage, {\n              type: state.currentType,\n              things,\n              services: state.services,\n            }),\n          ]),\n        ],\n      );\n    },\n  };\n}\n\nexport function ListingsApp(): m.Component<AppAttrs> {\n  return {\n    view() {\n      return m(\n        \"div.photos-app\",\n        { class: state.darkMode ? \"dark-mode\" : undefined },\n        [\n          m(Header, state),\n          m(\"div.app-container\", {\n            class: state.sidebarVisible ? \"sidebar-visible\" : undefined,\n          }, [\n            m(Sidebar, { visible: state.sidebarVisible }),\n            m(ListingsPage, {}),\n          ]),\n        ],\n      );\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { broadcast, navigate } from \"../commons/events.ts\";\n\ntype HeaderAttrs = {\n  darkMode: boolean;\n};\n\n/*\n * The sidebar menu\n */\nfunction BurgerMenu() {\n  const onclick = (_: Event) => {\n    broadcast(\"click_burger_menu\", {});\n  };\n\n  return {\n    view() {\n      return m(\"a\", { onclick }, m(\"span.burger\", \"\u039E\"));\n    },\n  };\n}\n\n/*\n * The link to the homepage\n */\nfunction HeaderBrandText() {\n  const BRAND_TEXT = \"photos\";\n\n  return {\n    view() {\n      return m(\"a\", {\n        href: \"#/\",\n        onclick: navigate(\"/\"),\n      }, m(\"span.brand\", BRAND_TEXT));\n    },\n  };\n}\n\n/*\n * The RSS icon. Roughly, \uD83D\uDEDC\n */\nfunction RSSIcon() {\n  const SVG_PATH = m(\"path\", {\n    fill: \"#ff9132\",\n    d: \"M 4.259,23.467c-2.35,0-4.259,1.917-4.259,4.252c0,2.349, 1.909,4.244, 4.259,4.244 c 2.358,0, 4.265-1.895, 4.265-4.244C 8.525,25.383, 6.618,23.467, 4.259,23.467zM 0.005,10.873l0,6.133 c 3.993,0, 7.749,1.562, 10.577,4.391c 2.825,2.822, 4.384,6.595, 4.384,10.603l 6.16,0 C 21.125,20.349, 11.648,10.873, 0.005,10.873zM 0.012,0l0,6.136 c 14.243,0, 25.836,11.604, 25.836,25.864L 32,32 C 32,14.36, 17.648,0, 0.012,0z\",\n  });\n\n  return {\n    view() {\n      return m(\n        \"a.rss\",\n        { title: \"rss\", href: \"/manifest/atom/atom-index.xml\" },\n        [\n          m(\"svg\", {\n            alt: \"rss\",\n            width: \"25px\",\n            height: \"25px\",\n            viewBox: \"0 0 32 32\",\n            style: \"position: relative; top: 5px;\",\n          }, [\n            SVG_PATH,\n          ]),\n        ],\n      );\n    },\n  };\n}\n\n/* */\nfunction ThemeSwitch() {\n  return {\n    view(vnode: m.Vnode<HeaderAttrs>) {\n      const text = vnode.attrs.darkMode ? \"\u2600\uFE0F\" : \"\uD83C\uDF19\";\n\n      return m(\n        \"a\",\n        {},\n        m(\"span.brand.switch\", {\n          onclick: () => {\n            broadcast(\"switch_theme\", {});\n          },\n        }, text),\n      );\n    },\n  };\n}\n\n/* */\nexport function Header() {\n  return {\n    view(vnode: m.Vnode<HeaderAttrs>) {\n      return m(\"nav.header\", { role: \"navigation\" }, [\n        // TODO this is a bad fix to an unknown reversion which messed up header item placement\n        // ideally we should find out what's actually wrong with the css, but for now...\n        // also, it doesn't work properly in Chrome\n        m(\"ul\", { style: \"display: ruby\" }, [\n          m(\"li.header-item\", {}, m(BurgerMenu())),\n          m(\"li.header-item\", {}, m(HeaderBrandText())),\n          m(\"li.rss-tag header-item\", { style: \"float: right\" }, m(RSSIcon())),\n          m(\n            \"li.header-item\",\n            { style: \"float: right\" },\n            m(ThemeSwitch(), {\n              darkMode: vnode.attrs.darkMode,\n            }),\n          ),\n        ]),\n      ]);\n    },\n  };\n}\n", "/*\n * Handle state-updates in response to events by delegating to other services. Handles\n * state-updates and rerenders.\n */\n\nimport type { ApplicationEvents } from \"../types.ts\";\n\n/*\n * Broadcast a custom application event to the document.\n */\nexport function broadcast(\n  label: ApplicationEvents,\n  detail: CustomEvent[\"detail\"],\n) {\n  console.info(`broadcasting event: ${label}`, detail);\n\n  (window as any).document.dispatchEvent(\n    new CustomEvent(label, {\n      detail,\n    }),\n  );\n}\n\n/*\n * Listen for custom application events.\n */\nexport function listen(\n  label: ApplicationEvents,\n  callback: (event: Event) => void,\n) {\n  (window as any).document.addEventListener(label, callback);\n}\n\n/*\n * Prevent default action for an event.\n *\n * @param event The event to block.\n */\nexport function block(event: Event) {\n  event?.preventDefault();\n}\n\n/*\n * Broadcast a navigation event and block the default action.\n *\n * @param route The route to navigate to.\n */\nexport function navigate(route: string) {\n  return (event: Event) => {\n    broadcast(\"navigate\", { route });\n    block(event);\n  };\n}\n", "/*\n * Manages dark mode preference in local storage\n */\nexport function load() {\n  return localStorage.getItem(\"darkMode\") === \"true\";\n}\n\nexport function save(value: boolean) {\n  return localStorage.setItem(\"darkMode\", `${value}`);\n}\n", "// src/sets.ts\nvar IndexedSet = class _IndexedSet {\n  #idx;\n  #map;\n  #reverseMap;\n  constructor() {\n    this.#idx = 0;\n    this.#map = /* @__PURE__ */ new Map();\n    this.#reverseMap = /* @__PURE__ */ new Map();\n  }\n  /*\n   * Return the underlying map of values to indices\n   */\n  map() {\n    return this.#map;\n  }\n  /*\n   * Return the underlying map of indices to values\n   */\n  reverseMap() {\n    return this.#reverseMap;\n  }\n  /*\n   * Add a value to the set, and return its index\n   */\n  add(value) {\n    if (this.#map.has(value)) {\n      return this.#map.get(value);\n    }\n    this.#map.set(value, this.#idx);\n    this.#reverseMap.set(this.#idx, value);\n    this.#idx++;\n    return this.#idx - 1;\n  }\n  /**\n   * Set the index for a value in the set\n   */\n  setIndex(value, index) {\n    this.#map.set(value, index);\n    this.#reverseMap.set(index, value);\n  }\n  /**\n   * Get the index for a value in the set\n   */\n  getIndex(value) {\n    return this.#map.get(value);\n  }\n  /**\n   * Set the values for an index in the set\n   */\n  getValue(idx) {\n    return this.#reverseMap.get(idx);\n  }\n  /**\n   * Does this structure have a value?\n   */\n  has(value) {\n    return this.#map.has(value);\n  }\n  clone() {\n    const newSet = new _IndexedSet();\n    for (const [key, value] of this.#map.entries()) {\n      newSet.setIndex(key, value);\n    }\n    return newSet;\n  }\n};\nvar Sets = class {\n  /*\n   * Compute the intersection of multiple numeric sets.\n   * The number of sets will be low (we're not adding ninety\n   * query parameters to these URNs) so first sort the\n   * sets in ascending size.\n   */\n  static intersection(metrics, sets) {\n    if (sets.length === 0) {\n      return /* @__PURE__ */ new Set();\n    }\n    sets.sort((setA, setB) => {\n      return setA.size - setB.size;\n    });\n    const acc = new Set(sets[0]);\n    for (let idx = 1; idx < sets.length; idx++) {\n      const currentSet = sets[idx];\n      for (const value of acc) {\n        metrics.setCheck();\n        if (!currentSet.has(value)) {\n          acc.delete(value);\n        }\n      }\n      if (acc.size === 0) {\n        break;\n      }\n    }\n    return acc;\n  }\n  /*\n   * Union two sets, and store the results in the left-hand-side set.\n   */\n  static append(set0, set1) {\n    for (const item of set1) {\n      set0.add(item);\n    }\n    return set0;\n  }\n  /*\n   * Compute the difference of two sets (set0 - set1)\n   */\n  static difference(set0, set1) {\n    const result = /* @__PURE__ */ new Set();\n    for (const item of set0) {\n      if (!set1.has(item)) {\n        result.add(item);\n      }\n    }\n    return result;\n  }\n};\n\n// src/tribble/parse.ts\nvar TribbleParser = class {\n  stringIndex;\n  constructor() {\n    this.stringIndex = new IndexedSet();\n  }\n  /*\n   * Parse a triple-line of tribble format text, and return a triple\n   */\n  parseTriple(line) {\n    const match = line.match(/^(\\d+) (\\d+) (\\d+)$/);\n    if (!match) {\n      throw new SyntaxError(`Invalid format for triple line: ${line}`);\n    }\n    const src = this.stringIndex.getValue(parseInt(match[1], 10));\n    const rel = this.stringIndex.getValue(parseInt(match[2], 10));\n    const tgt = this.stringIndex.getValue(parseInt(match[3], 10));\n    if (src === void 0 || rel === void 0 || tgt === void 0) {\n      throw new SyntaxError(`Invalid triple reference: ${line}`);\n    }\n    return [src, rel, tgt];\n  }\n  /*\n   * Parse a declaration line of tribble format text, and\n   * update the index.\n   */\n  parseDeclaration(line) {\n    const match = line.match(/^(\\d+) \"(.*)\"$/);\n    if (!match) {\n      throw new SyntaxError(`Invalid format for declaration line: ${line}`);\n    }\n    const id = match[1];\n    const value = match[2];\n    this.stringIndex.setIndex(value, parseInt(id, 10));\n  }\n  /*\n   * Parse a line of tribble format text, and return a triple when possible. Otherwise\n   * update the index.\n   */\n  parse(line) {\n    const isTriple = /^(\\d+)\\s(\\d+)\\s(\\d+)$/;\n    if (isTriple.test(line)) {\n      return this.parseTriple(line);\n    } else {\n      this.parseDeclaration(line);\n      return;\n    }\n  }\n};\n\n// src/tribble/stringify.ts\nvar TribbleStringifier = class {\n  stringIndex;\n  constructor() {\n    this.stringIndex = new IndexedSet();\n  }\n  /*\n   * Convert a triple to tribble format and return the encoding.\n   */\n  stringify(triple) {\n    const message = [];\n    const [source, relation, target] = triple;\n    for (const value of triple) {\n      if (!this.stringIndex.has(value)) {\n        const newId = this.stringIndex.add(value);\n        const stringifiedValue = value === \"null\" || value === null ? JSON.stringify(\"null\") : JSON.stringify(value.toString());\n        message.push(`${newId} ${stringifiedValue}`);\n      }\n    }\n    message.push(\n      `${this.stringIndex.getIndex(source)} ${this.stringIndex.getIndex(relation)} ${this.stringIndex.getIndex(target)}`\n    );\n    return message.join(\"\\n\");\n  }\n};\n\n// src/urn.ts\nfunction parseUrn(urn, namespace = \"r\\xF3\") {\n  if (!urn.startsWith(`urn:${namespace}:`)) {\n    throw new Error(`Invalid URN for namespace ${namespace}: ${urn}`);\n  }\n  const delimited = urn.split(\":\");\n  const type = delimited[2];\n  const idx = urn.indexOf(\"?\");\n  const queryString = idx !== -1 ? urn.slice(idx + 1) : \"\";\n  const id = idx !== -1 ? delimited[3].slice(0, delimited[3].indexOf(\"?\")) : delimited[3];\n  const qs = queryString ? Object.fromEntries(new URLSearchParams(queryString)) : {};\n  return {\n    type,\n    id,\n    qs\n  };\n}\nfunction asUrn(value, namespace = \"r\\xF3\") {\n  if (typeof value !== \"string\" || !value.startsWith(`urn:${namespace}:`)) {\n    return {\n      type: \"unknown\",\n      id: value,\n      qs: {}\n    };\n  }\n  return parseUrn(value, namespace);\n}\n\n// src/metrics.ts\nvar IndexPerformanceMetrics = class _IndexPerformanceMetrics {\n  mapReadCount;\n  constructor() {\n    this.mapReadCount = 0;\n  }\n  mapRead() {\n    this.mapReadCount++;\n  }\n  clone() {\n    const clone = new _IndexPerformanceMetrics();\n    clone.mapReadCount = this.mapReadCount;\n    return clone;\n  }\n};\nvar TribbleDBPerformanceMetrics = class _TribbleDBPerformanceMetrics {\n  setCheckCount;\n  constructor() {\n    this.setCheckCount = 0;\n  }\n  setCheck() {\n    this.setCheckCount++;\n  }\n  clone() {\n    const clone = new _TribbleDBPerformanceMetrics();\n    clone.setCheckCount = this.setCheckCount;\n    return clone;\n  }\n};\n\n// src/indices/index.ts\nvar Index = class _Index {\n  // Internal indexed representation for memory efficiency\n  indexedTriples;\n  // Metadata cache for efficient deletion\n  tripleMetadata;\n  // String indexing sets for memory efficiency\n  stringIndex;\n  tripleHashes;\n  hashIndices;\n  sourceType;\n  sourceId;\n  // note: QS uses a composite key: <key>=<value>\n  sourceQs;\n  relations;\n  targetType;\n  targetId;\n  targetQs;\n  metrics;\n  stringUrn;\n  constructor(triples) {\n    this.indexedTriples = [];\n    this.tripleMetadata = /* @__PURE__ */ new Map();\n    this.stringIndex = new IndexedSet();\n    this.tripleHashes = /* @__PURE__ */ new Set();\n    this.hashIndices = /* @__PURE__ */ new Map();\n    this.sourceType = /* @__PURE__ */ new Map();\n    this.sourceId = /* @__PURE__ */ new Map();\n    this.sourceQs = /* @__PURE__ */ new Map();\n    this.relations = /* @__PURE__ */ new Map();\n    this.targetType = /* @__PURE__ */ new Map();\n    this.targetId = /* @__PURE__ */ new Map();\n    this.targetQs = /* @__PURE__ */ new Map();\n    this.stringUrn = /* @__PURE__ */ new Map();\n    this.add(triples);\n    this.metrics = new IndexPerformanceMetrics();\n  }\n  /*\n   * Delete triples from the index\n   */\n  delete(triples) {\n    for (let idx = 0; idx < triples.length; idx++) {\n      const triple = triples[idx];\n      const tripleHash = this.hashTriple(triple);\n      const tripleIndex = this.hashIndices.get(tripleHash);\n      if (tripleIndex === void 0) {\n        continue;\n      }\n      this.tripleHashes.delete(tripleHash);\n      this.hashIndices.delete(tripleHash);\n      const metadata = this.tripleMetadata.get(tripleIndex);\n      if (metadata) {\n        this.sourceType.get(metadata.sourceTypeIdx)?.delete(tripleIndex);\n        this.sourceId.get(metadata.sourceIdIdx)?.delete(tripleIndex);\n        this.relations.get(metadata.relationIdx)?.delete(tripleIndex);\n        this.targetType.get(metadata.targetTypeIdx)?.delete(tripleIndex);\n        this.targetId.get(metadata.targetIdIdx)?.delete(tripleIndex);\n        for (const qsIdx of metadata.sourceQsIndices) {\n          this.sourceQs.get(qsIdx)?.delete(tripleIndex);\n        }\n        for (const qsIdx of metadata.targetQsIndices) {\n          this.targetQs.get(qsIdx)?.delete(tripleIndex);\n        }\n        this.tripleMetadata.delete(tripleIndex);\n      }\n      delete this.indexedTriples[tripleIndex];\n    }\n  }\n  /*\n   * Return the triples that are absent from the index\n   */\n  difference(triples) {\n    return triples.filter((triple) => !this.hasTriple(triple));\n  }\n  /*\n   * Check if a triple is present in the index\n   */\n  hasTriple(triple) {\n    return this.tripleHashes.has(this.hashTriple(triple));\n  }\n  /*\n   * Generate a simple hash for a triple\n   */\n  hashTriple(triple) {\n    const str = `${triple[0]}${triple[1]}${triple[2]}`;\n    let hash = 0;\n    for (let i = 0, len = str.length; i < len; i++) {\n      const chr = str.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0;\n    }\n    return hash.toString();\n  }\n  /*\n   * Get the index of a specific triple\n   */\n  getTripleIndex(triple) {\n    const hash = this.hashTriple(triple);\n    return this.hashIndices.get(hash);\n  }\n  /*\n   * Add new triples to the index incrementally\n   */\n  add(triples) {\n    for (let jdx = 0; jdx < triples.length; jdx++) {\n      const triple = triples[jdx];\n      const source = triple[0];\n      const relation = triple[1];\n      const target = triple[2];\n      let parsedSource = this.stringUrn.get(source);\n      if (!parsedSource) {\n        parsedSource = asUrn(source);\n        this.stringUrn.set(source, parsedSource);\n      }\n      let parsedTarget = this.stringUrn.get(target);\n      if (!parsedTarget) {\n        parsedTarget = asUrn(target);\n        this.stringUrn.set(target, parsedTarget);\n      }\n      const sourceIdx = this.stringIndex.add(source);\n      const relationIdx = this.stringIndex.add(relation);\n      const targetIdx = this.stringIndex.add(target);\n      const sourceTypeIdx = this.stringIndex.add(parsedSource.type);\n      const sourceIdIdx = this.stringIndex.add(parsedSource.id);\n      const targetTypeIdx = this.stringIndex.add(parsedTarget.type);\n      const targetIdIdx = this.stringIndex.add(parsedTarget.id);\n      const hash = this.hashTriple(triple);\n      if (this.tripleHashes.has(hash)) {\n        continue;\n      }\n      this.tripleHashes.add(hash);\n      const idx = this.indexedTriples.length;\n      this.hashIndices.set(hash, idx);\n      this.indexedTriples.push([sourceIdx, relationIdx, targetIdx]);\n      const sourceQsIndices = [];\n      const targetQsIndices = [];\n      let sourceTypeSet = this.sourceType.get(sourceTypeIdx);\n      if (!sourceTypeSet) {\n        sourceTypeSet = /* @__PURE__ */ new Set();\n        this.sourceType.set(sourceTypeIdx, sourceTypeSet);\n      }\n      sourceTypeSet.add(idx);\n      let sourceIdSet = this.sourceId.get(sourceIdIdx);\n      if (!sourceIdSet) {\n        sourceIdSet = /* @__PURE__ */ new Set();\n        this.sourceId.set(sourceIdIdx, sourceIdSet);\n      }\n      sourceIdSet.add(idx);\n      for (const [key, val] of Object.entries(parsedSource.qs)) {\n        const qsIdx = this.stringIndex.add(`${key}=${val}`);\n        sourceQsIndices.push(qsIdx);\n        let sourceQsSet = this.sourceQs.get(qsIdx);\n        if (!sourceQsSet) {\n          sourceQsSet = /* @__PURE__ */ new Set();\n          this.sourceQs.set(qsIdx, sourceQsSet);\n        }\n        sourceQsSet.add(idx);\n      }\n      let relationSet = this.relations.get(relationIdx);\n      if (!relationSet) {\n        relationSet = /* @__PURE__ */ new Set();\n        this.relations.set(relationIdx, relationSet);\n      }\n      relationSet.add(idx);\n      let targetTypeSet = this.targetType.get(targetTypeIdx);\n      if (!targetTypeSet) {\n        targetTypeSet = /* @__PURE__ */ new Set();\n        this.targetType.set(targetTypeIdx, targetTypeSet);\n      }\n      targetTypeSet.add(idx);\n      let targetIdSet = this.targetId.get(targetIdIdx);\n      if (!targetIdSet) {\n        targetIdSet = /* @__PURE__ */ new Set();\n        this.targetId.set(targetIdIdx, targetIdSet);\n      }\n      targetIdSet.add(idx);\n      for (const [key, val] of Object.entries(parsedTarget.qs)) {\n        const qsIdx = this.stringIndex.add(`${key}=${val}`);\n        targetQsIndices.push(qsIdx);\n        let targetQsSet = this.targetQs.get(qsIdx);\n        if (!targetQsSet) {\n          targetQsSet = /* @__PURE__ */ new Set();\n          this.targetQs.set(qsIdx, targetQsSet);\n        }\n        targetQsSet.add(idx);\n      }\n      this.tripleMetadata.set(idx, {\n        sourceTypeIdx,\n        sourceIdIdx,\n        sourceQsIndices,\n        relationIdx,\n        targetTypeIdx,\n        targetIdIdx,\n        targetQsIndices\n      });\n    }\n  }\n  /*\n   * Get the number of triples in the index\n   */\n  get length() {\n    return this.tripleHashes.size;\n  }\n  /*\n   * Get the actual array length including gaps (for cursor index management)\n   */\n  get arrayLength() {\n    return this.indexedTriples.length;\n  }\n  /*\n   * Reconstruct the original triples from the indexed representation\n   */\n  triples() {\n    return this.indexedTriples.filter((triple) => triple !== void 0).map(([sourceIdx, relationIdx, targetIdx]) => [\n      this.stringIndex.getValue(sourceIdx),\n      this.stringIndex.getValue(relationIdx),\n      this.stringIndex.getValue(targetIdx)\n    ]);\n  }\n  /*\n   * Get a specific triple by index\n   */\n  getTriple(index) {\n    if (index < 0 || index >= this.indexedTriples.length) {\n      return void 0;\n    }\n    const indexedTriple = this.indexedTriples[index];\n    if (!indexedTriple) {\n      return void 0;\n    }\n    const [sourceIdx, relationIdx, targetIdx] = indexedTriple;\n    return [\n      this.stringIndex.getValue(sourceIdx),\n      this.stringIndex.getValue(relationIdx),\n      this.stringIndex.getValue(targetIdx)\n    ];\n  }\n  /*\n   * Get the string indices for a specific triple by triple index\n   */\n  getTripleIndices(index) {\n    if (index < 0 || index >= this.indexedTriples.length) {\n      return void 0;\n    }\n    return this.indexedTriples[index];\n  }\n  /*\n   * Helper methods to convert string keys to indices for external API compatibility\n   */\n  getSourceTypeSet(type) {\n    const typeIdx = this.stringIndex.getIndex(type);\n    if (typeIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.sourceType.get(typeIdx);\n  }\n  getSourceIdSet(id) {\n    const idIdx = this.stringIndex.getIndex(id);\n    if (idIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.sourceId.get(idIdx);\n  }\n  getSourceQsSet(key, val) {\n    const qsIdx = this.stringIndex.getIndex(`${key}=${val}`);\n    if (qsIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.sourceQs.get(qsIdx);\n  }\n  getRelationSet(relation) {\n    const relationIdx = this.stringIndex.getIndex(relation);\n    if (relationIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.relations.get(relationIdx);\n  }\n  getTargetTypeSet(type) {\n    const typeIdx = this.stringIndex.getIndex(type);\n    if (typeIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.targetType.get(typeIdx);\n  }\n  getTargetIdSet(id) {\n    const idIdx = this.stringIndex.getIndex(id);\n    if (idIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.targetId.get(idIdx);\n  }\n  getTargetQsSet(key, val) {\n    const qsIdx = this.stringIndex.getIndex(`${key}=${val}`);\n    if (qsIdx === void 0) {\n      return void 0;\n    }\n    this.metrics.mapRead();\n    return this.targetQs.get(qsIdx);\n  }\n  /*\n   * Deep-clone the index\n   */\n  clone() {\n    const newIndex = new _Index([]);\n    newIndex.indexedTriples = this.indexedTriples.slice();\n    newIndex.tripleMetadata = new Map(this.tripleMetadata);\n    newIndex.stringIndex = this.stringIndex.clone();\n    newIndex.tripleHashes = new Set(this.tripleHashes);\n    newIndex.hashIndices = new Map(this.hashIndices);\n    const cloneMap = (original) => {\n      const newMap = /* @__PURE__ */ new Map();\n      for (const [key, valueSet] of original.entries()) {\n        newMap.set(key, new Set(valueSet));\n      }\n      return newMap;\n    };\n    newIndex.sourceType = cloneMap(this.sourceType);\n    newIndex.sourceId = cloneMap(this.sourceId);\n    newIndex.sourceQs = cloneMap(this.sourceQs);\n    newIndex.relations = cloneMap(this.relations);\n    newIndex.targetType = cloneMap(this.targetType);\n    newIndex.targetId = cloneMap(this.targetId);\n    newIndex.targetQs = cloneMap(this.targetQs);\n    newIndex.stringUrn = new Map(this.stringUrn);\n    newIndex.metrics = this.metrics.clone();\n    return newIndex;\n  }\n};\n\n// src/triples.ts\nvar Triples = class {\n  static source(triple) {\n    return triple[0];\n  }\n  static relation(triple) {\n    return triple[1];\n  }\n  static target(triple) {\n    return triple[2];\n  }\n};\n\n// src/db/search.ts\nfunction validateInput(params) {\n  const allowedKeys = [\"source\", \"relation\", \"target\"];\n  if (!Array.isArray(params)) {\n    for (const key of Object.keys(params)) {\n      if (!Object.prototype.hasOwnProperty.call(params, key)) continue;\n      if (!allowedKeys.includes(key)) {\n        throw new Error(`Unexpected search parameter: ${key}`);\n      }\n    }\n  }\n}\nfunction nodeTypeMatches(type, source, index) {\n  const matches = source ? index.getSourceTypeSet(type) : index.getTargetTypeSet(type);\n  if (matches === void 0 || matches.size === 0) {\n    return /* @__PURE__ */ new Set();\n  }\n  return matches;\n}\nfunction nodeIdMatches(id, source, index) {\n  const matches = /* @__PURE__ */ new Set();\n  const ids = Array.isArray(id) ? id : [id];\n  for (const subid of ids) {\n    const subidRows = source ? index.getSourceIdSet(subid) : index.getTargetIdSet(subid);\n    if (subidRows) {\n      Sets.append(matches, subidRows);\n    }\n  }\n  if (matches.size === 0) {\n    return /* @__PURE__ */ new Set();\n  }\n  return matches;\n}\nfunction nodeQsMatches(qs, source, index, metrics) {\n  const matches = [];\n  for (const [key, val] of Object.entries(qs)) {\n    const qsSet = source ? index.getSourceQsSet(key, val) : index.getTargetQsSet(key, val);\n    if (typeof qsSet === \"undefined\") {\n      return /* @__PURE__ */ new Set();\n    }\n    matches.push(qsSet);\n  }\n  return Sets.intersection(metrics, matches);\n}\nfunction nodeMatches(query, source, index, metrics, cursorIndices) {\n  let typeRows = void 0;\n  if (query.type) {\n    typeRows = nodeTypeMatches(query.type, source, index);\n    if (typeRows.size === 0) {\n      return /* @__PURE__ */ new Set();\n    }\n  }\n  let idRows = void 0;\n  if (query.id) {\n    idRows = nodeIdMatches(query.id, source, index);\n    if (idRows.size === 0) {\n      return /* @__PURE__ */ new Set();\n    }\n  }\n  let qsRows = void 0;\n  if (query.qs && Object.keys(query.qs).length > 0) {\n    qsRows = nodeQsMatches(query.qs, source, index, metrics);\n    if (qsRows.size === 0) {\n      return /* @__PURE__ */ new Set();\n    }\n  }\n  if (typeRows === void 0 && idRows === void 0 && qsRows === void 0) {\n    const pred2 = query.predicate;\n    if (!pred2) {\n      return cursorIndices;\n    }\n    const indexCopy = /* @__PURE__ */ new Set([...cursorIndices]);\n    for (const idx of indexCopy) {\n      const triple = index.getTriple(idx);\n      if (!triple) {\n        indexCopy.delete(idx);\n        continue;\n      }\n      if (!pred2(source ? triple[0] : triple[2])) {\n        indexCopy.delete(idx);\n      }\n    }\n    return indexCopy;\n  }\n  const matches = [cursorIndices];\n  if (typeRows !== void 0) {\n    matches.push(typeRows);\n  }\n  if (idRows !== void 0) {\n    matches.push(idRows);\n  }\n  if (qsRows !== void 0) {\n    matches.push(qsRows);\n  }\n  const matchingRows = Sets.intersection(metrics, matches);\n  if (!query.predicate) {\n    return matchingRows;\n  }\n  const pred = query.predicate;\n  for (const idx of matchingRows) {\n    const triple = index.getTriple(idx);\n    if (!pred(source ? triple[0] : triple[2])) {\n      matchingRows.delete(idx);\n    }\n  }\n  return matchingRows;\n}\nfunction findMatchingNodes(query, source, index, metrics, cursorIndices) {\n  const matches = /* @__PURE__ */ new Set();\n  for (const subquery of query) {\n    Sets.append(\n      matches,\n      nodeMatches(subquery, source, index, metrics, cursorIndices)\n    );\n  }\n  return matches;\n}\nfunction findMatchingRelations(query, index) {\n  const relations = Array.isArray(query.relation) ? query.relation : [query.relation];\n  const matches = /* @__PURE__ */ new Set();\n  for (const rel of relations) {\n    const relationSet = index.getRelationSet(rel);\n    if (relationSet) {\n      Sets.append(matches, relationSet);\n    }\n  }\n  if (!query.predicate) {\n    return matches;\n  }\n  const pred = query.predicate;\n  for (const idx of matches) {\n    const triple = index.getTriple(idx);\n    if (!triple) {\n      matches.delete(idx);\n      continue;\n    }\n    if (!pred(triple[1])) {\n      matches.delete(idx);\n    }\n  }\n  return matches;\n}\nfunction findMatchingRows(params, index, cursorIndices, metrics) {\n  const { source, relation, target } = params;\n  const matchingRowSets = [];\n  if (source) {\n    const input = Array.isArray(source) ? source : [source];\n    const matches = findMatchingNodes(\n      input,\n      true,\n      index,\n      metrics,\n      cursorIndices\n    );\n    matchingRowSets.push(matches);\n  }\n  if (relation) {\n    matchingRowSets.push(findMatchingRelations(relation, index));\n  }\n  if (target) {\n    const input = Array.isArray(target) ? target : [target];\n    const matches = findMatchingNodes(\n      input,\n      false,\n      index,\n      metrics,\n      cursorIndices\n    );\n    matchingRowSets.push(matches);\n  }\n  if (matchingRowSets.length === 0) {\n    return cursorIndices;\n  }\n  return Sets.intersection(metrics, matchingRowSets);\n}\n\n// src/db/inputs.ts\nfunction isUrn(value) {\n  return value.startsWith(`urn:`);\n}\nfunction parseNodeSearch(search) {\n  if (typeof search === \"string\") {\n    return isUrn(search) ? [asUrn(search)] : [{\n      type: \"unknown\",\n      id: search\n    }];\n  }\n  if (Array.isArray(search)) {\n    return search.map((subsearch) => {\n      return isUrn(subsearch) ? asUrn(subsearch) : {\n        type: \"unknown\",\n        id: subsearch\n      };\n    });\n  }\n  return [search];\n}\nfunction parseRelation(search) {\n  return typeof search === \"string\" || Array.isArray(search) ? { relation: search } : search;\n}\nfunction parseSearch(search) {\n  const source = Array.isArray(search) ? search[0] : search.source;\n  const relation = Array.isArray(search) ? search[1] : search.relation;\n  const target = Array.isArray(search) ? search[2] : search.target;\n  const out = {};\n  if (source) {\n    out.source = parseNodeSearch(source);\n  }\n  if (relation) {\n    out.relation = parseRelation(relation);\n  }\n  if (target) {\n    out.target = parseNodeSearch(target);\n  }\n  return out;\n}\n\n// src/tribble-db.ts\nvar TribbleDB = class _TribbleDB {\n  index;\n  triplesCount;\n  cursorIndices;\n  metrics;\n  validations;\n  constructor(triples, validations = {}) {\n    this.index = new Index(triples);\n    this.triplesCount = this.index.length;\n    this.cursorIndices = /* @__PURE__ */ new Set();\n    this.metrics = new TribbleDBPerformanceMetrics();\n    this.validations = validations;\n    for (let idx = 0; idx < this.triplesCount; idx++) {\n      this.cursorIndices.add(idx);\n    }\n  }\n  /*\n   * Clone the database.\n   *\n   * @returns A new TribbleDB instance, constructed with the same data as the original.\n   */\n  clone() {\n    const clonedDB = new _TribbleDB([]);\n    clonedDB.index = this.index;\n    clonedDB.triplesCount = this.triplesCount;\n    clonedDB.cursorIndices = this.cursorIndices;\n    clonedDB.metrics = this.metrics;\n    return clonedDB;\n  }\n  /*\n   * Convert an array of triples to a TribbleDB.\n   */\n  static of(triples) {\n    return new _TribbleDB(triples);\n  }\n  /*\n   * Convert an array of TripleObject instances to a TribbleDB.\n   *\n   * @param objects - An array of TripleObject instances.\n   *\n   * @returns A TribbleDB instance.\n   */\n  static from(objects) {\n    const triples = [];\n    for (const obj of objects) {\n      const { id, ...relations } = obj;\n      if (typeof id !== \"string\") {\n        throw new Error(\"Each TripleObject must have a string id.\");\n      }\n      for (const [relation, target] of Object.entries(relations)) {\n        if (Array.isArray(target)) {\n          for (const sub of target) {\n            triples.push([id, relation, sub]);\n          }\n        } else {\n          triples.push([id, relation, target]);\n        }\n      }\n    }\n    return new _TribbleDB(triples);\n  }\n  /*\n   * Validate triples against the provided validation functions.\n   *\n   * @param triples - An array of triples to validate.\n   */\n  validateTriples(triples) {\n    const messages = [];\n    for (const [source, relation, target] of triples) {\n      const validator = this.validations[relation];\n      if (!validator) {\n        continue;\n      }\n      const { type } = asUrn(source);\n      const res = validator(type, relation, target);\n      if (typeof res === \"string\") {\n        messages.push(res);\n      }\n    }\n    if (messages.length > 0) {\n      throw new Error(`Triple validation failed:\n- ${messages.join(\"\\n- \")}`);\n    }\n  }\n  /**\n   * Add new triples to the database.\n   *\n   * @param triples - An array of triples to add.\n   */\n  add(triples) {\n    const oldLength = this.index.arrayLength;\n    this.validateTriples(triples);\n    this.index.add(triples);\n    this.triplesCount = this.index.length;\n    for (let idx = oldLength; idx < this.index.arrayLength; idx++) {\n      this.cursorIndices.add(idx);\n    }\n  }\n  /**\n   * Map over the triples in the database.\n   *\n   * @param fn - A mapping function.\n   * @returns A new TribbleDB instance containing the mapped triples.\n   */\n  map(fn) {\n    return new _TribbleDB(this.index.triples().map(fn));\n  }\n  /**\n   * Flatmap over the triples in the database. This can be used to add new triples\n   * to a copy of the database.\n   *\n   * @param fn - A mapping function.\n   * @returns A new TribbleDB instance containing the flat-mapped triples.\n   */\n  flatMap(fn) {\n    const flatMappedTriples = this.index.triples().flatMap(fn);\n    const newDb = new _TribbleDB([]);\n    newDb.index = this.index.clone();\n    newDb.add(flatMappedTriples);\n    return newDb;\n  }\n  /*\n   * Deduplicate an array of triples using hash-based comparison.\n   *\n   * @param triples - An array of triples that may contain duplicates.\n   * @returns A new array with duplicate triples removed.\n   */\n  deduplicateTriples(triples) {\n    const seen = /* @__PURE__ */ new Set();\n    const result = [];\n    for (const triple of triples) {\n      const hash = this.index.hashTriple(triple);\n      if (!seen.has(hash)) {\n        seen.add(hash);\n        result.push(triple);\n      }\n    }\n    return result;\n  }\n  /*\n   * Perform an in-place flatmap over this database. This works by:\n   * - Searching the database to get a subset of triples\n   * - Flatmapping those triples\n   * - Deleting any triples from the original subset that are no longer present after the flatmap\n   * - Adding all new triples to the database\n   *\n   * @param search - The search parameters to subset the database.\n   * @param fn - A mapping function to apply to each triple in the search result.\n   *\n   * @returns This TribbleDB instance.\n   */\n  searchFlatmap(search, fn) {\n    const searchResults = this.search(search);\n    const matchingTriples = searchResults.triples();\n    const transformedTriples = matchingTriples.flatMap(fn);\n    const deduplicatedTransformed = this.deduplicateTriples(transformedTriples);\n    const originalHashMap = /* @__PURE__ */ new Map();\n    for (const triple of matchingTriples) {\n      const hash = this.index.hashTriple(triple);\n      originalHashMap.set(hash, triple);\n    }\n    const transformedHashMap = /* @__PURE__ */ new Map();\n    for (const triple of deduplicatedTransformed) {\n      const hash = this.index.hashTriple(triple);\n      transformedHashMap.set(hash, triple);\n    }\n    const triplesToDelete = [];\n    const triplesToAdd = [];\n    for (const [hash, triple] of originalHashMap) {\n      if (!transformedHashMap.has(hash)) {\n        triplesToDelete.push(triple);\n      }\n    }\n    for (const [hash, triple] of transformedHashMap) {\n      if (!originalHashMap.has(hash)) {\n        triplesToAdd.push(triple);\n      }\n    }\n    this.delete(triplesToDelete);\n    this.add(triplesToAdd);\n    return this;\n  }\n  /**\n   * Get the first triple in the database.\n   *\n   * @returns The first triple, or undefined if there are no triples.\n   */\n  firstTriple() {\n    return this.index.length > 0 ? this.index.getTriple(0) : void 0;\n  }\n  /*\n   * Get the first source in the database.\n   */\n  firstSource() {\n    const first = this.firstTriple();\n    return first ? Triples.source(first) : void 0;\n  }\n  /**\n   * Get the first relation in the database.\n   */\n  firstRelation() {\n    const first = this.firstTriple();\n    return first ? Triples.relation(first) : void 0;\n  }\n  /**\n   * Get the first target in the database.\n   */\n  firstTarget() {\n    const first = this.firstTriple();\n    return first ? Triples.target(first) : void 0;\n  }\n  /*\n   * Get the first object in the database.\n   */\n  firstObject(listOnly = false) {\n    let firstId = void 0;\n    const obj = {};\n    for (const [source, relation, target] of this.index.triples()) {\n      if (firstId === void 0) {\n        firstId = source;\n        obj.id = source;\n      }\n      if (firstId !== source) {\n        continue;\n      }\n      if (!obj[relation]) {\n        obj[relation] = listOnly ? [target] : target;\n      } else if (Array.isArray(obj[relation])) {\n        if (!obj[relation].includes(target)) {\n          obj[relation].push(target);\n        }\n      } else {\n        obj[relation] = obj[relation] === target ? obj[relation] : [obj[relation], target];\n      }\n    }\n    return Object.keys(obj).length > 0 ? obj : void 0;\n  }\n  /*\n   * Get all triples in the database.\n   *\n   * @returns An array of all triples.\n   */\n  triples() {\n    return this.index.triples();\n  }\n  /**\n   * Get all unique sources in the database.\n   *\n   * @returns A set of all unique sources.\n   */\n  sources() {\n    return new Set(\n      this.index.triples().map(Triples.source)\n    );\n  }\n  /**\n   * Get all unique relations in the database.\n   *\n   * @returns A set of all unique relations.\n   */\n  relations() {\n    return new Set(\n      this.index.triples().map(Triples.relation)\n    );\n  }\n  /**\n   * Get all unique targets in the database.\n   *\n   * @returns A set of all unique targets.\n   */\n  targets() {\n    return new Set(\n      this.index.triples().map(Triples.target)\n    );\n  }\n  /*\n   * Get all unique objects represented by the triples.\n   *\n   * @returns An array of unique TripleObject instances.\n   */\n  objects(listOnly = false) {\n    const output = [];\n    for (const [id, obj] of Object.entries(this.#object(listOnly))) {\n      obj.id = id;\n      output.push(obj);\n    }\n    return output;\n  }\n  /*\n   * Internal function; convert all triples to an object representation.\n   *\n   * @param listOnly - Whether to always represent relation values as lists.\n   */\n  #object(listOnly = false) {\n    const objs = {};\n    for (const [source, relation, target] of this.index.triples()) {\n      if (!objs[source]) {\n        objs[source] = { id: source };\n      }\n      const relationRef = objs[source][relation];\n      if (!relationRef) {\n        objs[source][relation] = listOnly ? [target] : target;\n      } else if (Array.isArray(relationRef)) {\n        if (!relationRef.includes(target)) {\n          relationRef.push(target);\n        }\n      } else {\n        objs[source][relation] = relationRef === target ? relationRef : [relationRef, target];\n      }\n    }\n    return objs;\n  }\n  /*\n   * Search across all triples in the database. There are two forms of query possible:\n   *\n   * - Object: { source?, relation?, target }\n   * - Array: [ source?, relation?, target? ]\n   *\n   * @param params - The search parameters.\n   * @returns A new TribbleDB instance containing the matching triples.\n   */\n  search(params) {\n    const parsed = parseSearch(params);\n    validateInput(parsed);\n    const matchingTriples = [];\n    for (const rowIdx of findMatchingRows(\n      parsed,\n      this.index,\n      this.cursorIndices,\n      this.metrics\n    )) {\n      const triple = this.index.getTriple(rowIdx);\n      if (triple !== void 0) {\n        matchingTriples.push(triple);\n      }\n    }\n    return new _TribbleDB(matchingTriples);\n  }\n  /*\n   * Get performance metrics for the database.\n   */\n  getMetrics() {\n    return {\n      index: this.index.metrics,\n      db: this.metrics\n    };\n  }\n  /*\n   * Read a single object from the data by urn. If not a urn, the\n   * value is used as an id and the type is the default type `unknown`. By default,\n   * query-strings are disregarded.\n   */\n  readThing(urn, opts = { qs: false }) {\n    if (opts.qs) {\n      const { type, id } = asUrn(urn);\n      return this.search({ source: { type, id } }).firstObject();\n    } else {\n      return this.search({ source: urn }).firstObject();\n    }\n  }\n  /*\n   * Read a set of URNs, and return any matching results. Ordered but not guaranteed to\n   * return a match for all provided URNs.\n   */\n  readThings(urns, opts = { qs: false }) {\n    const results = [];\n    for (const urn of urns) {\n      const thing = this.readThing(urn, opts);\n      if (thing !== void 0) {\n        results.push(thing);\n      }\n    }\n    return results;\n  }\n  /*\n   * Read and parse a triple object. On missing data or parse failure return undefined (or throw an exception)\n   */\n  parseThing(parser, urn, opts = { qs: false }) {\n    const thing = this.readThing(urn, opts);\n    if (thing) {\n      return parser(thing);\n    } else {\n      return void 0;\n    }\n  }\n  /*\n   * Read and parse a collection of triple objects. Skip over missing data or parse failures.\n   */\n  parseThings(parser, urns, opts = { qs: false }) {\n    const results = [];\n    for (const urn of urns) {\n      const res = this.parseThing(parser, urn, opts);\n      if (res) {\n        results.push(res);\n      }\n    }\n    return results;\n  }\n  /*\n   * Merge another TribbleDB into this one.\n   *\n   * @param other - The other TribbleDB to merge.\n   * @returns This TribbleDB instance.\n   */\n  merge(other) {\n    this.add(other.triples());\n    return this;\n  }\n  /*\n   * Delete triples from the database.\n   *\n   * @param triples - An array of triples to delete.\n   * @returns This TribbleDB instance.\n   */\n  delete(triples) {\n    const indicesToDelete = /* @__PURE__ */ new Set();\n    for (const triple of triples) {\n      const tripleIndex = this.index.getTripleIndex(triple);\n      if (tripleIndex !== void 0) {\n        indicesToDelete.add(tripleIndex);\n      }\n    }\n    this.index.delete(triples);\n    this.triplesCount = this.index.length;\n    for (const idx of indicesToDelete) {\n      this.cursorIndices.delete(idx);\n    }\n    return this;\n  }\n};\nexport {\n  TribbleDB,\n  TribbleParser,\n  TribbleStringifier,\n  asUrn,\n  parseUrn\n};\n", "/*\n * Load tribblefile from a URL as a stream of triples.\n */\n\nimport { TribbleDB } from \"@rgrannell1/tribbledb\";\nimport type { Triple } from \"@rgrannell1/tribbledb\";\nimport { TribbleParser } from \"@rgrannell1/tribbledb\";\n\n/*\n * Stream triples from a URL\n *\n * @param url The URL to fetch triples from\n */\nexport async function* streamTribbles(url: string): AsyncGenerator<Triple[]> {\n  const parser = new TribbleParser();\n  const res = await fetch(url);\n  if (!res.body) {\n    throw new Error(\"No response body\");\n  }\n\n  const decoder = new TextDecoderStream();\n  const reader = res.body.pipeThrough(decoder).getReader();\n  let buffer = \"\";\n\n  // rather than yield 20k times, yield a few larger batches...\n  // experimentally, 500 items seems about right\n  const tripleBuffer: Triple[] = [];\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    buffer += value;\n    const lines = buffer.split(\"\\n\");\n    buffer = lines.pop() ?? \"\";\n    for (const line of lines) {\n      const triple = parser.parse(line);\n      if (triple !== undefined) {\n        tripleBuffer.push(triple);\n      }\n\n      if (tripleBuffer.length >= 500) {\n        yield [...tripleBuffer];\n        tripleBuffer.length = 0;\n      }\n    }\n  }\n\n  // parse any remaining line in buffer\n  if (buffer.length > 0) {\n    const triple = parser.parse(buffer);\n    if (triple !== undefined) {\n      tripleBuffer.push(triple);\n    }\n  }\n\n  // and yield any leftover triples\n  if (tripleBuffer.length > 0) {\n    yield [...tripleBuffer];\n  }\n}\n\nlet tdb: TribbleDB | null = null;\n\n/*\n * Load triples from a URL. This takes about 500ms to run (Oct 27 2025) and\n * takes about 60% of load-time of the page. This needs to be reworked, as in the litelement\n * version, to incrementally stream load the database while allowing the page to render.\n *\n * For now, lets make blocking load faster than 500ms...\n *\n * October 28 2025: about 250ms now\n */\nexport async function loadTriples(\n  url: string,\n  schema: Record<string, any> = {},\n  perTriple: (triple: Triple) => Triple[] = (x) => [x],\n): Promise<TribbleDB> {\n  if (!tdb) {\n    tdb = new TribbleDB([], schema);\n  }\n\n  for await (const triples of streamTribbles(url)) {\n    for (const triple of triples) {\n      tdb.add(perTriple(triple));\n    }\n  }\n\n  return tdb;\n}\n", "\nexport const SMALL_DEVICE_WIDTH = 500;\n\nexport const PHOTO_WIDTH = 400;\nexport const PHOTO_HEIGHT = 400;\n\nexport class KnownRelations {\n  static ALBUM_ID = \"albumId\";\n  static SUBJECT = \"subject\";\n  static LOCATION = \"location\";\n  static LONGITUDE = \"longitude\";\n  static LATITUDE = \"latitude\";\n  static COUNTRY = \"country\";\n  static FLAG = \"flag\";\n  static RATING = \"rating\";\n  static NAME = \"name\";\n  static BIRDWATCH_URL = \"birdwatchUrl\";\n  static WIKIPEDIA = \"wikipedia\";\n  static CREATED_AT = \"createdAt\";\n  static SEASON = \"season\";\n  static F_STOP = \"f_stop\";\n  static FOCAL_LENGTH = \"focalLength\";\n  static MODEL = \"model\";\n  static EXPOSURE_TIME = \"exposureTime\";\n  static ISO = \"iso\";\n  static WIDTH = \"width\";\n  static HEIGHT = \"height\";\n  static THUMBNAIL_URL = \"thumbnailUrl\";\n  static PNG_URL = \"pngUrl\";\n  static MID_IMAGE_LOSSY_URL = \"midImageLossyUrl\";\n  static FULL_IMAGE = \"fullImage\";\n  static POSTER_URL = \"posterUrl\";\n  static VIDEO_URL_1080P = \"videoUrl1080p\";\n  static VIDEO_URL_480P = \"videoUrl480p\";\n  static VIDEO_URL_720P = \"videoUrl720p\";\n  static VIDEO_URL_UNSCALED = \"videoUrlUnscaled\";\n  static YEAR = \"year\";\n  static CONTAINS = \"contains\";\n  static IN = \"in\";\n  static STYLE = \"style\";\n  // horrible\n  static FLAGS = \"flags\";\n\n  static CONTAINS_ALBUM = \"containsAlbum\";\n  static TRIP = \"trip\";\n}\n\nexport class KnownTypes {\n  static PLACE = \"place\";\n  static COUNTRY = \"country\";\n  static BIRD = \"bird\";\n  static MAMMAL = \"mammal\";\n  static REPTILE = \"reptile\";\n  static AMPHIBIAN = \"amphibian\";\n  static INSECT = \"insect\";\n  static CAMERA = \"camera\";\n  static PHOTO = \"photo\";\n  static VIDEO = \"video\";\n  static ALBUM = \"album\";\n  static UNESCO = \"unesco\";\n  static FISH = \"fish\";\n  static PLACE_FEATURE = \"place_feature\";\n}\n\n/*\n * It does make sense to say \"show every place photo\",\n * so designate some types as non-listable on the Listing page\n */\nexport const NonListableTypes = new Set([\n  KnownTypes.COUNTRY,\n  KnownTypes.CAMERA,\n  KnownTypes.PLACE,\n]);\n\n/*\n * A few words have irregular plurals; store them here\n * so we can display them without saying `Countrys`\n */\nexport const PLURALS = new Map<string, string>([\n  [\"country\", \"countries\"],\n]);\n\n/*\n * Renamed relations mapping\n */\nexport const RENAMED_RELATIONS = new Map<string, string>([\n  [KnownRelations.FLAGS, KnownRelations.COUNTRY],\n]);\n\n/*\n * These relations should all expand to CDN urls\n */\nexport const CDN_RELATIONS = new Set([\n  KnownRelations.THUMBNAIL_URL,\n  KnownRelations.PNG_URL,\n  KnownRelations.MID_IMAGE_LOSSY_URL,\n  KnownRelations.FULL_IMAGE,\n  KnownRelations.POSTER_URL,\n  KnownRelations.VIDEO_URL_1080P,\n  KnownRelations.VIDEO_URL_480P,\n  KnownRelations.VIDEO_URL_720P,\n  KnownRelations.VIDEO_URL_UNSCALED,\n]);\n\n/*\n * Some relationships have inverses; store this data here\n * (though it could be passed in band in the Tribble file in future)\n */\nexport const RelationSymmetries = [\n  [KnownRelations.IN, KnownRelations.CONTAINS],\n  [KnownRelations.CONTAINS_ALBUM, KnownRelations.TRIP],\n];\n\n/*\n * A list of shortened Curies passed to the UI, and how to expand them\n */\nexport const CURIES = {\n  \"i\": \"urn:r\u00F3:\",\n  \"birdwatch\": \"https://birdwatchireland.ie/birds/\",\n  \"photos\": \"https://photos-cdn.rgrannell.xyz/\",\n  \"wiki\": \"https://en.wikipedia.org/wiki/\",\n};\n\n// Curies match this pattern\nexport const CURIE_REGEX = /^\\[([a-z]*):(.*)\\]$/;\n\n// TODO inject via environmental variable\nexport const ENDPOINT = \"https://photos-cdn.rgrannell.xyz\";\n\nexport const SCROLL_HIDE_THRESHOLD = 200;\n\n/*\n * Places have features, use these features to pick an emoji to represent the place\n */\nexport const PLACE_FEATURES_TO_EMOJI = {\n  aquarium: \"\uD83D\uDC20\",\n  aquaduct: \"\uD83C\uDFDB\uFE0F\",\n  archaeological: \"\uD83C\uDFFA\",\n  beach: \"\uD83C\uDFD6\uFE0F\",\n  bridge: \"\uD83C\uDF09\",\n  canal: \"\uD83D\uDEA4\",\n  castle: \"\uD83C\uDFF0\",\n  church: \"\u26EA\",\n  cathedral: \"\u26EA\",\n  continent: \"\uD83C\uDF0D\",\n  cave: \"\u26CF\uFE0F\",\n  city: \"\uD83C\uDFD9\uFE0F\",\n  cliffs: \"\u26F0\uFE0F\",\n  county: \"\uD83D\uDDFA\uFE0F\",\n  district: \"\uD83C\uDFD8\uFE0F\",\n  garden: \"\uD83C\uDF3A\",\n  harbor: \"\u2693\",\n  island: \"\uD83C\uDFDD\uFE0F\",\n  lake: \"\uD83C\uDFDE\uFE0F\",\n  monument: \"\uD83D\uDDFF\",\n  mosque: \"\uD83D\uDD4C\",\n  mountain: \"\uD83C\uDFD4\uFE0F\",\n  mountains: \"\uD83C\uDFD4\uFE0F\",\n  museum: \"\uD83C\uDFDB\uFE0F\",\n  monastery: \"\uD83C\uDFEF\",\n  national: \"\uD83C\uDDFA\uD83C\uDDF3\",\n  nature: \"\uD83C\uDF3F\",\n  palace: \"\uD83C\uDFEF\",\n  park: \"\uD83C\uDF33\",\n  port: \"\uD83D\uDEF3\uFE0F\",\n  rainforest: \"\uD83C\uDF34\",\n  square: \"\uD83C\uDFE2\",\n  state: \"\uD83C\uDFDB\uFE0F\",\n  street: \"\uD83D\uDEB6\u200D\u2642\uFE0F\",\n  town: \"\uD83C\uDFD8\uFE0F\",\n  train: \"\uD83D\uDE86\",\n  unesco: \"\uD83C\uDFDB\uFE0F\",\n  village: \"\uD83C\uDFE1\",\n  volcano: \"\uD83C\uDF0B\",\n  waterfall: \"\uD83D\uDCA6\",\n  wildlife: \"\uD83E\uDD81\",\n  zoo: \"\uD83E\uDD93\",\n};\n\n/*\n * A list of cameras I've taken photos on\n */\nexport const CAMERA_MODELS = new Set([\n  \"dc-gh5\",\n  \"dc-gh6\",\n  \"dmc-fz72\",\n  \"dmc-g7\",\n  \"finepix-f70exr\",\n  \"xz-1\",\n]);\n\n/*\n * A list of phones I've taken photos on\n */\nexport const PHONE_MODELS = new Set([\n  \"pixel-4a\",\n  \"pixel-7-pro\",\n  \"pixel-9a\",\n  \"sm-a520f\",\n]);\n\nexport const BinomialTypes = new Set([\n  KnownTypes.BIRD,\n  KnownTypes.MAMMAL,\n  KnownTypes.REPTILE,\n  KnownTypes.AMPHIBIAN,\n  KnownTypes.FISH,\n  KnownTypes.INSECT,\n]);\n", "/* String Utilities */\n\nimport { PLURALS } from \"../constants.ts\";\n\nexport function capitalise(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function pluralise(str: string): string {\n  if (PLURALS.has(str)) {\n    return PLURALS.get(str)!;\n  }\n\n  return str + \"s\";\n}\n\nconst CAMEL_CASE_CACHE = new Map<string, string>();\n\nexport function camelCase(str: string): string {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n\n  // Caching this since it took about 10ms at load time, so why not eliminate that?\n  if (CAMEL_CASE_CACHE.has(str)) {\n    return CAMEL_CASE_CACHE.get(str)!;\n  }\n\n  const result = str.replace(\n    /[-_ ]+([a-z0-9])/g,\n    (_, char) => char.toUpperCase(),\n  );\n\n  CAMEL_CASE_CACHE.set(str, result);\n  return result;\n}\n\nexport function binomial(binomial: string) {\n  const pretty = binomial.replace(/-/g, \" \");\n  return capitalise(pretty);\n}\n\n/*\n * Markdown renderer is mangling descriptions.\n */\nexport function preprocessDescription(description: string): string {\n  return description.replace(/\\\\\"/g, '\"');\n}\n", "/*\n * We want to limit how much we send to the server,\n * so some triples are modified or derived client-side\n */\n\nimport type { TribbleDB, Triple } from \"@rgrannell1/tribbledb\";\n\nimport {\n  CDN_RELATIONS,\n  CURIE_REGEX,\n  CURIES,\n  ENDPOINT,\n  KnownRelations,\n  RelationSymmetries,\n  RENAMED_RELATIONS,\n} from \"../constants.ts\";\nimport { camelCase } from \"../commons/strings.ts\";\n\n/*\n * Convert star ratings into rating URNs.\n */\nexport function convertRatingsToUrns(tdb: TribbleDB) {\n  const rating = /\u2B50/g;\n  tdb.searchFlatmap({\n    relation: KnownRelations.RATING,\n  }, ([src, rel, tgt]) => {\n    const starCount = (tgt.match(rating) || []).length;\n    return [[src, rel, `urn:r\u00F3:rating:${starCount - 1}`]];\n  })\n}\n\n\n/*\n * Convert `country` relations to URNs\n */\nexport function convertCountriesToUrns(tdb: TribbleDB) {\n  const spacy = / /g;\n  tdb.searchFlatmap({\n    relation: KnownRelations.COUNTRY,\n  }, ([src, rel, tgt]) => {\n    const id = tgt.toLowerCase().replace(spacy, \"-\");\n    return [[src, rel, `urn:r\u00F3:country:${id}`]];\n  });\n}\n\nconst styleNames = new Set<string>();\n\n/* */\nexport function convertStylesToUrns(tdb: TribbleDB) {\n  tdb.searchFlatmap({\n    relation: KnownRelations.STYLE,\n  }, ([src, rel, tgt]) => {\n    const id = tgt.toLowerCase().replace(/ /g, \"-\");\n    const styleUrn = `urn:r\u00F3:style:${id}`;\n\n    if (!styleNames.has(tgt)) {\n      styleNames.add(tgt);\n      return [\n        [\n          src,\n          rel,\n          styleUrn,\n        ],\n        [\n          styleUrn,\n          KnownRelations.NAME,\n          tgt,\n        ],\n      ];\n    } else {\n      return [[\n        src,\n        rel,\n        styleUrn,\n      ]];\n    }\n  });\n}\n\n/*\n * Expand CDN urls with their endpoint\n */\nexport function expandCdnUrls(tdb: TribbleDB) {\n  tdb.searchFlatmap({\n    relation: Array.from(CDN_RELATIONS),\n  }, ([src, rel, tgt]) => {\n    return [[\n      src,\n      rel,\n      `${ENDPOINT}${tgt}`,\n    ]];\n  });\n}\n\n/*\n * Convert relation names to camelCase\n */\nexport function convertRelationCasing(triple: Triple) {\n  const [src, rel, tgt] = triple;\n\n  return [[\n    src,\n    camelCase(rel),\n    tgt,\n  ]];\n}\n\n/*\n * Expand shortened URNS into urn:r\u00F3:\n */\nexport function expandUrns(triple: Triple): Triple[] {\n  const [src, rel, tgt] = triple;\n\n  return [[\n    typeof src === \"string\" && src.startsWith(\"::\")\n      ? `urn:r\u00F3:${src.slice(2)}`\n      : src,\n    rel,\n    typeof tgt === \"string\" && tgt.startsWith(\"::\")\n      ? `urn:r\u00F3:${tgt.slice(2)}`\n      : tgt,\n  ]];\n}\n\n/*\n * Add years as a relation, when a date is present\n */\nexport function addYear(tdb: TribbleDB) {\n  const years = tdb.search({\n    relation: KnownRelations.CREATED_AT,\n  }).triples().flatMap(([src, _, tgt]) => {\n    const date = new Date(tgt);\n\n    if (isNaN(date.getTime())) {\n      return [];\n    }\n\n    const year = date.getUTCFullYear().toString();\n\n    return [[src, KnownRelations.YEAR, year]] as Triple[];\n  });\n\n  tdb.add(years);\n}\n\n/*\n * Reverse relationships\n *\n * some relations imply other; X parent-of Y implies Y child-of X\n */\nexport function addInverseRelations(tdb: TribbleDB) {\n  const triples: Triple[] = [];\n\n  for (const [to, from] of RelationSymmetries) {\n    const results = tdb.search({\n      relation: to,\n    }).triples();\n\n    for (const [src, _, tgt] of results) {\n      triples.push([ tgt, from, src ]);\n    }\n  }\n\n  tdb.add(triples);\n}\n\nconst CURIE_CACHE = new Map<string, string>();\n\n/*\n * Expand curie-formatted URLS into their full form.\n */\nexport function expandCurie(curies: Record<string, string>, value: string) {\n  const cached = CURIE_CACHE.get(value);\n  if (cached) {\n    return cached;\n  }\n\n  if (typeof value !== \"string\" || !CURIE_REGEX.test(value)) {\n    return value;\n  }\n  const match = value.match(CURIE_REGEX);\n\n  if (!match) {\n    return value;\n  }\n\n  const prefix = match[1];\n  const id = match[2];\n\n  const result = curies[prefix] ? `${curies[prefix]}${id}` : value;\n\n  CURIE_CACHE.set(value, result);\n  return result;\n}\n\n/*\n * Some URNs are sent in CURIE format to compact them; expand\n * e.g [wiki:olm] => https://en.wikipedia.org/wiki/olm\n */\nexport function expandTripleCuries(\n  triple: Triple,\n) {\n  const [src, rel, tgt] = triple;\n\n  return [\n    [\n      expandCurie(CURIES, src),\n      rel,\n      expandCurie(CURIES, tgt),\n    ],\n  ];\n}\n\n/*\n * Construct a location tree based on `in` relations.\n */\nexport function buildLocationTrees(\n  tdb: TribbleDB,\n) {\n\n  // This is a bit unpleasant\n  const treeState = {\n    nodes: new Map<string, {\n      id: string;\n      parents: Set<string>;\n    }>(),\n    // used later to detect whether a node is a leaf\n    branchIds: new Set<string>(),\n  };\n\n  const results = tdb.search({\n    relation: KnownRelations.IN,\n  }).triples();\n\n  const nodes = treeState.nodes;\n  for (const [src, , tgt] of results) {\n    let srcNode = nodes.get(src);\n    if (!srcNode) {\n      srcNode = { id: src, parents: new Set() };\n      nodes.set(src, srcNode);\n    }\n\n    let tgtNode = nodes.get(tgt);\n    if (!tgtNode) {\n      tgtNode = { id: tgt, parents: new Set() };\n      nodes.set(tgt, tgtNode);\n    }\n\n    treeState.branchIds.add(tgt);\n    srcNode?.parents.add(tgt);\n  }\n\n  return treeState;\n}\n\n/*\n * Rename relations (until they're remapped on the mirror side)\n */\nfunction renameRelations(triple: Triple) {\n  for (const [from, to] of RENAMED_RELATIONS) {\n    if (triple[1] === from) {\n      return [[\n        triple[0],\n        to,\n        triple[2],\n      ]];\n    }\n  }\n\n  return [triple];\n}\n\n// This should be in mirror, but for testing...\nexport const HARD_CODED_TRIPLES: Triple[] = [\n  [\"urn:r\u00F3:rating:%E2%AD%90\", KnownRelations.NAME, \"\u2B50\"],\n  [\"urn:r\u00F3:rating:%E2%AD%90%E2%AD%90\", KnownRelations.NAME, \"\u2B50\u2B50\"],\n  [\"urn:r\u00F3:rating:%E2%AD%90%E2%AD%90%E2%AD%90\", KnownRelations.NAME, \"\u2B50\u2B50\u2B50\"],\n  [\n    \"urn:r\u00F3:rating:%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90\",\n    KnownRelations.NAME,\n    \"\u2B50\u2B50\u2B50\u2B50\",\n  ],\n  [\n    \"urn:r\u00F3:rating:%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90\",\n    KnownRelations.NAME,\n    \"\u2B50\u2B50\u2B50\u2B50\u2B50\",\n  ],\n];\n\n/*\n * Compose all triple modifiers together.\n *\n * This is a bottleneck\n * - takes roughly 100ms to run as of Nov 25 tribbledb v0.16\n * - takes 70ms after v0.18 Nov 25 and moving some derivations to non-linear scan adds\n *\n * @param triple The input triple to modify.\n */\nexport function deriveTriples(\n  triple: Triple,\n): Triple[] {\n  const tripleProcessors = [\n    renameRelations,\n    convertRelationCasing,\n    expandUrns,\n    expandTripleCuries,\n  ];\n\n  let outputTriples: Triple[] = [triple];\n  for (const fn of tripleProcessors) {\n    let nextStep: Triple[] = [];\n\n    for (const triple of outputTriples) {\n      nextStep.push(...(fn(triple) as Triple[]));\n    }\n\n    outputTriples = [...nextStep];\n    nextStep = [];\n  }\n\n  return outputTriples;\n}\n\n/*\n * Operations that add but do not modify existing triples,\n * to be run after all indexing is complete.\n *\n */\nexport function postIndexing(tdb: TribbleDB) {\n  addYear(tdb);\n  addInverseRelations(tdb);\n  addNestedLocations(tdb);\n  convertRatingsToUrns(tdb);\n  convertCountriesToUrns(tdb);\n  expandCdnUrls(tdb);\n  convertStylesToUrns(tdb);\n}\n\n/*\n* During the initial flatmap processing of the ingested triples,\n* we built up a tree describing which places are contained in which others.\n* Construct the transitive relations in this function.\n*/\nexport function addNestedLocations(tdb: TribbleDB) {\n  const treeState = buildLocationTrees(tdb);\n  /*\n   * Recurse up the tree from the leaves, tracing the path we followed.\n   */\n  function recurse(path: string[], urn: string): Triple[] {\n    const triples: Triple[] = [];\n\n    const node = treeState.nodes.get(urn);\n\n    // Probably not possible\n    if (!node) {\n      throw new Error(`no node in location tree for ${urn}`);\n    }\n\n    // Beats implementing cycle-detection\n    if (path.length > 5) {\n      throw new Error(`likely cycle; ${JSON.stringify(path)}`);\n    }\n\n    if (node.parents.size === 0) {\n      // in this case, we have a path A :IN B :IN C :IN D\n      // return [A, B], [A, C], [A, D], [B, C], ..., [C, D]\n      // which should be the set of transitive in relations.\n      // For good measure, throw in the `contains` inverse relation\n      const totalPath = [...path, urn];\n\n      for (let idx = 0; idx < totalPath.length - 1; idx++) {\n        for (let jdx = idx; jdx < totalPath.length; jdx++) {\n          const src = totalPath[idx];\n          const tgt = totalPath[jdx];\n\n          if (src === tgt) {\n            continue;\n          }\n\n          triples.push([src, KnownRelations.IN, tgt]);\n          triples.push([tgt, KnownRelations.CONTAINS, src]);\n        }\n      }\n    } else {\n      for (const parent of node.parents) {\n        triples.push(...recurse([...path, urn], parent));\n      }\n    }\n\n    return triples;\n  }\n\n  const triples: Triple[] = [];\n\n  // Recurse up from all leaves A :IN B, and\n  // return all transitive location relations\n  for (const nodeId of treeState.nodes.keys()) {\n    if (treeState.branchIds.has(nodeId)) {\n      continue;\n    }\n\n    triples.push(...recurse([], nodeId));\n  }\n\n  tdb.add(triples);\n}\n\n/*\n * TODO: if a photo is in Zaragoza, it's in Spain. Make sure that\n         link is captured.\n */\n", "// TODO dd typing\n\nexport function logParseWarning(issues: any): void {\n  const message: string[] = [];\n\n  for (const issue of issues) {\n    message.push(\n      `Parse warning @\\n${\n        JSON.stringify(issue.path, null, 2)\n      }\\n: ${issue.message}`,\n    );\n  }\n\n  // TODO; error out instead\n  console.warn(message.join(\"\\n\"));\n  console.trace();\n}\n", "//#region src/storages/globalConfig/globalConfig.ts\nlet store$4;\n/**\n* Sets the global configuration.\n*\n* @param config The configuration.\n*/\nfunction setGlobalConfig(config$1) {\n\tstore$4 = {\n\t\t...store$4,\n\t\t...config$1\n\t};\n}\n/**\n* Returns the global configuration.\n*\n* @param config The config to merge.\n*\n* @returns The configuration.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalConfig(config$1) {\n\treturn {\n\t\tlang: config$1?.lang ?? store$4?.lang,\n\t\tmessage: config$1?.message,\n\t\tabortEarly: config$1?.abortEarly ?? store$4?.abortEarly,\n\t\tabortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly\n\t};\n}\n/**\n* Deletes the global configuration.\n*/\nfunction deleteGlobalConfig() {\n\tstore$4 = void 0;\n}\n\n//#endregion\n//#region src/storages/globalMessage/globalMessage.ts\nlet store$3;\n/**\n* Sets a global error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setGlobalMessage(message$1, lang) {\n\tif (!store$3) store$3 = /* @__PURE__ */ new Map();\n\tstore$3.set(lang, message$1);\n}\n/**\n* Returns a global error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalMessage(lang) {\n\treturn store$3?.get(lang);\n}\n/**\n* Deletes a global error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteGlobalMessage(lang) {\n\tstore$3?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/schemaMessage/schemaMessage.ts\nlet store$2;\n/**\n* Sets a schema error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSchemaMessage(message$1, lang) {\n\tif (!store$2) store$2 = /* @__PURE__ */ new Map();\n\tstore$2.set(lang, message$1);\n}\n/**\n* Returns a schema error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSchemaMessage(lang) {\n\treturn store$2?.get(lang);\n}\n/**\n* Deletes a schema error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteSchemaMessage(lang) {\n\tstore$2?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/specificMessage/specificMessage.ts\nlet store$1;\n/**\n* Sets a specific error message.\n*\n* @param reference The identifier reference.\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSpecificMessage(reference, message$1, lang) {\n\tif (!store$1) store$1 = /* @__PURE__ */ new Map();\n\tif (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());\n\tstore$1.get(reference).set(lang, message$1);\n}\n/**\n* Returns a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSpecificMessage(reference, lang) {\n\treturn store$1?.get(reference)?.get(lang);\n}\n/**\n* Deletes a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*/\nfunction deleteSpecificMessage(reference, lang) {\n\tstore$1?.get(reference)?.delete(lang);\n}\n\n//#endregion\n//#region src/utils/_stringify/_stringify.ts\n/**\n* Stringifies an unknown input to a literal or type string.\n*\n* @param input The unknown input.\n*\n* @returns A literal or type string.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _stringify(input) {\n\tconst type = typeof input;\n\tif (type === \"string\") return `\"${input}\"`;\n\tif (type === \"number\" || type === \"bigint\" || type === \"boolean\") return `${input}`;\n\tif (type === \"object\" || type === \"function\") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n\treturn type;\n}\n\n//#endregion\n//#region src/utils/_addIssue/_addIssue.ts\n/**\n* Adds an issue to the dataset.\n*\n* @param context The issue context.\n* @param label The issue label.\n* @param dataset The input dataset.\n* @param config The configuration.\n* @param other The optional props.\n*\n* @internal\n*/\nfunction _addIssue(context, label, dataset, config$1, other) {\n\tconst input = other && \"input\" in other ? other.input : dataset.value;\n\tconst expected = other?.expected ?? context.expects ?? null;\n\tconst received = other?.received ?? /* @__PURE__ */ _stringify(input);\n\tconst issue = {\n\t\tkind: context.kind,\n\t\ttype: context.type,\n\t\tinput,\n\t\texpected,\n\t\treceived,\n\t\tmessage: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n\t\trequirement: context.requirement,\n\t\tpath: other?.path,\n\t\tissues: other?.issues,\n\t\tlang: config$1.lang,\n\t\tabortEarly: config$1.abortEarly,\n\t\tabortPipeEarly: config$1.abortPipeEarly\n\t};\n\tconst isSchema = context.kind === \"schema\";\n\tconst message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);\n\tif (message$1 !== void 0) issue.message = typeof message$1 === \"function\" ? message$1(issue) : message$1;\n\tif (isSchema) dataset.typed = false;\n\tif (dataset.issues) dataset.issues.push(issue);\n\telse dataset.issues = [issue];\n}\n\n//#endregion\n//#region src/utils/_getByteCount/_getByteCount.ts\nlet textEncoder;\n/**\n* Returns the byte count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The byte count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getByteCount(input) {\n\tif (!textEncoder) textEncoder = new TextEncoder();\n\treturn textEncoder.encode(input).length;\n}\n\n//#endregion\n//#region src/utils/_getGraphemeCount/_getGraphemeCount.ts\nlet segmenter;\n/**\n* Returns the grapheme count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The grapheme count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getGraphemeCount(input) {\n\tif (!segmenter) segmenter = new Intl.Segmenter();\n\tconst segments = segmenter.segment(input);\n\tlet count = 0;\n\tfor (const _ of segments) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_getLastMetadata/_getLastMetadata.ts\n/**\n* Returns the last top-level value of a given metadata type from a schema\n* using a breadth-first search that starts with the last item in the pipeline.\n*\n* @param schema The schema to search.\n* @param type The metadata type.\n*\n* @returns The value, if any.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getLastMetadata(schema, type) {\n\tif (\"pipe\" in schema) {\n\t\tconst nestedSchemas = [];\n\t\tfor (let index = schema.pipe.length - 1; index >= 0; index--) {\n\t\t\tconst item = schema.pipe[index];\n\t\t\tif (item.kind === \"schema\" && \"pipe\" in item) nestedSchemas.push(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === type) return item[type];\n\t\t}\n\t\tfor (const nestedSchema of nestedSchemas) {\n\t\t\tconst result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);\n\t\t\tif (result !== void 0) return result;\n\t\t}\n\t}\n}\n\n//#endregion\n//#region src/utils/_getStandardProps/_getStandardProps.ts\n/**\n* Returns the Standard Schema properties.\n*\n* @param context The schema context.\n*\n* @returns The Standard Schema properties.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getStandardProps(context) {\n\treturn {\n\t\tversion: 1,\n\t\tvendor: \"valibot\",\n\t\tvalidate(value$1) {\n\t\t\treturn context[\"~run\"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/utils/_getWordCount/_getWordCount.ts\nlet store;\n/**\n* Returns the word count of the input.\n*\n* @param locales The locales to be used.\n* @param input The input to be measured.\n*\n* @returns The word count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getWordCount(locales, input) {\n\tif (!store) store = /* @__PURE__ */ new Map();\n\tif (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n\tconst segments = store.get(locales).segment(input);\n\tlet count = 0;\n\tfor (const segment of segments) if (segment.isWordLike) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\n/**\n* Non-digit regex.\n*/\nconst NON_DIGIT_REGEX = /\\D/gu;\n/**\n* Checks whether a string with numbers corresponds to the luhn algorithm.\n*\n* @param input The input to be checked.\n*\n* @returns Whether input is valid.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isLuhnAlgo(input) {\n\tconst number$1 = input.replace(NON_DIGIT_REGEX, \"\");\n\tlet length$1 = number$1.length;\n\tlet bit = 1;\n\tlet sum = 0;\n\twhile (length$1) {\n\t\tconst value$1 = +number$1[--length$1];\n\t\tbit ^= 1;\n\t\tsum += bit ? [\n\t\t\t0,\n\t\t\t2,\n\t\t\t4,\n\t\t\t6,\n\t\t\t8,\n\t\t\t1,\n\t\t\t3,\n\t\t\t5,\n\t\t\t7,\n\t\t\t9\n\t\t][value$1] : value$1;\n\t}\n\treturn sum % 10 === 0;\n}\n\n//#endregion\n//#region src/utils/_isValidObjectKey/_isValidObjectKey.ts\n/**\n* Disallows inherited object properties and prevents object prototype\n* pollution by disallowing certain keys.\n*\n* @param object The object to check.\n* @param key The key to check.\n*\n* @returns Whether the key is allowed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isValidObjectKey(object$1, key) {\n\treturn Object.hasOwn(object$1, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n//#endregion\n//#region src/utils/_joinExpects/_joinExpects.ts\n/**\n* Joins multiple `expects` values with the given separator.\n*\n* @param values The `expects` values.\n* @param separator The separator.\n*\n* @returns The joined `expects` property.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _joinExpects(values$1, separator) {\n\tconst list = [...new Set(values$1)];\n\tif (list.length > 1) return `(${list.join(` ${separator} `)})`;\n\treturn list[0] ?? \"never\";\n}\n\n//#endregion\n//#region src/utils/entriesFromList/entriesFromList.ts\n/**\n* Creates an object entries definition from a list of keys and a schema.\n*\n* @param list A list of keys.\n* @param schema The schema of the keys.\n*\n* @returns The object entries.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromList(list, schema) {\n\tconst entries$1 = {};\n\tfor (const key of list) entries$1[key] = schema;\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/entriesFromObjects/entriesFromObjects.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromObjects(schemas) {\n\tconst entries$1 = {};\n\tfor (const schema of schemas) Object.assign(entries$1, schema.entries);\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/getDotPath/getDotPath.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDotPath(issue) {\n\tif (issue.path) {\n\t\tlet key = \"\";\n\t\tfor (const item of issue.path) if (typeof item.key === \"string\" || typeof item.key === \"number\") if (key) key += `.${item.key}`;\n\t\telse key += item.key;\n\t\telse return null;\n\t\treturn key;\n\t}\n\treturn null;\n}\n\n//#endregion\n//#region src/utils/isOfKind/isOfKind.ts\n/**\n* A generic type guard to check the kind of an object.\n*\n* @param kind The kind to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfKind(kind, object$1) {\n\treturn object$1.kind === kind;\n}\n\n//#endregion\n//#region src/utils/isOfType/isOfType.ts\n/**\n* A generic type guard to check the type of an object.\n*\n* @param type The type to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfType(type, object$1) {\n\treturn object$1.type === type;\n}\n\n//#endregion\n//#region src/utils/isValiError/isValiError.ts\n/**\n* A type guard to check if an error is a ValiError.\n*\n* @param error The error to check.\n*\n* @returns Whether its a ValiError.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isValiError(error) {\n\treturn error instanceof ValiError;\n}\n\n//#endregion\n//#region src/utils/ValiError/ValiError.ts\n/**\n* A Valibot error with useful information.\n*/\nvar ValiError = class extends Error {\n\t/**\n\t* Creates a Valibot error with useful information.\n\t*\n\t* @param issues The error issues.\n\t*/\n\tconstructor(issues) {\n\t\tsuper(issues[0].message);\n\t\tthis.name = \"ValiError\";\n\t\tthis.issues = issues;\n\t}\n};\n\n//#endregion\n//#region src/actions/args/args.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction args(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: args,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst argsDataset = this.schema[\"~run\"]({ value: args_ }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/args/argsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction argsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: argsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args$1) => {\n\t\t\t\tconst argsDataset = await schema[\"~run\"]({ value: args$1 }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/await/awaitAsync.ts\n/**\n* Creates an await transformation action.\n*\n* @returns An await action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction awaitAsync() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"await\",\n\t\treference: awaitAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/regex.ts\n/**\n* [Base64](https://en.wikipedia.org/wiki/Base64) regex.\n*/\nconst BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\n/**\n* [BIC](https://en.wikipedia.org/wiki/ISO_9362) regex.\n*/\nconst BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\n/**\n* [Cuid2](https://github.com/paralleldrive/cuid2) regex.\n*/\nconst CUID2_REGEX = /^[a-z][\\da-z]*$/u;\n/**\n* [Decimal](https://en.wikipedia.org/wiki/Decimal) regex.\n*/\nconst DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\n/**\n* [Digits](https://en.wikipedia.org/wiki/Numerical_digit) regex.\n*/\nconst DIGITS_REGEX = /^\\d+$/u;\n/**\n* [Email address](https://en.wikipedia.org/wiki/Email_address) regex.\n*/\nconst EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\n/**\n* Emoji regex from [emoji-regex-xs](https://github.com/slevithan/emoji-regex-xs) v1.0.0 (MIT license).\n*\n* Hint: We decided against the newer `/^\\p{RGI_Emoji}+$/v` regex because it is\n* not supported in older runtimes and does not match all emoji.\n*/\nconst EMOJI_REGEX = /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation}))*)+$/u;\n/**\n* [Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\n/**\n* [Hex color](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\n/**\n* [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity) regex.\n*/\nconst IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\n/**\n* [IPv4](https://en.wikipedia.org/wiki/IPv4) regex.\n*/\nconst IPV4_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\n/**\n* [IPv6](https://en.wikipedia.org/wiki/IPv6) regex.\n*/\nconst IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [IP](https://en.wikipedia.org/wiki/IP_address) regex.\n*/\nconst IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date regex.\n*/\nconst ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time regex.\n*/\nconst ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time regex.\n*/\nconst ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time with seconds regex.\n*/\nconst ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp regex.\n*/\nconst ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) week regex.\n*/\nconst ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 48 bit regex.\n*/\nconst MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 64 bit regex.\n*/\nconst MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) regex.\n*/\nconst MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [Nano ID](https://github.com/ai/nanoid) regex.\n*/\nconst NANO_ID_REGEX = /^[\\w-]+$/u;\n/**\n* [Octal](https://en.wikipedia.org/wiki/Octal) regex.\n*/\nconst OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\n/**\n* [RFC 5322 email address](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1) regex.\n*\n* Hint: This regex was taken from the [HTML Living Standard Specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) and does not perfectly represent RFC 5322.\n*/\nconst RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/**\n* [Slug](https://en.wikipedia.org/wiki/Clean_URL#Slug) regex.\n*/\nconst SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\n/**\n* [ULID](https://github.com/ulid/spec) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\n/**\n* [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) regex.\n*/\nconst UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n//#endregion\n//#region src/actions/base64/base64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction base64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"base64\",\n\t\treference: base64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BASE64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Base64\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bic/bic.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bic(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bic\",\n\t\treference: bic,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BIC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"BIC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/brand/brand.ts\n/**\n* Creates a brand transformation action.\n*\n* @param name The brand name.\n*\n* @returns A brand action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction brand(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"brand\",\n\t\treference: brand,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bytes/bytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bytes\",\n\t\treference: bytes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 !== this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/check.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction check(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: check,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/checkAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: checkAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItems(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItems,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) for (let index = 0; index < dataset.value.length; index++) {\n\t\t\t\tconst item = dataset.value[index];\n\t\t\t\tif (!this.requirement(item, index, dataset.value)) _addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\tinput: item,\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\tvalue: item\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItemsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItemsAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItemsAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst requirementResults = await Promise.all(dataset.value.map(this.requirement));\n\t\t\t\tfor (let index = 0; index < dataset.value.length; index++) if (!requirementResults[index]) {\n\t\t\t\t\tconst item = dataset.value[index];\n\t\t\t\t\t_addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\t\tinput: item,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\t\tvalue: item\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/creditCard/creditCard.ts\n/**\n* Credit card regex.\n*/\nconst CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\n/**\n* Sanitize regex.\n*/\nconst SANITIZE_REGEX = /[- ]/gu;\n/**\n* Provider regex list.\n*/\nconst PROVIDER_REGEX_LIST = [\n\t/^3[47]\\d{13}$/u,\n\t/^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n\t/^6(?:011|5\\d{2})\\d{12,15}$/u,\n\t/^(?:2131|1800|35\\d{3})\\d{11}$/u,\n\t/^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n\t/^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n\t/^4\\d{12}(?:\\d{3,6})?$/u\n];\n/* @__NO_SIDE_EFFECTS__ */\nfunction creditCard(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"credit_card\",\n\t\treference: creditCard,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\tlet sanitized;\n\t\t\treturn CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, \"\")) && PROVIDER_REGEX_LIST.some((regex$1) => regex$1.test(sanitized)) && /* @__PURE__ */ _isLuhnAlgo(sanitized);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"credit card\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/cuid2/cuid2.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction cuid2(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"cuid2\",\n\t\treference: cuid2,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: CUID2_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Cuid2\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/decimal/decimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction decimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"decimal\",\n\t\treference: decimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"decimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/description/description.ts\n/**\n* Creates a description metadata action.\n*\n* @param description_ The description text.\n*\n* @returns A description action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction description(description_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"description\",\n\t\treference: description,\n\t\tdescription: description_\n\t};\n}\n\n//#endregion\n//#region src/actions/digits/digits.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction digits(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"digits\",\n\t\treference: digits,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DIGITS_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"digits\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/email/email.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction email(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"email\",\n\t\treference: email,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/emoji/emoji.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction emoji(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"emoji\",\n\t\treference: emoji,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: EMOJI_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"emoji\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/empty/empty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction empty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"empty\",\n\t\treference: empty,\n\t\tasync: false,\n\t\texpects: \"0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > 0) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/endsWith/endsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction endsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ends_with\",\n\t\treference: endsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, \"end\", dataset, config$1, { received: `\"${dataset.value.slice(-this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/entries/entries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"entries\",\n\t\treference: entries,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count !== this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/everyItem/everyItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction everyItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"every_item\",\n\t\treference: everyItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/examples/examples.ts\n/**\n* Creates an examples metadata action.\n*\n* @param examples_ The examples.\n*\n* @returns An examples action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction examples(examples_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"examples\",\n\t\treference: examples,\n\t\texamples: examples_\n\t};\n}\n\n//#endregion\n//#region src/actions/excludes/excludes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction excludes(requirement, message$1) {\n\tconst received = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"excludes\",\n\t\treference: excludes,\n\t\tasync: false,\n\t\texpects: `!${received}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/filterItems/filterItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction filterItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"filter_items\",\n\t\treference: filterItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.filter(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/findItem/findItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction findItem(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"find_item\",\n\t\treference: findItem,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.find(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/finite/finite.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction finite(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"finite\",\n\t\treference: finite,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isFinite,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"finite\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/flavor/flavor.ts\n/**\n* Creates a flavor transformation action.\n*\n* @param name The flavor name.\n*\n* @returns A flavor action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction flavor(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"flavor\",\n\t\treference: flavor,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/graphemes/graphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction graphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"graphemes\",\n\t\treference: graphemes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/gtValue/gtValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction gtValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"gt_value\",\n\t\treference: gtValue,\n\t\tasync: false,\n\t\texpects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hash/hash.ts\n/**\n* Hash lengths object.\n*/\nconst HASH_LENGTHS = {\n\tmd4: 32,\n\tmd5: 32,\n\tsha1: 40,\n\tsha256: 64,\n\tsha384: 96,\n\tsha512: 128,\n\tripemd128: 32,\n\tripemd160: 40,\n\ttiger128: 32,\n\ttiger160: 40,\n\ttiger192: 48,\n\tcrc32: 8,\n\tcrc32b: 8,\n\tadler32: 8\n};\n/* @__NO_SIDE_EFFECTS__ */\nfunction hash(types, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hash\",\n\t\treference: hash,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RegExp(types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hash\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexadecimal/hexadecimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexadecimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hexadecimal\",\n\t\treference: hexadecimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEXADECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hexadecimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexColor/hexColor.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexColor(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hex_color\",\n\t\treference: hexColor,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEX_COLOR_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hex color\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/imei/imei.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction imei(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"imei\",\n\t\treference: imei,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\treturn IMEI_REGEX.test(input) && /* @__PURE__ */ _isLuhnAlgo(input);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"IMEI\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/includes/includes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction includes(requirement, message$1) {\n\tconst expects = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"includes\",\n\t\treference: includes,\n\t\tasync: false,\n\t\texpects,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received: `!${expects}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/integer/integer.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction integer(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"integer\",\n\t\treference: integer,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ip/ip.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ip(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ip\",\n\t\treference: ip,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IP\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv4/ipv4.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv4(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv4\",\n\t\treference: ipv4,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV4_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv4\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv6/ipv6.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv6(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv6\",\n\t\treference: ipv6,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV6_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv6\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDate/isoDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDate(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date\",\n\t\treference: isoDate,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDateTime/isoDateTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDateTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date_time\",\n\t\treference: isoDateTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date-time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTime/isoTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time\",\n\t\treference: isoTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimeSecond/isoTimeSecond.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimeSecond(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time_second\",\n\t\treference: isoTimeSecond,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_SECOND_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time-second\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimestamp/isoTimestamp.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimestamp(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_timestamp\",\n\t\treference: isoTimestamp,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIMESTAMP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"timestamp\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoWeek/isoWeek.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoWeek(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_week\",\n\t\treference: isoWeek,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_WEEK_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"week\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/length/length.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction length(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"length\",\n\t\treference: length,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ltValue/ltValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ltValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"lt_value\",\n\t\treference: ltValue,\n\t\tasync: false,\n\t\texpects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac/mac.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac\",\n\t\treference: mac,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac48/mac48.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac48(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac48\",\n\t\treference: mac48,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC48_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"48-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac64/mac64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac64\",\n\t\treference: mac64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"64-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mapItems/mapItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"map_items\",\n\t\treference: mapItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.map(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxBytes/maxBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_bytes\",\n\t\treference: maxBytes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 > this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxEntries/maxEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_entries\",\n\t\treference: maxEntries,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count > this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxGraphemes/maxGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_graphemes\",\n\t\treference: maxGraphemes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxLength/maxLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_length\",\n\t\treference: maxLength,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxSize/maxSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_size\",\n\t\treference: maxSize,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxValue/maxValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_value\",\n\t\treference: maxValue,\n\t\tasync: false,\n\t\texpects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxWords/maxWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_words\",\n\t\treference: maxWords,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/metadata/metadata.ts\n/**\n* Creates a custom metadata action.\n*\n* @param metadata_ The metadata object.\n*\n* @returns A metadata action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction metadata(metadata_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"metadata\",\n\t\treference: metadata,\n\t\tmetadata: metadata_\n\t};\n}\n\n//#endregion\n//#region src/actions/mimeType/mimeType.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mimeType(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mime_type\",\n\t\treference: mimeType,\n\t\tasync: false,\n\t\texpects: /* @__PURE__ */ _joinExpects(requirement.map((option) => `\"${option}\"`), \"|\"),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, \"MIME type\", dataset, config$1, { received: `\"${dataset.value.type}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minBytes/minBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_bytes\",\n\t\treference: minBytes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 < this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minEntries/minEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_entries\",\n\t\treference: minEntries,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count < this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minGraphemes/minGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_graphemes\",\n\t\treference: minGraphemes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minLength/minLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_length\",\n\t\treference: minLength,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minSize/minSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_size\",\n\t\treference: minSize,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minValue/minValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_value\",\n\t\treference: minValue,\n\t\tasync: false,\n\t\texpects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minWords/minWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_words\",\n\t\treference: minWords,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/multipleOf/multipleOf.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction multipleOf(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"multiple_of\",\n\t\treference: multipleOf,\n\t\tasync: false,\n\t\texpects: `%${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, \"multiple\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nanoid/nanoid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nanoid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"nanoid\",\n\t\treference: nanoid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: NANO_ID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Nano ID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nonEmpty/nonEmpty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonEmpty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"non_empty\",\n\t\treference: nonEmpty,\n\t\tasync: false,\n\t\texpects: \"!0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === 0) _addIssue(this, \"length\", dataset, config$1, { received: \"0\" });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/normalize/normalize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction normalize(form) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"normalize\",\n\t\treference: normalize,\n\t\tasync: false,\n\t\tform,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.normalize(this.form);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notBytes/notBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_bytes\",\n\t\treference: notBytes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 === this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notEntries/notEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_entries\",\n\t\treference: notEntries,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count === this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notGraphemes/notGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_graphemes\",\n\t\treference: notGraphemes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notLength/notLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_length\",\n\t\treference: notLength,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notSize/notSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_size\",\n\t\treference: notSize,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValue/notValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_value\",\n\t\treference: notValue,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValues/notValues.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValues(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_values\",\n\t\treference: notValues,\n\t\tasync: false,\n\t\texpects: `!${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notWords/notWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_words\",\n\t\treference: notWords,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/octal/octal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction octal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"octal\",\n\t\treference: octal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: OCTAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"octal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/parseJson/parseJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parseJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"parse_json\",\n\t\treference: parseJson,\n\t\tconfig: config$1,\n\t\tmessage: message$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tdataset.value = JSON.parse(dataset.value, this.config?.reviver);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n/**\n* Checks if a dataset is partially typed.\n*\n* @param dataset The dataset to check.\n* @param paths The paths to check.\n*\n* @returns Whether it is partially typed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isPartiallyTyped(dataset, paths) {\n\tif (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {\n\t\tlet typed = false;\n\t\tconst bound = Math.min(path.length, issue.path?.length ?? 0);\n\t\tfor (let index = 0; index < bound; index++) if (path[index] !== issue.path[index].key && (path[index] !== \"$\" || issue.path[index].type !== \"array\")) {\n\t\t\ttyped = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!typed) return false;\n\t}\n\treturn true;\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheck.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheck(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheckAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheckAsync(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheck.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheck(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\taction({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheckAsync.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheckAsync(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tawait action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransform.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransform(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransform,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst output = action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransformAsync.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransformAsync(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransformAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst output = await action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/readonly/readonly.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction readonly() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"readonly\",\n\t\treference: readonly,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/reduceItems/reduceItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction reduceItems(operation, initial) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"reduce_items\",\n\t\treference: reduceItems,\n\t\tasync: false,\n\t\toperation,\n\t\tinitial,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.reduce(this.operation, this.initial);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/regex/regex.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction regex(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"regex\",\n\t\treference: regex,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"format\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returns.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returns(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returns,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst returnsDataset = this.schema[\"~run\"]({ value: func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returnsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returnsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returnsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args_) => {\n\t\t\t\tconst returnsDataset = await this.schema[\"~run\"]({ value: await func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rfcEmail/rfcEmail.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction rfcEmail(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"rfc_email\",\n\t\treference: rfcEmail,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RFC_EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/safeInteger/safeInteger.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeInteger(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"safe_integer\",\n\t\treference: safeInteger,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isSafeInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"safe integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/size/size.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction size(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"size\",\n\t\treference: size,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/slug/slug.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction slug(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"slug\",\n\t\treference: slug,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: SLUG_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"slug\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/someItem/someItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction someItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"some_item\",\n\t\treference: someItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/sortItems/sortItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction sortItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"sort_items\",\n\t\treference: sortItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.sort(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/startsWith/startsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction startsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"starts_with\",\n\t\treference: startsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, \"start\", dataset, config$1, { received: `\"${dataset.value.slice(0, this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/stringifyJson/stringifyJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction stringifyJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"stringify_json\",\n\t\treference: stringifyJson,\n\t\tmessage: message$1,\n\t\tconfig: config$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tconst output = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);\n\t\t\t\tif (output === void 0) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t\tdataset.value = output;\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/title/title.ts\n/**\n* Creates a title metadata action.\n*\n* @param title_ The title text.\n*\n* @returns A title action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction title(title_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"title\",\n\t\treference: title,\n\t\ttitle: title_\n\t};\n}\n\n//#endregion\n//#region src/actions/toBigint/toBigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBigint(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_bigint\",\n\t\treference: toBigint,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = BigInt(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"bigint\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toBoolean/toBoolean.ts\n/**\n* Creates a to boolean transformation action.\n*\n* @returns A to boolean action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBoolean() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_boolean\",\n\t\treference: toBoolean,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = Boolean(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toDate/toDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toDate(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_date\",\n\t\treference: toDate,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = new Date(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"date\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"date\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toLowerCase/toLowerCase.ts\n/**\n* Creates a to lower case transformation action.\n*\n* @returns A to lower case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toLowerCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_lower_case\",\n\t\treference: toLowerCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toLowerCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMaxValue/toMaxValue.ts\n/**\n* Creates a to max value transformation action.\n*\n* @param requirement The maximum value.\n*\n* @returns A to max value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMaxValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_max_value\",\n\t\treference: toMaxValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMinValue/toMinValue.ts\n/**\n* Creates a to min value transformation action.\n*\n* @param requirement The minimum value.\n*\n* @returns A to min value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMinValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_min_value\",\n\t\treference: toMinValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toNumber/toNumber.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toNumber(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_number\",\n\t\treference: toNumber,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = Number(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toString/toString.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toString(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_string\",\n\t\treference: toString,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = String(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"string\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toUpperCase/toUpperCase.ts\n/**\n* Creates a to upper case transformation action.\n*\n* @returns A to upper case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toUpperCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_upper_case\",\n\t\treference: toUpperCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toUpperCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transform.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transform(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transform,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transformAsync.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transformAsync(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transformAsync,\n\t\tasync: true,\n\t\toperation,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trim/trim.ts\n/**\n* Creates a trim transformation action.\n*\n* @returns A trim action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trim() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim\",\n\t\treference: trim,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trim();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimEnd/trimEnd.ts\n/**\n* Creates a trim end transformation action.\n*\n* @returns A trim end action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimEnd() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_end\",\n\t\treference: trimEnd,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimEnd();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimStart/trimStart.ts\n/**\n* Creates a trim start transformation action.\n*\n* @returns A trim start action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimStart() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_start\",\n\t\treference: trimStart,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimStart();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ulid/ulid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ulid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ulid\",\n\t\treference: ulid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ULID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"ULID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/url/url.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction url(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"url\",\n\t\treference: url,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\ttry {\n\t\t\t\tnew URL(input);\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"URL\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/uuid/uuid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction uuid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"uuid\",\n\t\treference: uuid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: UUID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"UUID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/value/value.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction value(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"value\",\n\t\treference: value,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/values/values.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction values(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"values\",\n\t\treference: values,\n\t\tasync: false,\n\t\texpects: `${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/words/words.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction words(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"words\",\n\t\treference: words,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/assert/assert.ts\n/**\n* Checks if the input matches the schema. As this is an assertion function, it\n* can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*/\nfunction assert(schema, input) {\n\tconst issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n\tif (issues) throw new ValiError(issues);\n}\n\n//#endregion\n//#region src/methods/config/config.ts\n/**\n* Changes the local configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param config The parse configuration.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction config(schema, config$1) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config_) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config_,\n\t\t\t\t...config$1\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getFallback/getFallback.ts\n/**\n* Returns the fallback value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The output dataset if available.\n* @param config The config if available.\n*\n* @returns The fallback value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallback(schema, dataset, config$1) {\n\treturn typeof schema.fallback === \"function\" ? schema.fallback(dataset, config$1) : schema.fallback;\n}\n\n//#endregion\n//#region src/methods/fallback/fallback.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallback(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/fallback/fallbackAsync.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallbackAsync(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = await schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: await /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/flatten/flatten.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction flatten(issues) {\n\tconst flatErrors = {};\n\tfor (const issue of issues) if (issue.path) {\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) {\n\t\t\tif (!flatErrors.nested) flatErrors.nested = {};\n\t\t\tif (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);\n\t\t\telse flatErrors.nested[dotPath] = [issue.message];\n\t\t} else if (flatErrors.other) flatErrors.other.push(issue.message);\n\t\telse flatErrors.other = [issue.message];\n\t} else if (flatErrors.root) flatErrors.root.push(issue.message);\n\telse flatErrors.root = [issue.message];\n\treturn flatErrors;\n}\n\n//#endregion\n//#region src/methods/forward/forward.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forward(action, path) {\n\treturn {\n\t\t...action,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/forward/forwardAsync.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forwardAsync(action, path) {\n\treturn {\n\t\t...action,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = await action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getDefault/getDefault.ts\n/**\n* Returns the default value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The input dataset if available.\n* @param config The config if available.\n*\n* @returns The default value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefault(schema, dataset, config$1) {\n\treturn typeof schema.default === \"function\" ? schema.default(dataset, config$1) : schema.default;\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaults.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefaults(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getDefaults);\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaultsAsync.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getDefaultsAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getDefaultsAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getDefaultsAsync));\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDescription/getDescription.ts\n/**\n* Returns the description of the schema.\n*\n* If multiple descriptions are defined, the last one of the highest level is\n* returned. If no description is defined, `undefined` is returned.\n*\n* @param schema The schema to get the description from.\n*\n* @returns The description, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDescription(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"description\");\n}\n\n//#endregion\n//#region src/methods/getExamples/getExamples.ts\n/**\n* Returns the examples of a schema.\n*\n* If multiple examples are defined, it concatenates them using depth-first\n* search. If no examples are defined, an empty array is returned.\n*\n* @param schema The schema to get the examples from.\n*\n* @returns The examples, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getExamples(schema) {\n\tconst examples$1 = [];\n\tfunction depthFirstCollect(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstCollect(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"examples\") examples$1.push(...item.examples);\n\t\t}\n\t}\n\tdepthFirstCollect(schema);\n\treturn examples$1;\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacks.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallbacks(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getFallbacks);\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacksAsync.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getFallbacksAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getFallbacksAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getFallbacksAsync));\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getMetadata/getMetadata.ts\n/**\n* Returns the metadata of a schema.\n*\n* If multiple metadata are defined, it shallowly merges them using depth-first\n* search. If no metadata is defined, an empty object is returned.\n*\n* @param schema Schema to get the metadata from.\n*\n* @returns The metadata, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getMetadata(schema) {\n\tconst result = {};\n\tfunction depthFirstMerge(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstMerge(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"metadata\") Object.assign(result, item.metadata);\n\t\t}\n\t}\n\tdepthFirstMerge(schema);\n\treturn result;\n}\n\n//#endregion\n//#region src/methods/getTitle/getTitle.ts\n/**\n* Returns the title of the schema.\n*\n* If multiple titles are defined, the last one of the highest level is\n* returned. If no title is defined, `undefined` is returned.\n*\n* @param schema The schema to get the title from.\n*\n* @returns The title, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getTitle(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"title\");\n}\n\n//#endregion\n//#region src/methods/is/is.ts\n/**\n* Checks if the input matches the schema. By using a type predicate, this\n* function can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*\n* @returns Whether the input matches the schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction is(schema, input) {\n\treturn !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n//#endregion\n//#region src/schemas/any/any.ts\n/**\n* Creates an any schema.\n*\n* Hint: This schema function exists only for completeness and is not\n* recommended in practice. Instead, `unknown` should be used to accept\n* unknown data.\n*\n* @returns An any schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction any() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"any\",\n\t\treference: any,\n\t\texpects: \"any\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/array.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction array(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: array,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.item[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/arrayAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction arrayAsync(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: arrayAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(input.map((value$1) => this.item[\"~run\"]({ value: value$1 }, config$1)));\n\t\t\t\tfor (let key = 0; key < itemDatasets.length; key++) {\n\t\t\t\t\tconst itemDataset = itemDatasets[key];\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/bigint/bigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bigint(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"bigint\",\n\t\treference: bigint,\n\t\texpects: \"bigint\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"bigint\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/blob/blob.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction blob(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"blob\",\n\t\treference: blob,\n\t\texpects: \"Blob\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Blob) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/boolean/boolean.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction boolean(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"boolean\",\n\t\treference: boolean,\n\t\texpects: \"boolean\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"boolean\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/custom.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction custom(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: custom,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/customAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction customAsync(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: customAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (await this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/date/date.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction date(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"date\",\n\t\treference: date,\n\t\texpects: \"Date\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/enum/enum.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction enum_(enum__, message$1) {\n\tconst options = [];\n\tfor (const key in enum__) if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) options.push(enum__[key]);\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"enum\",\n\t\treference: enum_,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\tenum: enum__,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptional,\n\t\texpects: wrapped.expects,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptionalAsync,\n\t\texpects: wrapped.expects,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/file/file.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction file(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"file\",\n\t\treference: file,\n\t\texpects: \"File\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof File) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/function/function.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction function_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"function\",\n\t\treference: function_,\n\t\texpects: \"Function\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"function\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/instance/instance.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction instance(class_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"instance\",\n\t\treference: instance,\n\t\texpects: class_.name,\n\t\tasync: false,\n\t\tclass: class_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof this.class) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/utils/_merge/_merge.ts\n/**\n* Merges two values into one single output.\n*\n* @param value1 First value.\n* @param value2 Second value.\n*\n* @returns The merge dataset.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _merge(value1, value2) {\n\tif (typeof value1 === typeof value2) {\n\t\tif (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return { value: value1 };\n\t\tif (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n\t\t\tfor (const key in value2) if (key in value1) {\n\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\tvalue1[key] = dataset.value;\n\t\t\t} else value1[key] = value2[key];\n\t\t\treturn { value: value1 };\n\t\t}\n\t\tif (Array.isArray(value1) && Array.isArray(value2)) {\n\t\t\tif (value1.length === value2.length) {\n\t\t\t\tfor (let index = 0; index < value1.length; index++) {\n\t\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n\t\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\t\tvalue1[index] = dataset.value;\n\t\t\t\t}\n\t\t\t\treturn { value: value1 };\n\t\t\t}\n\t\t}\n\t}\n\treturn { issue: true };\n}\n\n//#endregion\n//#region src/schemas/intersect/intersect.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersect(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersect,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tfor (const schema of this.options) {\n\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/intersectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersectAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersectAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tconst optionDatasets = await Promise.all(this.options.map((schema) => schema[\"~run\"]({ value: input }, config$1)));\n\t\t\t\tfor (const optionDataset of optionDatasets) {\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazy.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazy(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazy,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.getter(dataset.value)[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazyAsync.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazyAsync(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazyAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn (await this.getter(dataset.value))[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/literal/literal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction literal(literal_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"literal\",\n\t\treference: literal,\n\t\texpects: /* @__PURE__ */ _stringify(literal_),\n\t\tasync: false,\n\t\tliteral: literal_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === this.literal) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/map.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction map(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: map,\n\t\texpects: \"Map\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tfor (const [inputKey, inputValue] of input) {\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: inputKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/mapAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: mapAsync,\n\t\texpects: \"Map\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tconst datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([\n\t\t\t\t\tinputKey,\n\t\t\t\t\tinputValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: inputKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: inputValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nan/nan.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nan(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nan\",\n\t\treference: nan,\n\t\texpects: \"NaN\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (Number.isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/never/never.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction never(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"never\",\n\t\treference: never,\n\t\texpects: \"never\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\t_addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullable(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullable,\n\t\texpects: \"!null\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullableAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullableAsync,\n\t\texpects: \"!null\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullish(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullish,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullishAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullishAsync,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptional(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptional,\n\t\texpects: \"!undefined\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptionalAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptionalAsync,\n\t\texpects: \"!undefined\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/null/null.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction null_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"null\",\n\t\treference: null_,\n\t\texpects: \"null\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullable,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullableAsync,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullish(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullish,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullishAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullishAsync,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/number/number.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction number(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"number\",\n\t\treference: number,\n\t\texpects: \"number\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"number\" && !isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/object.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction object(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: object,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/objectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: objectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRest(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRest,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) {\n\t\t\t\t\t\tconst valueDataset = this.rest[\"~run\"]({ value: input[key] }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRestAsync(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRestAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(Object.entries(input).filter(([key]) => /* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value$1]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue$1,\n\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t]))]);\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, valueDataset] of restDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optional,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optionalAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/picklist/picklist.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction picklist(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"picklist\",\n\t\treference: picklist,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/promise/promise.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction promise(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"promise\",\n\t\treference: promise,\n\t\texpects: \"Promise\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Promise) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/record.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction record(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: record,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const entryKey in input) if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {\n\t\t\t\t\tconst entryValue = input[entryKey];\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: entryKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: entryValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/recordAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction recordAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: recordAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst datasets = await Promise.all(Object.entries(input).filter(([key$1]) => /* @__PURE__ */ _isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([\n\t\t\t\t\tentryKey,\n\t\t\t\t\tentryValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: entryKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: entryValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/set.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction set(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: set,\n\t\texpects: \"Set\",\n\t\tasync: false,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tfor (const inputValue of input) {\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/setAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction setAsync(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: setAsync,\n\t\texpects: \"Set\",\n\t\tasync: true,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tconst valueDatasets = await Promise.all([...input].map(async (inputValue) => [inputValue, await this.value[\"~run\"]({ value: inputValue }, config$1)]));\n\t\t\t\tfor (const [inputValue, valueDataset] of valueDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/string/string.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction string(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"string\",\n\t\treference: string,\n\t\texpects: \"string\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"string\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/symbol/symbol.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction symbol(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"symbol\",\n\t\treference: symbol,\n\t\texpects: \"symbol\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"symbol\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRest(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRest,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.rest[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRestAsync(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRestAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(input.slice(this.items.length).map(async (value$1, key) => {\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey + this.items.length,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}))]);\n\t\t\t\tfor (const [key, value$1, itemDataset] of normalDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, itemDataset] of restDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefined/undefined.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefined_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefined\",\n\t\treference: undefined_,\n\t\texpects: \"undefined\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedable,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedableAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/utils/_subIssues/_subIssues.ts\n/**\n* Returns the sub issues of the provided datasets for the union issue.\n*\n* @param datasets The datasets.\n*\n* @returns The sub issues.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _subIssues(datasets) {\n\tlet issues;\n\tif (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);\n\telse issues = dataset.issues;\n\treturn issues;\n}\n\n//#endregion\n//#region src/schemas/union/union.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction union(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: union,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/unionAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction unionAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: unionAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/unknown/unknown.ts\n/**\n* Creates a unknown schema.\n*\n* @returns A unknown schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unknown() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"unknown\",\n\t\treference: unknown,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variant.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variant(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variant,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true }).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tparseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variantAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variantAsync(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variantAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = async (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") await parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? (await discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true })).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tawait parseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/void/void.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction void_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"void\",\n\t\treference: void_,\n\t\texpects: \"void\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/keyof/keyof.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction keyof(schema, message$1) {\n\treturn /* @__PURE__ */ picklist(Object.keys(schema.entries), message$1);\n}\n\n//#endregion\n//#region src/methods/message/message.ts\n/**\n* Changes the local message configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param message_ The error message.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction message(schema, message_) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config$1,\n\t\t\t\tmessage: message_\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/omit/omit.ts\n/**\n* Creates a modified copy of an object schema that does not contain the\n* selected entries.\n*\n* @param schema The schema to omit from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction omit(schema, keys) {\n\tconst entries$1 = { ...schema.entries };\n\tfor (const key of keys) delete entries$1[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/parse/parse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nfunction parse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parse/parseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nasync function parseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parser/parser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parser(schema, config$1) {\n\tconst func = (input) => parse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/parser/parserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parserAsync(schema, config$1) {\n\tconst func = (input) => parseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/partial/partial.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partial(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optional(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/partial/partialAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialAsync(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optionalAsync(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pick/pick.ts\n/**\n* Creates a modified copy of an object schema that contains only the selected\n* entries.\n*\n* @param schema The schema to pick from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction pick(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key of keys) entries$1[key] = schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipe.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipe(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipeAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipeAsync(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/required.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction required(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptional(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/requiredAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction requiredAsync(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptionalAsync(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function safeParseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParser(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParserAsync(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/summarize/summarize.ts\n/**\n* Summarize the error messages of issues in a pretty-printable multi-line string.\n*\n* @param issues The list of issues.\n*\n* @returns A summary of the issues.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction summarize(issues) {\n\tlet summary = \"\";\n\tfor (const issue of issues) {\n\t\tif (summary) summary += \"\\n\";\n\t\tsummary += `\u00D7 ${issue.message}`;\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) summary += `\\n  \u2192 at ${dotPath}`;\n\t}\n\treturn summary;\n}\n\n//#endregion\n//#region src/methods/unwrap/unwrap.ts\n/**\n* Unwraps the wrapped schema.\n*\n* @param schema The schema to be unwrapped.\n*\n* @returns The unwrapped schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unwrap(schema) {\n\treturn schema.wrapped;\n}\n\n//#endregion\nexport { BASE64_REGEX, BIC_REGEX, CUID2_REGEX, DECIMAL_REGEX, DIGITS_REGEX, EMAIL_REGEX, EMOJI_REGEX, HEXADECIMAL_REGEX, HEX_COLOR_REGEX, IMEI_REGEX, IPV4_REGEX, IPV6_REGEX, IP_REGEX, ISO_DATE_REGEX, ISO_DATE_TIME_REGEX, ISO_TIMESTAMP_REGEX, ISO_TIME_REGEX, ISO_TIME_SECOND_REGEX, ISO_WEEK_REGEX, MAC48_REGEX, MAC64_REGEX, MAC_REGEX, NANO_ID_REGEX, OCTAL_REGEX, RFC_EMAIL_REGEX, SLUG_REGEX, ULID_REGEX, UUID_REGEX, ValiError, _addIssue, _getByteCount, _getGraphemeCount, _getLastMetadata, _getStandardProps, _getWordCount, _isLuhnAlgo, _isValidObjectKey, _joinExpects, _stringify, any, args, argsAsync, array, arrayAsync, assert, awaitAsync, base64, bic, bigint, blob, boolean, brand, bytes, check, checkAsync, checkItems, checkItemsAsync, config, creditCard, cuid2, custom, customAsync, date, decimal, deleteGlobalConfig, deleteGlobalMessage, deleteSchemaMessage, deleteSpecificMessage, description, digits, email, emoji, empty, endsWith, entries, entriesFromList, entriesFromObjects, enum_ as enum, enum_, everyItem, exactOptional, exactOptionalAsync, examples, excludes, fallback, fallbackAsync, file, filterItems, findItem, finite, flatten, flavor, forward, forwardAsync, function_ as function, function_, getDefault, getDefaults, getDefaultsAsync, getDescription, getDotPath, getExamples, getFallback, getFallbacks, getFallbacksAsync, getGlobalConfig, getGlobalMessage, getMetadata, getSchemaMessage, getSpecificMessage, getTitle, graphemes, gtValue, hash, hexColor, hexadecimal, imei, includes, instance, integer, intersect, intersectAsync, ip, ipv4, ipv6, is, isOfKind, isOfType, isValiError, isoDate, isoDateTime, isoTime, isoTimeSecond, isoTimestamp, isoWeek, keyof, lazy, lazyAsync, length, literal, looseObject, looseObjectAsync, looseTuple, looseTupleAsync, ltValue, mac, mac48, mac64, map, mapAsync, mapItems, maxBytes, maxEntries, maxGraphemes, maxLength, maxSize, maxValue, maxWords, message, metadata, mimeType, minBytes, minEntries, minGraphemes, minLength, minSize, minValue, minWords, multipleOf, nan, nanoid, never, nonEmpty, nonNullable, nonNullableAsync, nonNullish, nonNullishAsync, nonOptional, nonOptionalAsync, normalize, notBytes, notEntries, notGraphemes, notLength, notSize, notValue, notValues, notWords, null_ as null, null_, nullable, nullableAsync, nullish, nullishAsync, number, object, objectAsync, objectWithRest, objectWithRestAsync, octal, omit, optional, optionalAsync, parse, parseAsync, parseJson, parser, parserAsync, partial, partialAsync, partialCheck, partialCheckAsync, pick, picklist, pipe, pipeAsync, promise, rawCheck, rawCheckAsync, rawTransform, rawTransformAsync, readonly, record, recordAsync, reduceItems, regex, required, requiredAsync, returns, returnsAsync, rfcEmail, safeInteger, safeParse, safeParseAsync, safeParser, safeParserAsync, set, setAsync, setGlobalConfig, setGlobalMessage, setSchemaMessage, setSpecificMessage, size, slug, someItem, sortItems, startsWith, strictObject, strictObjectAsync, strictTuple, strictTupleAsync, string, stringifyJson, summarize, symbol, title, toBigint, toBoolean, toDate, toLowerCase, toMaxValue, toMinValue, toNumber, toString, toUpperCase, transform, transformAsync, trim, trimEnd, trimStart, tuple, tupleAsync, tupleWithRest, tupleWithRestAsync, ulid, undefined_ as undefined, undefined_, undefinedable, undefinedableAsync, union, unionAsync, unknown, unwrap, url, uuid, value, values, variant, variantAsync, void_ as void, void_, words };", "import m from \"mithril\";\nimport { asUrn, TribbleDB } from \"@rgrannell1/tribbledb\";\nimport type { TripleObject } from \"@rgrannell1/tribbledb\";\nimport { ThingLink } from \"../components/thing-link.ts\";\nimport type { ThingLinkAttrs } from \"../components/thing-link.ts\";\nimport { one } from \"../commons/arrays.ts\";\n\n/*\n * Read a thing as an undifferentiated TripleObject\n * by URN\n */\nexport function readThing(\n  tdb: TribbleDB,\n  urn: string,\n): TripleObject | undefined {\n  const { id, type } = asUrn(urn);\n\n  return tdb.search({\n    source: { id, type },\n  }).firstObject();\n}\n\n/*\n * Read and parse a thing by URN\n */\nexport function readParsedThing<T>(\n  parser: (tdb: TribbleDB, thing: TripleObject) => T | undefined,\n  tdb: TribbleDB,\n  id: string,\n): T | undefined {\n  const thing = readThing(tdb, id);\n  if (!thing) {\n    return undefined;\n  }\n\n  return parser(tdb, thing);\n}\n\n/*\n * Read an array of things by URN\n *\n * @param tdb TribbleDB instance\n * @param urns Set of URNs to read\n */\nexport function readThings(\n  tdb: TribbleDB,\n  urns: Set<string>,\n): TripleObject[] {\n  const things: TripleObject[] = [];\n\n  for (const urn of urns) {\n    const thing = readThing(tdb, urn);\n    if (thing) {\n      things.push(thing);\n    }\n  }\n\n  return things;\n}\n\n/*\n * Read an array of parsed things by URNs\n */\nexport const readParsedThings = function <T>(\n  parser: (tdb: TribbleDB, thing: TripleObject) => T | undefined,\n  tdb: TribbleDB,\n  urns: Set<string>,\n): T[] {\n  if (typeof parser !== \"function\") {\n    throw new Error(\"Parser must be a function\");\n  }\n\n  const parsedThings: T[] = [];\n\n  for (const urn of urns) {\n    const thing = readThing(tdb, urn);\n    if (!thing) {\n      continue;\n    }\n\n    const parsed = parser(tdb, thing);\n    if (parsed) {\n      parsedThings.push(parsed);\n    }\n  }\n\n  return parsedThings;\n};\n\n/*\n * Read all things of a given type that have a name\n */\nexport function readNamedTypeThings<T>(\n  tdb: TribbleDB,\n  type: string,\n): TripleObject[] {\n  const things = tdb.search({\n    source: { type },\n  }).objects();\n\n  return things\n    .filter((thing) => {\n      return Object.prototype.hasOwnProperty.call(thing, \"name\");\n    })\n    .sort((thinga, thingb) => {\n      const firstName = thinga.name;\n      const secondName = thingb.name;\n\n      const first = one(firstName) as string;\n      const second = one(secondName) as string;\n\n      return first.localeCompare(second);\n    });\n}\n\n// TODO: remove mithril, move to presenter folder!!\nexport function toThingLinks(\n  tdb: TribbleDB,\n  urns: (string | undefined)[],\n): m.Vnode<ThingLinkAttrs, {}>[] {\n  return urns.flatMap((urn) => {\n    if (!urn) {\n      return [];\n    }\n    const thing = readThing(tdb, urn);\n\n    if (!thing || !thing.name) {\n      return [];\n    }\n\n    return [m(ThingLink, { urn, thing })];\n  });\n}\n", "import m from \"mithril\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport { navigate } from \"../commons/events.ts\";\n\nimport { one } from \"../commons/arrays.ts\";\nimport { thingEmoji } from \"../services/emoji.ts\";\nimport type { Thing } from \"../types.ts\";\n\nexport type ThingLinkAttrs = {\n  urn: string;\n  thing: Thing;\n};\n\n/* */\nexport function ThingLink() {\n  return {\n    view(vnode: m.Vnode<ThingLinkAttrs>) {\n      const { urn, thing } = vnode.attrs;\n      const { type, id } = asUrn(urn);\n\n      let name = id;\n      if (Object.prototype.hasOwnProperty.call(thing, \"name\")) {\n        const candidate = one((thing as { name: string | string[] }).name);\n        if (candidate) {\n          name = candidate;\n        }\n      }\n\n      const emoji = thingEmoji(urn, name, thing);\n\n      return m(\"a\", {\n        href: urn,\n        onclick: navigate(`/thing/${type}:${id}`),\n        class: [\"thing-link\", `${type}-link`].join(\" \"),\n      }, `${emoji}\\t${name}`);\n    },\n  };\n}\n", "/*\n * Given a value, array of values, or undefined, return an array.\n * This is often required when dealing with relations that may have multiple values.\n */\nexport function arrayify<T>(value: T | T[] | undefined): T[] {\n  if (value === undefined) {\n    return [];\n  }\n\n  return Array.isArray(value) ? value : [value];\n}\n\n/*\n * Return the first value, or undefined. Often needed in cases where\n * a triple object theoretically could have multiple or missing values (e.g name)\n * but won't in practice.\n */\nexport function one<T>(value: T | T[] | undefined): T | undefined {\n  return Array.isArray(value) ? value[0] : value;\n}\n", "import { asUrn } from \"@rgrannell1/tribbledb\";\nimport { one } from \"../commons/arrays.ts\";\nimport {\n  CAMERA_MODELS,\n  KnownTypes,\n  PHONE_MODELS,\n  PLACE_FEATURES_TO_EMOJI,\n} from \"../constants.ts\";\nimport type { Thing } from \"../types.ts\";\n\n/*\n * Pick an emoji based on the place feature\n *\n * @param thing The place\n */\nexport function placeEmoji(thing: any): string {\n  const feature = one(thing.features);\n  const { id: featureId } = asUrn(feature);\n\n  if (\n    Object.prototype.hasOwnProperty.call(PLACE_FEATURES_TO_EMOJI, featureId)\n  ) {\n    return PLACE_FEATURES_TO_EMOJI[\n      featureId as keyof typeof PLACE_FEATURES_TO_EMOJI\n    ];\n  }\n\n  return \"\uD83D\uDCCD\";\n}\n\n/*\n * Load an emoji relating to a place (e.g church emoji for religious sites)\n */\nexport function placeFeatureEmoji(featureUrn: string): string {\n  const { id: featureId } = asUrn(featureUrn);\n\n  if (\n    Object.prototype.hasOwnProperty.call(PLACE_FEATURES_TO_EMOJI, featureId)\n  ) {\n    return PLACE_FEATURES_TO_EMOJI[\n      featureId as keyof typeof PLACE_FEATURES_TO_EMOJI\n    ];\n  }\n\n  return \"\uD83D\uDCCD\";\n}\n\n/*\n * Pick an flag based on the country definition\n *\n * @param thing The country thing\n */\nexport function countryEmoji(thing: any): string {\n  const flag = one(thing.flag);\n  return flag; //?? \"\uD83C\uDFF3\uFE0F\";\n}\n\n/*\n * Pick a bird emoji\n */\nfunction birdEmoji(): string {\n  return \"\uD83D\uDC24\";\n}\n\n/*\n * Pick an emoji for the camera\n *\n * @param thing The thing to get the emoji for, based on id\n */\nfunction cameraEmoji(thing: Thing): string {\n  const { id } = asUrn(thing.id);\n\n  if (CAMERA_MODELS.has(id)) {\n    return \"\uD83D\uDCF7\";\n  } else if (PHONE_MODELS.has(id)) {\n    return \"\uD83D\uDCF1\";\n  }\n\n  return \"\uD83D\uDCF7\";\n}\n\n/* */\nexport function thingEmoji(urn: string, _: string, thing: Thing): string {\n  const { type } = asUrn(urn);\n\n  switch (type) {\n    case KnownTypes.PLACE:\n      return placeEmoji(thing);\n    case KnownTypes.COUNTRY:\n      return countryEmoji(thing);\n    case KnownTypes.BIRD:\n      return birdEmoji();\n    case KnownTypes.CAMERA:\n      return cameraEmoji(thing);\n    case KnownTypes.PLACE_FEATURE:\n      return placeFeatureEmoji(urn);\n    default:\n      return \"\";\n  }\n}\n", "import {\n  asUrn,\n  type TribbleDB,\n  type TripleObject,\n} from \"@rgrannell1/tribbledb\";\nimport { logParseWarning } from \"../commons/logger.ts\";\nimport { type BaseSchema, type InferOutput, safeParse } from \"valibot\";\nimport { readParsedThing, readParsedThings } from \"./things.ts\";\nimport { one } from \"../commons/arrays.ts\";\n\ntype Parser<T> = (tdb: TribbleDB, thing: TripleObject) => T | undefined;\n\n/*\n * Create a parser for a specific schema.\n */\nexport function parseObject<\n  TSchema extends BaseSchema<unknown, unknown, any>,\n  TType extends string,\n>(\n  schema: TSchema,\n  type: TType,\n): (\n  _: TribbleDB,\n  object: TripleObject,\n) => (InferOutput<TSchema> & { type: TType }) | undefined {\n  return (_: TribbleDB, object: TripleObject) => {\n    const result = safeParse(schema, object);\n\n    if (!result.success) {\n      logParseWarning(result.issues);\n      return;\n    }\n\n    return { ...result.output as any, type } as InferOutput<TSchema> & {\n      type: TType;\n    };\n  };\n}\n\n/*\n * Create a parser that selects the appropriate parser based on the type of the object.\n */\nexport function parseByType<T>(\n  typeParsers: Record<string, Parser<T>>,\n): Parser<T> {\n  return (tdb: TribbleDB, thing: TripleObject) => {\n    const { type } = asUrn(one(thing.id)!);\n\n    const parser = typeParsers[type] ?? typeParsers[\"default\"];\n    if (!parser) {\n      return undefined;\n    }\n\n    return parser(tdb, thing);\n  };\n}\n\n/*\n * Create a one-item reader for a specific parser.\n */\nexport function readOne<T>(parser: Parser<T>) {\n  return (tdb: TribbleDB, id: string) => {\n    return readParsedThing(parser, tdb, id);\n  };\n}\n\n/*\n * Create a many-item reader for a specific parser.\n */\nexport function readMany<T>(parser: Parser<T>) {\n  if (typeof parser !== \"function\") {\n    throw new Error(\"Parser must be a function\");\n  }\n\n  return (tdb: TribbleDB, urns: Set<string>) => {\n    return readParsedThings(parser, tdb, urns);\n  };\n}\n\n/*\n * Create both one-item and many-item readers for a specific parser.\n */\nexport function readers<T>(parser: Parser<T>) {\n  return {\n    one: readOne(parser),\n    many: readMany(parser),\n  };\n}\n", "/*\n * Defines Zod schemas that we use to convert Tribble objects into something\n * with actual type-safety.\n */\n\nimport {\n  any,\n  array,\n  integer,\n  number,\n  object,\n  optional,\n  pipe,\n  string,\n  transform,\n  union,\n  url,\n} from \"valibot\";\n\nconst v = {\n  string,\n  array,\n  object,\n  optional,\n  union,\n  any,\n  pipe,\n  url,\n  integer,\n  number,\n  transform,\n};\n\nexport const AlbumSchema = v.object({\n  name: v.string(),\n  id: v.string(),\n  trip: v.optional(v.string()),\n  minDate: v.pipe(v.string(), v.transform(Number)),\n  maxDate: v.pipe(v.string(), v.transform(Number)),\n  thumbnailUrl: v.string(),\n  // TODO this is silly\n  mosaic: v.string(),\n  photosCount: v.pipe(v.string(), v.transform(Number)),\n  videosCount: v.pipe(v.string(), v.transform(Number)),\n  country: v.union([v.string(), v.array(v.string())]),\n  description: v.optional(v.string()),\n});\n\nexport const CountrySchema = v.object({\n  id: v.string(),\n  flag: v.optional(v.string()),\n  name: v.string(),\n  contains: v.optional(v.union([v.string(), v.array(v.string())])),\n  in: v.optional(v.union([v.string(), v.array(v.string())])),\n});\n\nexport const UnescoSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  longitude: v.optional(v.string()),\n  latitude: v.optional(v.string()),\n});\n\nexport const PlaceSchema = v.object({\n  id: v.string(),\n  name: v.string(),\n  features: v.optional(v.union([v.string(), v.array(v.string())])),\n  in: v.optional(v.union([v.string(), v.array(v.string())])),\n  shortName: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n  unescoId: v.optional(v.string()),\n});\n\nexport const PhotoSchema = v.object({\n  albumId: v.string(),\n  country: v.optional(v.union([v.string(), v.array(v.string())])),\n  createdAt: v.string(),\n  subject: v.optional(v.union([v.string(), v.array(v.string())])),\n  exposureTime: v.optional(v.string()),\n  fStop: v.optional(v.string()),\n  focalLength: v.optional(v.string()),\n  fullImage: v.string(),\n  height: v.optional(v.string()),\n  id: v.string(),\n  iso: v.optional(v.string()),\n  location: v.optional(v.union([v.string(), v.array(v.string())])),\n  midImageLossyUrl: v.string(),\n  model: v.optional(v.string()),\n  mosaicColours: v.string(),\n  pngUrl: v.string(),\n  rating: v.string(),\n  style: v.optional(v.string()),\n  thumbnailUrl: v.string(),\n  width: v.optional(v.string()),\n  description: v.optional(v.string()),\n  summary: v.optional(v.string()),\n  contrastingGrey: v.string(),\n});\n\nexport const MammalSchema = v.object({\n  id: v.string(),\n  name: v.string(),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const ReptileSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const FishSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const AmphibianSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const InsectSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const SubjectSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n});\n\nexport const BirdSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n  wikipedia: v.optional(v.string()),\n  birdwatchUrl: v.optional(v.union([v.string(), v.array(v.string())])),\n});\n\nexport const VideoSchema = v.object({\n  id: v.string(),\n  albumId: v.string(),\n  description: v.string(),\n  posterUrl: v.pipe(v.string(), v.url()),\n  videoUrl1080p: v.pipe(v.string(), v.url()),\n  videoUrl480p: v.pipe(v.string(), v.url()),\n  videoUrl720p: v.pipe(v.string(), v.url()),\n  videoUrlUnscaled: v.pipe(v.string(), v.url()),\n});\n\nexport const StatsSchema = v.object({\n  photos: v.pipe(v.number(), v.integer()),\n  videos: v.pipe(v.number(), v.integer()),\n  albums: v.pipe(v.number(), v.integer()),\n  years: v.pipe(v.number(), v.integer()),\n  countries: v.pipe(v.number(), v.integer()),\n  bird_species: v.pipe(v.number(), v.integer()),\n  mammal_species: v.pipe(v.number(), v.integer()),\n  amphibian_species: v.pipe(v.number(), v.integer()),\n  reptile_species: v.pipe(v.number(), v.integer()),\n  unesco_sites: v.pipe(v.number(), v.integer()),\n});\n\nexport const FeatureSchema = v.object({\n  id: v.string(),\n  name: v.optional(v.string()),\n});\n", "import { KnownTypes } from \"../constants.ts\";\nimport type {\n  Amphibian,\n  Bird,\n  Fish,\n  Insect,\n  Mammal,\n  Reptile,\n  Stats,\n} from \"../types.ts\";\nimport { parseByType, parseObject } from \"../commons/parser.ts\";\nimport {\n  AlbumSchema,\n  AmphibianSchema,\n  BirdSchema,\n  CountrySchema,\n  FeatureSchema,\n  FishSchema,\n  InsectSchema,\n  MammalSchema,\n  PhotoSchema,\n  PlaceSchema,\n  ReptileSchema,\n  StatsSchema,\n  UnescoSchema,\n  VideoSchema,\n} from \"../schemas.ts\";\nimport { safeParse } from \"valibot\";\nimport type { TribbleDB } from \"@rgrannell1/tribbledb\";\n\nexport const parseFeature = parseObject(FeatureSchema, \"feature\");\nexport const parseCountry = parseObject(CountrySchema, \"country\");\nexport const parseUnesco = parseObject(UnescoSchema, \"unesco\");\nexport const parsePhoto = parseObject(PhotoSchema, \"photo\");\nexport const parseBird = parseObject(BirdSchema, \"bird\");\nexport const parseMammal = parseObject(MammalSchema, \"mammal\");\nexport const parseReptile = parseObject(ReptileSchema, \"reptile\");\nexport const parseAmphibian = parseObject(AmphibianSchema, \"amphibian\");\nexport const parseInsect = parseObject(InsectSchema, \"insect\");\nexport const parseFish = parseObject(FishSchema, \"fish\");\nexport const parseVideo = parseObject(VideoSchema, \"video\");\nexport const parsePlace = parseObject(PlaceSchema, \"place\");\nexport const parseAlbum = parseObject(AlbumSchema, \"album\");\n\n/*\n * Parse known subject types\n */\nexport const parseSubject = parseByType<\n  Bird | Mammal | Reptile | Amphibian | Insect | Fish\n>({\n  [KnownTypes.BIRD]: parseBird,\n  [KnownTypes.MAMMAL]: parseMammal,\n  [KnownTypes.REPTILE]: parseReptile,\n  [KnownTypes.AMPHIBIAN]: parseAmphibian,\n  [KnownTypes.INSECT]: parseInsect,\n  [KnownTypes.FISH]: parseFish,\n});\n\n/*\n * Parse on object identified by a location relation\n */\nexport const parseLocation = parseByType<any>({\n  [KnownTypes.PLACE]: parsePlace,\n  [KnownTypes.COUNTRY]: parseCountry,\n  [KnownTypes.UNESCO]: parseUnesco,\n});\n\n/*\n * Parse stats object\n */\nexport function parseStats(stats: unknown): Stats | undefined {\n  return safeParse(StatsSchema, stats).success ? (stats as Stats) : undefined;\n}\n", "import { TribbleDB } from \"@rgrannell1/tribbledb\";\nimport { readers } from \"../commons/parser.ts\";\n\nimport {\n  parseAlbum,\n  parseAmphibian,\n  parseCountry,\n  parseFeature,\n  parseFish,\n  parseInsect,\n  parseLocation,\n  parseMammal,\n  parsePhoto,\n  parsePlace,\n  parseReptile,\n  parseSubject,\n  parseUnesco,\n  parseVideo,\n} from \"./parsers.ts\";\n\nexport const { one: readCountry, many: readCountries } = readers(parseCountry);\nexport const { one: readPlace, many: readPlaces } = readers(parsePlace);\nexport const { one: readLocation, many: readLocations } = readers(\n  parseLocation,\n);\nexport const { one: readUnesco, many: readUnescos } = readers(parseUnesco);\nexport const { one: readAlbum, many: readAlbums } = readers(parseAlbum);\nexport const { one: readMammal, many: readMammals } = readers(parseMammal);\nexport const { one: readReptile, many: readReptiles } = readers(parseReptile);\nexport const { one: readInsect, many: readInsects } = readers(parseInsect);\n// Thank you, english.\nexport const { one: readFish, many: readFishes } = readers(parseFish);\nexport const { one: readSubject, many: readSubjects } = readers(parseSubject);\nexport const { one: readAmphibian, many: readAmphibians } = readers(\n  parseAmphibian,\n);\nexport const { one: readVideo, many: readVideos } = readers(parseVideo);\nexport const { one: readPhoto, many: readPhotos } = readers(parsePhoto);\nexport const { one: readFeature, many: readFeatures } = readers(parseFeature);\n", "import { KnownRelations, PHOTO_WIDTH } from \"../constants.ts\";\nimport { asUrn, TribbleDB } from \"@rgrannell1/tribbledb\";\nimport type { Location, Photo, Subject } from \"../types.ts\";\nimport {\n  readLocations,\n  readPhoto,\n  readPhotos,\n  readSubjects,\n} from \"./readers.ts\";\n\n\n/*\n* Determine whether a photo should be eagerly or lazily loaded\n* depending on page position\n*/\nexport function loadingMode(idx: number): \"eager\" | \"lazy\" {\n  const viewportWidth = (globalThis as any).innerWidth;\n  const viewportHeight = (globalThis as any).innerHeight;\n\n  const imageDimension = PHOTO_WIDTH;\n  const maxImagesPerRow = Math.floor(viewportWidth / imageDimension);\n  const maxRowsInFold = Math.floor(viewportHeight / imageDimension);\n\n  return idx > (maxImagesPerRow * maxRowsInFold) + 1 ? \"lazy\" : \"eager\";\n}\n\nconst COLOURS_CACHE: Map<string, string> = new Map();\n\n/*\n * Convert a mosaic colour string into a bitmap data URL\n */\nexport function encodeBitmapDataURL(colours: string): string {\n  if (COLOURS_CACHE.has(colours)) {\n    return COLOURS_CACHE.get(colours) as string;\n  }\n\n  const coloursList = colours.split(\"#\").map((colour: string) => `#${colour}`);\n  const canvas = (window as any).document.createElement(\"canvas\");\n  canvas.width = 2;\n  canvas.height = 2;\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    throw new Error(\"context missing\");\n  }\n  ctx.fillStyle = coloursList[1];\n  ctx.fillRect(0, 0, 1, 1);\n  ctx.fillStyle = coloursList[2];\n  ctx.fillRect(1, 0, 1, 1);\n  ctx.fillStyle = coloursList[3];\n  ctx.fillRect(0, 1, 1, 1);\n  ctx.fillStyle = coloursList[4];\n  ctx.fillRect(1, 1, 1, 1);\n\n  COLOURS_CACHE.set(colours, canvas.toDataURL(\"image/png\"));\n  return COLOURS_CACHE.get(colours) as string;\n}\n\n/*\n * Read all photos, sorted by date\n */\nexport function readAllPhotos(tdb: TribbleDB): Photo[] {\n  const photos = tdb.search({\n    source: {type: 'photo'}\n  }).sources();\n\n  return readPhotos(tdb, photos).sort((photoa, photob) => {\n    return parseInt(photob.createdAt) - parseInt(photoa.createdAt);\n  });\n}\n\n/*\n * Read the locations and subjects associated with a set of photo ids\n */\nexport function readThingsByPhotoIds(tdb: TribbleDB, photoIds: Set<string>): {\n  locations: Location[];\n  subjects: Subject[];\n} {\n  const locations = new Set<string>();\n  const subjects = new Set<string>();\n\n  for (const photoId of photoIds) {\n    const pid = asUrn(photoId);\n\n    const obj = tdb.search({\n      source: { type: pid.type, id: pid.id },\n      relation: [KnownRelations.LOCATION, KnownRelations.SUBJECT],\n    }).firstObject(true);\n\n    if (!obj) {\n      continue;\n    }\n\n    const location = obj?.location ?? [];\n    const subject = obj?.subject ?? [];\n\n    for (const loc of location) {\n      locations.add(loc);\n    }\n    for (const subj of subject) {\n      subjects.add(subj);\n    }\n  }\n\n  return {\n    subjects: readSubjects(tdb, subjects),\n    locations: readLocations(tdb, locations),\n  };\n}\n\n/* */\nexport function readPhotosByThingIds(\n  tdb: TribbleDB,\n  thingsUrns: Set<string>,\n): Photo[] {\n  const photoIds = new Set<string>();\n\n  for (const thingUrn of thingsUrns) {\n    const { type, id } = asUrn(thingUrn);\n\n    const results = tdb.search({\n      source: { type: \"photo\" },\n      //relation: KnownRelations.SUBJECT, TODO\n      target: { type, id },\n    }).sources();\n\n    for (const result of results) {\n      photoIds.add(result);\n    }\n  }\n\n  return readPhotos(tdb, photoIds).sort((photoa, photob) => {\n    return parseInt(photob.createdAt) - parseInt(photoa.createdAt);\n  });\n}\n\nexport function readThingCover(\n  tdb: TribbleDB,\n  thingUrn: string,\n): Photo | undefined {\n  const { type, id } = asUrn(thingUrn);\n\n  const source = tdb.search({\n    source: { type: \"photo\" },\n    relation: \"cover\",\n    target: { type, id },\n  }).firstSource();\n\n  return source ? readPhoto(tdb, source) : undefined;\n}\n\nfunction sortByRating(photoa: Photo, photob: Photo) {\n  const ratingA = photoa.rating;\n  const ratingB = photob.rating;\n\n  return ratingB.toLocaleString().localeCompare(ratingA.toLocaleString());\n}\n\n/*\n * Read a cover image for a thing\n */\nexport function chooseThingCover(\n  tdb: TribbleDB,\n  thingUrn: string,\n) {\n  const { type, id } = asUrn(thingUrn);\n\n  const cover = readThingCover(tdb, thingUrn);\n  if (cover) {\n    return cover;\n  }\n\n  const results = tdb.search({\n    source: { type: \"photo\" },\n    target: { type, id },\n  }).sources();\n\n  const photos = readPhotos(tdb, new Set(results)).sort(sortByRating);\n\n  return photos.length > 0 ? photos[0] : null;\n}\n", "import { asUrn, TribbleDB } from \"@rgrannell1/tribbledb\";\nimport type { Album } from \"../types.ts\";\nimport type { Photo, Video } from \"../types.ts\";\nimport { readThingsByPhotoIds } from \"./photos.ts\";\nimport { readPhotos } from \"./readers.ts\";\nimport { KnownRelations, KnownTypes } from \"../constants.ts\";\nimport { readAlbums, readVideos } from \"./readers.ts\";\n\n/*\n * Get the album date\n */\nexport function albumYear(album: Album): number {\n  return new Date(album.minDate).getFullYear();\n}\n\n/*\n * Read albums from the TribbleDB\n */\nexport function readAllAlbums(tdb: TribbleDB): Album[] {\n  const ids = tdb.search({\n    source: { type: KnownTypes.ALBUM },\n  }).sources();\n\n  return (readAlbums(tdb, ids) as Album[])\n    .sort((album0: Album, album1: Album) => {\n      return album1.minDate - album0.minDate;\n    });\n}\n\n/*\n * Get the photo IDs associated with an album ID\n *\n * @param tdb TribbleDB instance\n * @param id Album URN\n */\nexport function readAlbumPhotoIds(tdb: TribbleDB, id: string): Set<string> {\n  return tdb.search({\n    source: { type: KnownTypes.PHOTO },\n    relation: KnownRelations.ALBUM_ID,\n    target: { id: asUrn(id).id },\n  }).sources();\n}\n\n/*\n * Read photos associated with an album\n *\n * @param tdb TribbleDB instance\n * @param id Album URN\n */\nexport function readAlbumPhotosByAlbumId(tdb: TribbleDB, id: string): Photo[] {\n  return readPhotos(tdb, readAlbumPhotoIds(tdb, id));\n}\n\n/*\n * Read videos associated with an album\n *\n * @param tdb TribbleDB instance\n * @param id Album URN\n */\nexport function readAlbumVideoIds(tdb: TribbleDB, id: string): Set<string> {\n  return tdb.search({\n    source: { type: KnownTypes.VIDEO },\n    relation: KnownRelations.ALBUM_ID,\n    target: { id: asUrn(id).id },\n  }).sources();\n}\n\n/*\n * Read videos associated with an album\n *\n * @param tdb TribbleDB instance\n * @param id Album URN\n */\nexport function readAlbumVideosByAlbumId(tdb: TribbleDB, id: string): Video[] {\n  return readVideos(tdb, readAlbumVideoIds(tdb, id));\n}\n\n/*\n * Photos in an album are associated with places (`location` relation) and\n * with subjects (`subject` relation). This function enumerates information on all of the\n * things in an album via the relation\n *\n * (x) -> [:subject|:location] -> (:photo) - [:albumId] -> (id:album)\n */\nexport function readThingsByAlbumId(tdb: TribbleDB, id: string) {\n  return readThingsByPhotoIds(tdb, readAlbumPhotoIds(tdb, id));\n}\n\n/*\n * Read albums associated with a set of thing IDs\n */\nexport function readAlbumsByThingIds(\n  tdb: TribbleDB,\n  thingsUrns: Set<string>,\n) {\n  const photoIds = new Set<string>();\n\n  // first, collect photo-ids associated with the things\n  for (const thingUrn of thingsUrns) {\n    const { type, id } = asUrn(thingUrn);\n\n    const results = tdb.search({ target: { type, id } }).sources();\n\n    for (const result of results) {\n      photoIds.add(result);\n    }\n  }\n\n  const albumIds = new Set<string>();\n\n  // next, collect album-ids associated with the photos\n  for (const photoId of photoIds) {\n    const pid = asUrn(photoId);\n\n    const albums = tdb.search({\n      source: { type: pid.type, id: pid.id },\n      relation: KnownRelations.ALBUM_ID,\n    }).targets();\n\n    for (const id of albums) {\n      albumIds.add(`urn:r\u00F3:album:${id}`);\n    }\n  }\n\n  return readAlbums(tdb, albumIds);\n}\n", "/*\n * Handle name lookups\n */\n\nimport { TribbleDB } from \"@rgrannell1/tribbledb\";\nimport { KnownRelations } from \"../constants.ts\";\n\nconst NAME_TO_URN_CACHE: Map<string, string> = new Map();\n\n/*\n * Convert names to tribble URNs\n *\n * @param tdb - The TribbleDB instance\n * @param names - A set of names to convert\n *\n * @returns A set of corresponding URNs\n */\nexport function namesToUrns(tdb: TribbleDB, names: Set<string>): Set<string> {\n  const urns: Set<string> = new Set();\n  if (names.size === 0) {\n    return urns;\n  }\n\n  // lookup cached names first\n  for (const name of names) {\n    if (NAME_TO_URN_CACHE.has(name)) {\n      const cachedUrn = NAME_TO_URN_CACHE.get(name);\n      if (cachedUrn) {\n        urns.add(cachedUrn);\n      }\n    }\n  }\n\n  // if all names are cached, don't query TDB at all,\n  // since this method is slow\n  if (urns.size === names.size) {\n    return urns;\n  }\n\n  const namesCursor = tdb.search({\n    relation: KnownRelations.NAME,\n    target: Array.from(names),\n  });\n\n  for (const [urn, _, name] of namesCursor.triples()) {\n    if (names.has(name as string)) {\n      urns.add(urn as string);\n    }\n  }\n\n  return urns;\n}\n", "import type { AppWindow, State } from \"./types.ts\";\nimport * as DarkMode from \"./services/dark-mode.ts\";\nimport { loadTriples } from \"./semantic/data.ts\";\nimport { deriveTriples, postIndexing, HARD_CODED_TRIPLES } from \"./semantic/derive.ts\";\nimport { TribbleDB } from \"@rgrannell1/tribbledb\";\n\nimport { readAlbumsByThingIds } from \"./services/albums.ts\";\nimport {\n  readAlbum,\n  readAmphibian,\n  readCountries,\n  readCountry,\n  readFeatures,\n  readInsect,\n  readLocation,\n  readLocations,\n  readMammal,\n  readPhoto,\n  readPhotos,\n  readPlace,\n  readReptile,\n  readUnesco,\n  readUnescos,\n  readVideo,\n} from \"./services/readers.ts\";\nimport { chooseThingCover, readPhotosByThingIds } from \"./services/photos.ts\";\nimport { readThings, toThingLinks } from \"./commons/things.ts\";\nimport { namesToUrns } from \"./services/names.ts\";\n\n/*\n * Load data from the tribbles file.\n * This is ccurrently done in a single blocking load which is not efficient.\n */\nasync function loadData() {\n  const schema = {};\n  const tdb = await loadTriples(\n    `/manifest/tribbles.${(window as AppWindow).envConfig.publication_id}.txt`,\n    schema,\n    deriveTriples,\n  );\n\n  postIndexing(tdb);\n\n  tdb.add(HARD_CODED_TRIPLES);\n\n  return tdb;\n}\n\n/*\n * Commonly used services that depend on state\n *\n * This is not pleasant, though I don't see a simpler method.\n */\nexport function loadServices(tdb: TribbleDB) {\n  return {\n    readThing: tdb.readThing,\n    readAlbum: readAlbum.bind(null, tdb),\n    readCountry: readCountry.bind(null, tdb),\n    readPlace: readPlace.bind(null, tdb),\n    readPhoto: readPhoto.bind(null, tdb),\n    readMammal: readMammal.bind(null, tdb),\n    readReptile: readReptile.bind(null, tdb),\n    readAmphibian: readAmphibian.bind(null, tdb),\n    readInsect: readInsect.bind(null, tdb),\n    readVideo: readVideo.bind(null, tdb),\n    readLocation: readLocation.bind(null, tdb),\n    readUnesco: readUnesco.bind(null, tdb),\n    readLocations: readLocations.bind(null, tdb),\n    readFeatures: readFeatures.bind(null, tdb),\n    readPhotos: readPhotos.bind(null, tdb),\n    readUnescos: readUnescos.bind(null, tdb),\n    readThings: readThings.bind(null, tdb),\n    readCountries: readCountries.bind(null, tdb),\n    namesToUrns: namesToUrns.bind(null, tdb),\n    readThingCover: chooseThingCover.bind(null, tdb),\n    readPhotosByThingIds: readPhotosByThingIds.bind(null, tdb),\n    readAlbumsByThingIds: readAlbumsByThingIds.bind(null, tdb),\n    toThingLinks: toThingLinks.bind(null, tdb),\n  };\n}\n\n/*\n * Load the application state from localStorage or return defaults.\n */\nexport async function loadState(): Promise<State> {\n  const data = await loadData();\n\n  return {\n    currentAlbum: undefined,\n    currentPhoto: undefined,\n    currentUrn: undefined,\n    currentType: undefined,\n    data,\n    darkMode: DarkMode.load(),\n    sidebarVisible: false,\n    services: loadServices(data),\n  };\n}\n", "import m from \"mithril\";\nimport { navigate } from \"../commons/events.ts\";\n\ntype SidebarItemAttrs = {\n  name: string;\n  route: string;\n};\n\ntype SidebarAttrs = {\n  visible: boolean;\n};\n\n/*\n * Defines each item in the sidebar\n */\nfunction SidebarItem() {\n  return {\n    view(vnode: m.Vnode<SidebarItemAttrs>) {\n      return m(\"li\", {\n        class: \"sidebar-item\",\n        onclick: navigate(vnode.attrs.route),\n      }, vnode.attrs.name);\n    },\n  };\n}\n\n/*\n * Defines the app sidebar\n */\nexport function Sidebar() {\n  function classes(visible: boolean) {\n    const cls = [\"photo-sidebar\"];\n    if (visible) {\n      cls.push(\"sidebar-visible\");\n    }\n    return cls.join(\" \");\n  }\n\n  return {\n    view(vnode: m.Vnode<SidebarAttrs>) {\n      return m(\"aside\", { class: classes(vnode.attrs.visible) }, [\n        m(\"nav\", [\n          m(\"ul\", [\n            m(SidebarItem, { name: \"PHOTOS\", route: \"/photos\" }),\n            m(SidebarItem, { name: \"VIDEOS\", route: \"/videos\" }),\n            m(SidebarItem, { name: \"ALBUMS\", route: \"/albums\" }),\n            m(SidebarItem, { name: \"LISTINGS\", route: \"/listings\" }),\n            m(SidebarItem, { name: \"ABOUT\", route: \"/about\" }),\n          ]),\n        ]),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { AlbumStats } from \"../components/album-stats.ts\";\nimport type { Album, Services } from \"../types.ts\";\nimport { encodeBitmapDataURL, loadingMode } from \"../services/photos.ts\";\nimport { PhotoAlbumMetadata } from \"../components/photo-album-metadata.ts\";\nimport { PhotoAlbum } from \"../components/photo-album.ts\";\nimport { setTitle } from \"../services/window.ts\";\nimport { CountryLink } from \"../components/place-links.ts\";\nimport { block, broadcast } from \"../commons/events.ts\";\nimport { albumYear } from \"../services/albums.ts\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport { setify } from \"../commons/sets.ts\";\n\ntype AlbumsListAttrs = {\n  albums: Album[];\n  services: Services;\n};\n\nfunction onAlbumClick(id: string, title: string, event: Event) {\n  const parsed = asUrn(id);\n\n  broadcast(\"navigate\", { route: `/album/${parsed.id}`, title });\n  block(event);\n}\n\nfunction drawAlbum(\n  state: { year: number },\n  album: Album,\n  idx: number,\n  services: Services,\n) {\n  const loading = loadingMode(idx);\n\n  const $albumComponents: m.Vnode<\n    unknown,\n    unknown\n  >[] = [];\n\n  // push year header if a new year\n  if (state.year !== albumYear(album)) {\n    state.year = albumYear(album);\n\n    if (state.year !== new Date().getFullYear()) {\n      const $h2 = m(\n        \"h2.album-year-heading\",\n        { key: `year-${state.year}` },\n        state.year.toString(),\n      );\n      $albumComponents.push($h2);\n    }\n  }\n\n  const $countryLinks = services.readCountries(setify(album.country)).map(\n    (country) => {\n      return m(CountryLink, {\n        country,\n        key: `album-country-${album.id}-${country.id}`,\n        mode: \"flag\",\n      });\n    },\n  );\n\n  const $md = m(PhotoAlbumMetadata, {\n    title: album.name,\n    minDate: album.minDate,\n    maxDate: album.maxDate,\n    count: album.photosCount,\n    countryLinks: $countryLinks,\n  });\n\n  const $album = m(PhotoAlbum, {\n    trip: album.trip,\n    imageUrl: album.thumbnailUrl,\n    thumbnailUrl: album.thumbnailUrl,\n    thumbnailDataUrl: encodeBitmapDataURL(album.mosaic),\n    loading: loading,\n    minDate: album.minDate,\n    onclick: onAlbumClick.bind(null, album.id, album.name),\n  });\n\n  $albumComponents.push(\n    m(\"div\", {\n      key: `album-${album.id}`,\n    }, [\n      $album,\n      $md,\n    ]),\n  );\n\n  return $albumComponents;\n}\n\n/*\n * Construct a list of albums\n */\nfunction AlbumsList() {\n  return {\n    view(vnode: m.Vnode<AlbumsListAttrs>) {\n      const state = { year: 2005 };\n      const { albums, services } = vnode.attrs;\n\n      const $albumComponents: m.Vnode<\n        unknown,\n        unknown\n      >[] = [];\n\n      // TODO this blocks render too long\n      for (let idx = 0; idx < albums.length; idx++) {\n        $albumComponents.push(...drawAlbum(state, albums[idx], idx, services));\n      }\n\n      return m(\"section.album-container\", $albumComponents);\n    },\n  };\n}\n\ntype AlbumsPageAttrs = {\n  albums: Album[];\n  services: Services;\n};\n\n/* */\nexport function AlbumsPage() {\n  return {\n    oninit() {\n      setTitle(\"Albums - photos\");\n    },\n    view(vnode: m.Vnode<AlbumsPageAttrs>) {\n      const { albums, services } = vnode.attrs;\n\n      const $md = m(\"section.album-metadata\", [\n        m(\"h1.albums-header\", \"Albums\"),\n        m(AlbumStats),\n      ]);\n\n      return m(\"div.page\", [\n        $md,\n        //m(YearCursor),\n        m(AlbumsList, { albums, services }),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { AppWindow } from \"../types.ts\";\nimport { parseStats } from \"../services/parsers.ts\";\n\n/*\n * Show statistics and links for the album pages\n */\nexport function AlbumStats() {\n  const stats = parseStats((window as AppWindow).stats);\n\n  return {\n    view() {\n      if (!stats) {\n        return m(\"p\");\n      }\n\n      return m(\"p.photo-stats\", [\n        `${stats.photos} `,\n        m(\"a\", { href: \"#/photos\" }, \"photos\"),\n        \" \u00B7 \",\n        `${stats.videos} `,\n        m(\"a\", { href: \"#/videos\" }, \"videos\"),\n        \" \u00B7 \",\n        `${stats.albums} albums \u00B7 ${stats.years} years \u00B7 `,\n        `${stats.countries} `,\n        m(\"a\", { href: \"#/listing/country\" }, \"countries\"),\n        \" \u00B7 \",\n        `${stats.bird_species} `,\n        m(\"a\", { href: \"#/listing/bird\" }, \"bird species\"),\n        \" \u00B7 \",\n        `${stats.mammal_species} `,\n        m(\"a\", { href: \"#/listing/mammal\" }, \"mammal species\"),\n        \" \u00B7 a few \",\n        m(\"a\", { href: \"#/listing/amphibian\" }, \"amphibians\"),\n        \" and \",\n        m(\"a\", { href: \"#/listing/reptile\" }, \"reptiles\"),\n        \" \u00B7 \",\n        `${stats.unesco_sites} `,\n        m(\"a\", { href: \"#/thing/unesco:*\" }, \"UNESCO sites\"),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { isSmallerThan } from \"../services/window.ts\";\nimport * as Dates from \"../services/dates.ts\";\nimport type { CountryLinkAttrs } from \"./place-links.ts\";\nimport { SMALL_DEVICE_WIDTH } from \"../constants.ts\";\n\nexport type PhotoAlbumMetadataAttrs = {\n  title: string;\n  minDate?: number;\n  maxDate?: number;\n  count: number;\n  countryLinks: m.Vnode<CountryLinkAttrs, unknown>[];\n};\n\n/* */\nexport function PhotoAlbumMetadata() {\n  function dateRange(minDate?: number, maxDate?: number) {\n    if (!minDate || !maxDate) {\n      return \"unknown date\";\n    }\n\n    const isSmall = isSmallerThan(SMALL_DEVICE_WIDTH);\n    return Dates.dateRange(minDate, maxDate, isSmall);\n  }\n\n  return {\n    view(vnode: m.Vnode<PhotoAlbumMetadataAttrs>) {\n      const { title, minDate, maxDate, count, countryLinks } = vnode.attrs;\n      const text = count === 1 ? \"photo\" : \"photos\";\n\n      return m(\"div.photo-album-metadata\", [\n        m(\"p.photo-album-title\", title),\n        m(\"p.photo-album-date\", [\n          m(\"time\", dateRange(minDate, maxDate)),\n        ]),\n        m(\"div.photo-metadata-inline\", [\n          m(\"p.photo-album-count\", `${count} ${text}`),\n          m(\"p.photo-album-countries\", countryLinks),\n        ]),\n      ]);\n    },\n  };\n}\n", "/*\n * Window lookup\n */\n\nimport { SMALL_DEVICE_WIDTH } from \"../constants\";\n\n/*\n * Check if the window is smaller than a given width\n * used to detect a mobile device\n */\nexport function isSmallerThan(width: number = SMALL_DEVICE_WIDTH): boolean {\n  return globalThis.matchMedia(`(max-width: ${width}px)`).matches;\n}\n\n/*\n * Set the page's title\n */\nexport function setTitle(title: string) {\n  document.title = title;\n}\n", "/* Parse an image datetime to a JS date */\nexport function parse(dateTime: string): Date {\n  let [date, time] = dateTime.split(\" \");\n  date = date.replace(/:/g, \"-\");\n\n  return new Date(`${date} ${time}`);\n}\n\n/* Format an exif date as a normal datestring */\nexport function formatExifDate(dateTime: string): string {\n  if (!dateTime) {\n    return dateTime;\n  }\n\n  const createdAt = new Date(dateTime).toISOString();\n  const [date, time] = createdAt.split(\"T\")[0].replace(/\\:/g, \"-\");\n\n  return `${date.replace(/\\:/g, \"/\")} ${time}`;\n}\n\n/* Format the created-at timestamp to a human-readable date */\nexport function formatCreatedAt(dateTime: string): string {\n  const date = new Date(parseInt(dateTime));\n  const options: Intl.DateTimeFormatOptions = {\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"numeric\",\n  };\n\n  return date.toLocaleDateString(\"en-US\", options);\n}\n\n/* Format a date range */\nexport function dateRange(\n  minDate: Date | number,\n  maxDate: Date | number,\n  short: boolean,\n): string {\n  if (!minDate && !maxDate) {\n    return \"unknown date\";\n  }\n\n  const parsedMinDate = minDate instanceof Date ? minDate : new Date(minDate);\n  const parsedMaxDate = maxDate instanceof Date ? maxDate : new Date(maxDate);\n\n  if (short) {\n    const optsShort: Intl.DateTimeFormatOptions = {\n      day: \"numeric\",\n      month: \"short\",\n    };\n    const from = parsedMinDate.toLocaleDateString(\"en-IE\", optsShort);\n    const to = parsedMaxDate.toLocaleDateString(\"en-IE\", optsShort);\n\n    const minDay = parsedMinDate.toLocaleDateString(\"en-IE\", {\n      day: \"numeric\",\n    } as Intl.DateTimeFormatOptions);\n    const maxDay = parsedMaxDate.toLocaleDateString(\"en-IE\", {\n      day: \"numeric\",\n    } as Intl.DateTimeFormatOptions);\n\n    const minMonth = parsedMinDate.toLocaleDateString(\"en-IE\", {\n      month: \"short\",\n    } as Intl.DateTimeFormatOptions);\n    const maxMonth = parsedMaxDate.toLocaleDateString(\"en-IE\", {\n      month: \"short\",\n    } as Intl.DateTimeFormatOptions);\n\n    const minYear = parsedMinDate.getFullYear();\n    const maxYear = parsedMaxDate.getFullYear();\n\n    const monthsEqual = minMonth === maxMonth;\n    const yearsEqual = minYear === maxYear;\n\n    if (from === to) {\n      // e.g 22 Feb 2022\n      return `${from} ${minYear}`;\n    } else if (monthsEqual && yearsEqual) {\n      // e.g 22 - 24 Feb 2022\n\n      return `${minDay} - ${maxDay} ${maxMonth} ${minYear}`;\n    } else {\n      return `${from} ${minYear} - ${to} ${maxYear}`;\n    }\n  } else {\n    const opts: Intl.DateTimeFormatOptions = {\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n    };\n    const from = parsedMinDate.toLocaleDateString(\"en-IE\", opts);\n    const to = parsedMaxDate.toLocaleDateString(\"en-IE\", opts);\n\n    if (from === to) {\n      return from;\n    }\n\n    return `${from} \u2014 ${to}`;\n  }\n}\n", "import m from \"mithril\";\nimport { ImagePair } from \"./photo.ts\";\n\n// use this to keep track of trips, to assign each a\n// colour distinct from the adjacent ones\nconst TRIPS: string[] = [];\n\nfunction TripTag() {\n  return {\n    view(vnode: m.Vnode<{ trip: string | undefined }>) {\n      const { trip } = vnode.attrs;\n\n      if (!trip) {\n        return null;\n      }\n\n      if (!TRIPS.includes(trip)) {\n        TRIPS.push(trip);\n      }\n\n      // two colours supported\n      const tripIndex = TRIPS.indexOf(trip);\n      return m(\"div.trip-tag .trip-color-\" + (tripIndex % 2));\n    },\n  };\n}\n\nexport type PhotoAlbumAttrs = {\n  trip: string | undefined;\n  imageUrl: string;\n  thumbnailUrl: string;\n  thumbnailDataUrl: string;\n  loading: \"eager\" | \"lazy\";\n  child?: m.Children;\n  onclick?: (e: Event) => void;\n  minDate?: number;\n};\n\n/* */\nexport function PhotoAlbum() {\n  return {\n    view(vnode: m.Vnode<PhotoAlbumAttrs>) {\n      const {\n        imageUrl,\n        thumbnailUrl,\n        thumbnailDataUrl,\n        loading,\n        child,\n        minDate,\n        onclick,\n        trip,\n      } = vnode.attrs;\n\n      return m(\"div.photo-album\", { \"data-min-date\": minDate }, [\n        m(TripTag, { trip }),\n        m(ImagePair, {\n          imageUrl,\n          thumbnailUrl,\n          thumbnailDataUrl,\n          loading,\n          onclick,\n        }),\n        // NODE this might be broken\n        child,\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { parseUrn } from \"@rgrannell1/tribbledb\";\n\nimport { block, broadcast } from \"../commons/events.ts\";\nimport { MetadataIcon } from \"./metadata-icon.ts\";\nimport { PHOTO_HEIGHT, PHOTO_WIDTH } from \"../constants.ts\";\nimport { encodeBitmapDataURL } from \"../services/photos.ts\";\nimport type { Photo as PhotoType } from \"../types.ts\";\n\n/*\n * Broadcast an event when a photo loads, and swap out the placeholder\n */\nfunction loadImage(url: string, event: Event) {\n  broadcast(\"photo_loaded\", { url });\n\n  const $placeholder = (event.target as HTMLElement)?.parentNode\n    ?.querySelector(\n      \".thumbnail-placeholder\",\n    ) as HTMLElement;\n\n  if (!$placeholder) {\n    return;\n  }\n\n  $placeholder.style.zIndex = \"-1\";\n}\n\ntype ImageAttrs = {\n  thumbnailUrl: string;\n  loading: \"eager\" | \"lazy\";\n  onclick: ((e: Event) => void) | undefined;\n};\n\n/*\n * The thumbnail image itself\n */\nfunction Image() {\n  return {\n    view(vnode: m.Vnode<ImageAttrs>) {\n      const { thumbnailUrl, loading, onclick } = vnode.attrs;\n\n      return m(\"img.thumbnail-image\", {\n        onload: loadImage.bind(null, thumbnailUrl),\n        width: PHOTO_WIDTH,\n        height: PHOTO_HEIGHT,\n        src: thumbnailUrl,\n        loading: loading,\n        onclick,\n      });\n    },\n  };\n}\n\ntype PlaceholderImageAttrs = {\n  thumbnailDataUrl: string;\n};\n\n/*\n * The placeholder data URL\n */\nfunction PlaceholderImage() {\n  return {\n    view(vnode: m.Vnode<PlaceholderImageAttrs>) {\n      const { thumbnailDataUrl } = vnode.attrs;\n\n      return m(\"img.u-photo.thumbnail-image.thumbnail-placeholder\", {\n        width: PHOTO_WIDTH,\n        height: PHOTO_HEIGHT,\n        src: thumbnailDataUrl,\n      });\n    },\n  };\n}\n\ntype ImagePairAttrs = {\n  imageUrl: string;\n  thumbnailUrl: string;\n  thumbnailDataUrl: string;\n  loading: \"eager\" | \"lazy\";\n  onclick: ((e: Event) => void) | undefined;\n};\n\n/*\n * The underlying pair of images. One is the actual thumbnail, which\n * takes time to load. The other will be a grid data URL that instantly loads.\n */\nexport function ImagePair() {\n  return {\n    view(vnode: m.Vnode<ImagePairAttrs>) {\n      const {\n        imageUrl,\n        thumbnailUrl,\n        thumbnailDataUrl,\n        loading,\n        onclick,\n      } = vnode.attrs;\n\n      return m(\"a\", {\n        href: imageUrl,\n        target: \"_blank\",\n        rel: \"external\",\n      }, [\n        m(PlaceholderImage, { thumbnailDataUrl }),\n        m(Image, { thumbnailUrl, loading, onclick }),\n      ]);\n    },\n  };\n}\n\n/* */\nfunction formatId(id: string): string {\n  return id.startsWith(\"urn:\") ? parseUrn(id).id : id;\n}\n\nexport type PhotoAttrs = {\n  photo: PhotoType;\n  loading: \"eager\" | \"lazy\";\n  interactive?: boolean;\n};\n\n/*\n * Represents a photo, with a metadata link and the fake-progressive-loading\n * features (https://rgrannell.xyz/replacing-google-photos) to make images appear blank for\n * less time.\n */\nexport function Photo() {\n  return {\n    view(vnode: m.Vnode<PhotoAttrs>) {\n      const { photo, loading, interactive } = vnode.attrs;\n      const id = formatId(photo.id);\n      const {\n        fullImage,\n        thumbnailUrl,\n        mosaicColours,\n      } = photo;\n\n      // encode a grid of colours into a data URL\n      const thumbnailDataUrl = encodeBitmapDataURL(mosaicColours);\n\n      const $mdIcon = m(MetadataIcon, { id, colour: photo.contrastingGrey });\n      const $imagePair = m(ImagePair, {\n        imageUrl: photo.fullImage,\n        thumbnailUrl,\n        thumbnailDataUrl,\n        loading,\n        onclick: () => {\n          window.location.href = fullImage;\n        },\n      });\n\n      return m(\n        \"div\",\n        m(\"div.photo\", {}, [\n          m(\n            \"a\",\n            { onclick: block },\n            interactive\n              ? [\n                $mdIcon,\n                $imagePair,\n              ]\n              : [$imagePair],\n          ),\n        ]),\n      );\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { broadcast } from \"../commons/events.ts\";\n\n/* */\nfunction InfoSVG() {\n  return {\n    view(vnode: m.Vnode<{ colour: string }>) {\n      const { colour } = vnode.attrs;\n\n      return m(\"svg.photo-icon\", {\n        height: 40,\n        width: 40,\n        preserveAspectRatio: \"xMinYMin\",\n        viewBox: \"-2 -2 24 24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n      }, [\n        m(\"path\", {\n          d: \"m10 20c-5.523 0-10-4.477-10-10s4.477-10 10-10 10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm0-10a1 1 0 0 1 1 1v5a1 1 0 0 1 -2 0v-5a1 1 0 0 1 1-1zm0-1a1 1 0 1 1 0-2 1 1 0 0 1 0 2z\",\n          fill: colour,\n        }),\n      ]);\n    },\n  };\n}\n\ntype MetadataIconAttrs = {\n  id: string;\n  colour: string;\n};\n\n/* */\nexport function MetadataIcon() {\n  return {\n    view(vnode: m.Vnode<MetadataIconAttrs>) {\n      const { id, colour } = vnode.attrs;\n\n      return m(\"div.photo-metadata-popover\", {\n        onclick: () => broadcast(\"navigate\", { route: `/photo/${id}` }),\n      }, m(InfoSVG, { colour }));\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { urnToUrl } from \"../models/urn.ts\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport { navigate } from \"../commons/events.ts\";\nimport { isACountry } from \"../types.ts\";\nimport type { Country, Place } from \"../types.ts\";\nimport { one } from \"../commons/arrays.ts\";\nimport { countryEmoji, placeEmoji } from \"../services/emoji.ts\";\n\nexport type CountryLinkAttrs = {\n  country: Country;\n  mode: \"flag\" | \"name\";\n};\n\n/*\n * Construct a link to a country. Reuse existing emoji lookup logic\n */\nexport function CountryLink() {\n  return {\n    view(vnode: m.Vnode<CountryLinkAttrs>) {\n      const { country, mode } = vnode.attrs;\n      const { id, name } = country;\n\n      if (!id) {\n        return m(\"p\");\n      }\n\n      const flag = countryEmoji(country);\n\n      const parsed = asUrn(id);\n      const onclick = navigate(`/thing/${parsed.type}:${parsed.id}`);\n\n      if (mode === \"flag\") {\n        return m(\"a.country-link-short\", { href: urnToUrl(id), onclick }, flag);\n      }\n\n      return m(\n        \"a.country-link\",\n        { href: urnToUrl(id), onclick },\n        `${flag} ${name}`,\n      );\n    },\n  };\n}\n\n/*\n * Create a link to a place. Reuse existing emoji lookup logic\n */\nexport function PlaceLink() {\n  return {\n    view(vnode: m.Vnode<{ location: Place; mode: \"flag\" | \"name\" }>) {\n      const { location, mode } = vnode.attrs;\n\n      let text = \"\";\n      if (mode === \"flag\") {\n        text = placeEmoji(location);\n      }\n\n      text = `${placeEmoji(location)} ${one(location.name) || \"Unknown Place\"}`;\n\n      return m(\"a.place-link\", {\n        href: urnToUrl(location.id),\n        onclick: navigate(`/thing/place:${location.id}`),\n      }, text);\n    },\n  };\n}\n\n/*\n * Create a link to a country / place\n */\nexport function LocationLink() {\n  return {\n    view(vnode: m.Vnode<{ location: Country | Place; mode: \"flag\" | \"name\" }>) {\n      const { location, mode } = vnode.attrs;\n\n      if (isACountry(location)) {\n        return m(CountryLink, { country: location, mode });\n      }\n\n      return m(PlaceLink, { location, mode });\n    },\n  };\n}\n", "import { asUrn } from \"@rgrannell1/tribbledb\";\n\n/*\n * Convert a URN into a URL for the thing page.\n */\nexport function urnToUrl(urn: string) {\n  const { type, id } = asUrn(urn);\n  return `#/thing/${type}:${id}`;\n}\n", "import type { TripleObject } from \"@rgrannell1/tribbledb\";\n\n/*\n * Given a value, array of values, or undefined, return a set.\n */\nexport function setify<T>(value: T | T[] | undefined): Set<T> {\n  if (value === undefined) {\n    return new Set();\n  }\n\n  return new Set(Array.isArray(value) ? value : [value]);\n}\n\n/*\n * Collect a set of property values from a list of triple objects.\n */\nexport function setOf<T>(property: string, objects: TripleObject[]): Set<T> {\n  const result = new Set<T>();\n\n  for (const obj of objects) {\n    if (property in obj) {\n      const value = obj[property] as T | T[] | undefined;\n      if (value === undefined) {\n        continue;\n      }\n\n      if (Array.isArray(value)) {\n        for (const elem of value) {\n          result.add(elem);\n        }\n      } else {\n        result.add(value);\n      }\n    }\n  }\n\n  return result;\n}\n", "import m from \"mithril\";\n\nimport { setTitle } from \"../services/window.ts\";\nimport { navigate } from \"../commons/events.ts\";\n\n/* */\nexport function AboutPage() {\n  return {\n    oninit() {\n      setTitle(\"About - photos\");\n    },\n    view() {\n      const years = new Date().getFullYear() - 2012;\n\n      return m(\"div.page\", [\n        m(\"section.about-page\", [\n          m(\"h1\", \"About\"),\n          m(\n            \"p\",\n            `I started taking photos ${years} years ago, and have taken a lot of photos since. I've become, in my opinion, a reasonable wildlife photographer (though hit-or-miss at other styles of photography). I built this website to share the things`,\n            m(\"a\", {\n              href: \"https://photos.rgrannell.xyz/#/thing/rating:4\",\n              onclick: navigate(`/thing/rating:4`),\n            }, \" I found beautiful in this world.\"),\n          ),\n          m(\"h2\", \"Can I use the photos on this site?\"),\n          m(\n            \"p\",\n            \"You may use this website and its content for personal, non-commerical purposes only. For example, using photos as a desktop wallpaper is fine, selling these photos is not.\",\n          ),\n          m(\"h2\", \"Can I use data from this site to train AI?\"),\n          m(\n            \"p\",\n            \"No, absolutely not. The \",\n            m(\n              \"a\",\n              { href: \"http://photos.rgrannell.xyz/robots.txt\" },\n              \"robots.txt\",\n            ),\n            \" file for this site explicitly prohibits this.\",\n          ),\n          m(\"h2\", \"What is your contact information?\"),\n          m(\n            \"p\",\n            \"See \",\n            m(\"a\", { href: \"https://rgrannell.xyz/\" }, \"my personal site\"),\n            \" for contact details.\",\n          ),\n        ]),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Video as VideoType } from \"../types.ts\";\nimport { Video } from \"../components/video.ts\";\nimport type { VideoAttrs } from \"../components/video.ts\";\n\ntype VideosPageAttrs = {\n  videos: VideoType[];\n};\n\n/* */\nexport function VideosPage() {\n  return {\n    view(vnode: m.Vnode<VideosPageAttrs>) {\n      const { videos } = vnode.attrs;\n      const videoLengthText = videos.length === 1\n        ? \"1 video\"\n        : `${videos.length} videos`;\n\n      const $videosList = videos.map((video) => {\n        return m(Video, { video, preload: \"auto\" } satisfies VideoAttrs);\n      });\n\n      return m(\n        \"div.page\",\n        m(\"section.photos-metadata\", [\n          m(\"h1\", \"Videos\"),\n          m(\"p.photo-album-count\", videoLengthText),\n        ]),\n        m(\"section.photo-container\", $videosList),\n      );\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Video } from \"../types.ts\";\n\nexport type VideoAttrs = {\n  preload: string;\n  video: Video;\n};\n\n/* */\nexport function Video() {\n  return {\n    view(vnode: m.Vnode<VideoAttrs>) {\n      const {\n        preload,\n        video,\n      } = vnode.attrs;\n\n      if (!video) {\n        return m(\"div\", \"No video\");\n      }\n\n      const {\n        posterUrl,\n        videoUrl1080p,\n        videoUrl480p,\n        videoUrl720p,\n        videoUrlUnscaled,\n      } = video;\n\n      const $source = m(\"source\", {\n        src: videoUrl480p,\n        type: \"video/mp4\",\n      });\n\n      const $resolutionLinks = m(\"ul\", [\n        m(\"a\", { href: videoUrlUnscaled }, \"[L]\"),\n        m(\"a\", { href: videoUrl1080p }, \"[M]\"),\n        m(\"a\", { href: videoUrl720p }, \"[S]\"),\n        m(\"a\", { href: videoUrl480p }, \"[XS]\"),\n      ]);\n\n      return m(\"div\", { key: `video-${video.id}` }, [\n        m(\"video.thumbnail-video\", {\n          controls: true,\n          preload,\n          poster: posterUrl,\n        }, $source),\n        $resolutionLinks,\n      ]);\n    },\n  };\n}\n", "import { TribbleDB } from \"@rgrannell1/tribbledb\";\nimport type { Video } from \"../types.ts\";\nimport { readVideos } from \"./readers.ts\";\n\n/*\n * Read and parse a video by URNs\n *\n * @param tdb The TribbleDB instance\n *\n * @return The parsed videos\n */\nexport function readAllVideos(tdb: TribbleDB): Video[] {\n  const videos = tdb.search({\n    source: { type: \"video\" },\n  }).sources();\n\n  return readVideos(tdb, videos);\n}\n", "import m from \"mithril\";\nimport { setTitle, isSmallerThan } from \"../services/window.ts\";\nimport * as Dates from \"../services/dates.ts\";\nimport { AlbumShareButton } from \"../components/album-share-button.ts\";\nimport { CountryLink } from \"../components/place-links.ts\";\nimport { Video } from \"../components/video.ts\";\nimport type { VideoAttrs } from \"../components/video.ts\";\nimport { loadingMode } from \"../services/photos.ts\";\n\nimport type {\n  Album,\n  Country,\n  Photo as PhotoType,\n  Services,\n  Thing,\n  Video as VideoType,\n} from \"../types.ts\";\nimport { Photo } from \"../components/photo.ts\";\nimport type { PhotoAttrs } from \"../components/photo.ts\";\nimport { AlbumsButton } from \"../components/albums-button.ts\";\nimport { preprocessDescription } from \"../commons/strings.ts\";\nimport { setify } from \"../commons/sets.ts\";\nimport { SMALL_DEVICE_WIDTH } from \"../constants.ts\";\n\ntype AlbumAttrs = {\n  album: Album;\n  subjects: Thing[];\n  locations: Location[];\n  country: Country[];\n  photos: PhotoType[];\n  videos: VideoType[];\n  services: Services;\n};\n\n/* */\nexport function AlbumPage() {\n  return {\n    oninit() {\n      setTitle(\"Album - photos\");\n    },\n    view(vnode: m.Vnode<AlbumAttrs>) {\n      const {\n        album,\n        photos,\n        videos,\n        services,\n      } = vnode.attrs;\n\n      const {\n        name,\n        minDate,\n        maxDate,\n        photosCount,\n        description,\n        country,\n      } = album;\n\n      const dateRange = Dates.dateRange(\n        minDate,\n        maxDate,\n        isSmallerThan(SMALL_DEVICE_WIDTH),\n      );\n\n      const photoCountMessage = photosCount === 1\n        ? \"1 photo\"\n        : `${photosCount} photos`;\n\n      const $countryLinks = services.readCountries(\n        services.namesToUrns(setify(country)),\n      ).map((country) => {\n        return m(CountryLink, {\n          country,\n          mode: \"flag\",\n        });\n      });\n\n      const $albumMetadata = m(\"section.photos-metadata\", [\n        m(\"h1\", name),\n        m(\"p.photo-album-date\", m(\"time\", dateRange)),\n        m(\"p.photo-album-count\", photoCountMessage),\n        m(\"p.photo-album-countries\", $countryLinks),\n        m(\n          \"p.photo-album-description\",\n          m.trust(preprocessDescription(description ?? \"\") ?? \"\"),\n        ),\n        m(AlbumShareButton, { url: location.href, name }),\n        \" \",\n        m(AlbumsButton),\n        \" \",\n      ]);\n\n      const $photosList = photos.map((photo, idx) => {\n        return m(\n          Photo,\n          {\n            photo,\n            loading: loadingMode(idx),\n            interactive: true,\n          } satisfies PhotoAttrs,\n        );\n      });\n      const $videosList = videos.map((video) => {\n        return m(Video, { video, preload: \"auto\" } satisfies VideoAttrs);\n      });\n\n      return m(\n        \"div.page\",\n        $albumMetadata,\n        m(\"section.photo-container\", $photosList),\n        m(\"section.video-container\", $videosList),\n      );\n    },\n  };\n}\n", "import m from \"mithril\";\n\ntype AlbumShareButtonAttrs = {\n  url: string;\n  name: string;\n};\n\n/* */\nfunction handleError(message: string) {\n  if (message.includes(\"Shared canceled\")) {\n    return;\n  }\n  alert(message);\n}\n\n/* */\nasync function shareAlbum(\n  state: { sharing: boolean },\n  url: string,\n  name: string,\n) {\n  if (!navigator.share) {\n    handleError(\"navigator.share not available\");\n    return;\n  }\n\n  try {\n    await navigator.share({\n      title: `${name} - photos.rgrannell.xyz`,\n      url,\n    });\n  } catch (error) {\n    console.error(\"Error sharing:\", error);\n  } finally {\n    state.sharing = false;\n  }\n}\n\n/* */\nfunction buttonText(state: { sharing: boolean }) {\n  return state.sharing ? \"[sharing...]\" : \"[share]\";\n}\n\n/* */\nexport function AlbumShareButton() {\n  const localState = {\n    sharing: false,\n  };\n\n  return {\n    view(vnode: m.Vnode<AlbumShareButtonAttrs>) {\n      const { url, name } = vnode.attrs;\n\n      return m(\"button.photo-share-button\", {\n        disabled: !navigator.share,\n        onclick: shareAlbum.bind(null, localState, url, name),\n      }, buttonText(localState));\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { navigate } from \"../commons/events.ts\";\n\n/*\n * Links back to the albums page\n */\nexport function AlbumsButton() {\n  return {\n    view() {\n      return m(\n        \"a\",\n        { href: \"/albums\", onclick: navigate(`/albums`) },\n        \"[albums]\",\n      );\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Photo as PhotoType } from \"../types.ts\";\nimport { Photo } from \"../components/photo.ts\";\nimport { loadingMode } from \"../services/photos.ts\";\n\n/* */\nfunction PhotosList() {\n  return {\n    view(vnode: m.Vnode<PhotosPageAttrs>) {\n      const { photos } = vnode.attrs;\n\n      // TODO: load photos lazily\n      return m(\n        \"section.photo-container\",\n        photos.map((photo, idx) => {\n          const loading = loadingMode(idx);\n\n          return m(Photo, {\n            key: `photo-${photo.id}`,\n            photo,\n            loading,\n            interactive: true,\n          });\n        }),\n      );\n    },\n  };\n}\n\ntype PhotosPageAttrs = {\n  photos: PhotoType[];\n};\n\n/* */\nexport function PhotosPage() {\n  return {\n    view(vnode: m.Vnode<PhotosPageAttrs>) {\n      const { photos } = vnode.attrs;\n\n      const countText = `${photos.length} photo${\n        photos.length === 1 ? \"\" : \"s\"\n      }`;\n\n      const $md = m(\"section.photos-metadata\", [\n        m(\"h1\", \"Photos\"),\n        m(\"p.photo-album-count\", countText),\n      ]);\n\n      return m(\"div.page\", [$md, m(PhotosList, { photos })]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { Photo } from \"../components/photo.ts\";\nimport type { Photo as PhotoType, Services } from \"../types.ts\";\nimport { AlbumButton } from \"../components/album-button.ts\";\nimport { ExifData } from \"../components/exif-data.ts\";\nimport { PhotoInfo } from \"../components/photo-info.ts\";\n\ntype PhotoPageAttrs = {\n  photo: PhotoType;\n  services: Services;\n};\n\n/* */\nexport function PhotoPage() {\n  return {\n    view(vnode: m.Vnode<PhotoPageAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      // TODO this should be a ul\n      const $links = m(\"li.link-list\", [\n        m(\"a\", { href: photo.fullImage, rel: \"noreferrer\" }, \"[webp]\"),\n        \" \",\n        m(\"a\", { href: photo.pngUrl, rel: \"noreferrer\" }, \"[png]\"),\n        \" \",\n        // [share]\n        m(AlbumButton, { id: photo.albumId }),\n      ]);\n\n      const $exif = m(ExifData, { photo, services });\n      const $photoInfo = m(PhotoInfo, { photo, services });\n\n      return m(\"section\", [\n        m(\"h1\", \"Photo\"),\n        m(Photo, {\n          photo,\n          loading: \"eager\",\n          interactive: false,\n        }),\n        $links,\n        m(\n          \"div.page\",\n          m(\"h3\", \"Photo Information\"),\n          $photoInfo,\n          m(\"h3\", \"Exif Data\"),\n          $exif,\n        ),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { navigate } from \"../commons/events.ts\";\n\ntype AlbumButtonAttrs = {\n  id: string;\n};\n\n/*\n * Links back to the last album page\n */\nexport function AlbumButton() {\n  return {\n    view(vnode: m.Vnode<AlbumButtonAttrs>) {\n      const { id } = vnode.attrs;\n\n      return m(\"a\", {\n        href: `#/album/${id}`,\n        onclick: navigate(`/album/${id}`),\n      }, \"[album]\");\n    },\n  };\n}\n", "import m from \"mithril\";\nimport * as Dates from \"../services/dates.ts\";\nimport type { Photo as PhotoType, Services } from \"../types.ts\";\n\ntype ExifDataAttrs = {\n  photo: PhotoType;\n  services: Services;\n};\n\ntype HeadingAttrs = {\n  text: string;\n};\n\n/* */\nfunction Heading() {\n  return {\n    view(vnode: m.Vnode<HeadingAttrs>) {\n      const { text } = vnode.attrs;\n      return m(\"th.exif-heading\", text);\n    },\n  };\n}\n\n/*\n * Display the camera model\n */\nfunction CameraModel() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $model = services.toThingLinks([photo.model]);\n      if ($model.length > 0) {\n        return m(\"td\", $model);\n      }\n\n      return m(\"td\", \"Unknown\");\n    },\n  };\n}\n\n/*\n * Display the image dimensions\n */\nfunction ExifDimensions() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo } = vnode.attrs;\n\n      if (typeof photo.width === \"string\" && typeof photo.height === \"string\") {\n        return m(\"td\", `${photo.width} x ${photo.height}`);\n      }\n\n      return m(\"td\", \"Unknown\");\n    },\n  };\n}\n\n/*\n * Display the lens focal length\n */\nfunction FocalLength() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo } = vnode.attrs;\n      if (photo.focalLength === \"Unknown\") {\n        return m(\"td\", \"Unknown\");\n      } else if (photo.focalLength === \"0\") {\n        return m(\"td\", \"Manual lens\");\n      } else if (!photo.focalLength) {\n        return m(\"td\", \"Unknown\");\n      } else {\n        return m(\"td\", `${photo.focalLength}mm`);\n      }\n    },\n  };\n}\n\n/*\n * Display the shutter speed\n */\nfunction ShutterSpeed() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo } = vnode.attrs;\n      const { exposureTime } = photo;\n\n      if (typeof exposureTime === \"string\") {\n        const parsed = parseFloat(exposureTime);\n        if (isNaN(parsed)) {\n          return m(\"td\", \"Unknown\");\n        } else if (parsed >= 1) {\n          return m(\"td\", `${parsed} s`);\n        } else {\n          return m(\"td\", `1/${Math.round(1 / parsed)} s`);\n        }\n      }\n\n      return m(\"td\", \"Unknown\");\n    },\n  };\n}\n\n/*\n * Display the aperture (f-stop)\n */\nfunction Aperture() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo } = vnode.attrs;\n\n      if (photo.fStop === \"Unknown\") {\n        return m(\"td\", \"Unknown\");\n      } else if (photo.fStop === \"0.0\") {\n        return m(\"td\", \"Manual aperture control\");\n      } else if (!photo.fStop) {\n        return m(\"td\", \"Unknown\");\n      }\n\n      return m(\"td\", `\u0192/${photo.fStop}`);\n    },\n  };\n}\n\nexport function ExifData() {\n  return {\n    view(vnode: m.Vnode<ExifDataAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $dateTime = m(\"tr\", [\n        m(Heading, { text: \"Date-Time\" }),\n        m(\"td\", m(\"time\", Dates.formatCreatedAt(photo.createdAt))),\n      ]);\n\n      const $model = m(\"tr\", [\n        m(Heading, { text: \"Camera Model\" }),\n        m(CameraModel, { photo, services }),\n      ]);\n\n      const $dimensions = m(\"tr\", [\n        m(Heading, { text: \"Dimensions\" }),\n        m(ExifDimensions, { photo, services }),\n      ]);\n\n      const $focalLength = m(\"tr\", [\n        m(Heading, { text: \"Focal Length\" }),\n        m(FocalLength, { photo, services }),\n      ]);\n\n      const $shutterSpeed = m(\"tr\", [\n        m(Heading, { text: \"Shutter Speed\" }),\n        m(ShutterSpeed, { photo, services }),\n      ]);\n\n      const $aperture = m(\"tr\", [\n        m(Heading, { text: \"Aperture\" }),\n        m(Aperture, { photo, services }),\n      ]);\n\n      const $iso = m(\"tr\", [\n        m(Heading, { text: \"ISO\" }),\n        m(\"td\", photo.iso ?? \"Unknown\"),\n      ]);\n\n      return m(\"table.metadata-table\", [\n        $dateTime,\n        $model,\n        $dimensions,\n        $focalLength,\n        $shutterSpeed,\n        $aperture,\n        $iso,\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Photo as PhotoType, Services } from \"../types.ts\";\nimport { arrayify } from \"../commons/arrays.ts\";\nimport { preprocessDescription } from \"../commons/strings.ts\";\n\ntype HeadingAttrs = {\n  text: string;\n};\n\n/* */\nfunction Heading() {\n  return {\n    view(vnode: m.Vnode<HeadingAttrs>) {\n      const { text } = vnode.attrs;\n      return m(\"th.exif-heading\", text);\n    },\n  };\n}\n\ntype PhotoComponentAttrs = {\n  photo: PhotoType;\n  services: Services;\n};\n\n/* */\nfunction Description() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo } = vnode.attrs;\n\n      const html = preprocessDescription(\n        photo.description ?? photo.summary ?? \"\",\n      );\n      if (html) {\n        return m(\"td\", m.trust(html));\n      }\n\n      return m(\"td\", \"\u2014\");\n    },\n  };\n}\n\n/* */\nfunction Location() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $locations = services.toThingLinks(arrayify(photo.location));\n      return m(\"td\", $locations.length > 0 ? $locations : \"\u2014\");\n    },\n  };\n}\n\n/* */\nfunction Rating() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $rating = services.toThingLinks([photo.rating]);\n      return m(\"td\", $rating.length > 0 ? $rating : \"\u2014\");\n    },\n  };\n}\n\n/* */\nfunction Style() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $style = services.toThingLinks([photo.style]);\n      return m(\"td\", $style.length > 0 ? $style : \"\u2014\");\n    },\n  };\n}\n\n/* */\nfunction Subject() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $subject = services.toThingLinks(arrayify(photo.subject));\n      return m(\"td\", $subject.length > 0 ? $subject : \"\u2014\");\n    },\n  };\n}\n\n/* */\nfunction Country() {\n  return {\n    view(vnode: m.Vnode<PhotoComponentAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const $countries = services.toThingLinks(arrayify(photo.country));\n      return m(\"td\", $countries.length > 0 ? $countries : \"\u2014\");\n    },\n  };\n}\n\ntype PhotoInfoAttrs = {\n  photo: PhotoType;\n  services: Services;\n};\n\n/* */\nexport function PhotoInfo() {\n  return {\n    view(vnode: m.Vnode<PhotoInfoAttrs>) {\n      const { photo, services } = vnode.attrs;\n\n      const infoItems = [];\n\n      if (photo.description || photo.summary) {\n        infoItems.push(m(\"tr\", [\n          m(Heading, { text: \"Description\" }),\n          m(Description, { photo, services }),\n        ]));\n      }\n\n      infoItems.push(\n        m(\"tr\", [\n          m(Heading, { text: \"Country\" }),\n          m(Country, { photo, services }),\n        ]),\n        m(\"tr\", [\n          m(Heading, { text: \"Location\" }),\n          m(Location, { photo, services }),\n        ]),\n        m(\"tr\", [\n          m(Heading, { text: \"Rating\" }),\n          m(Rating, { photo, services }),\n        ]),\n        m(\"tr\", [\n          m(Heading, { text: \"Style\" }),\n          m(Style, { photo, services }),\n        ]),\n        m(\"tr\", [\n          m(Heading, { text: \"Subject\" }),\n          m(Subject, { photo, services }),\n        ]),\n      );\n\n      return m(\"table.metadata-table\", infoItems);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { NonListableTypes } from \"../constants.ts\";\nimport { capitalise, pluralise } from \"../commons/strings.ts\";\nimport { asUrn, type TripleObject } from \"@rgrannell1/tribbledb\";\nimport { navigate } from \"../commons/events.ts\";\nimport type { Services } from \"../types.ts\";\nimport { PhotoAlbum } from \"../components/photo-album.ts\";\nimport { encodeBitmapDataURL, loadingMode } from \"../services/photos.ts\";\nimport { one } from \"../commons/arrays.ts\";\nimport { ThingMetadata } from \"../components/thing-metadata.ts\";\n\n/*\n * Draw an album for a single thing\n */\nfunction drawThingAlbum(services: Services, thing: TripleObject, idx: number) {\n  const id = one(thing.id);\n\n  if (!id) {\n    return [];\n  }\n\n  const coverPhoto = services.readThingCover(id);\n  if (!coverPhoto) {\n    return [];\n  }\n\n  const $md = m(ThingMetadata, { thing });\n\n  const { id: thingId, type } = asUrn(id);\n\n  // Placeholder implementation\n  return [m(PhotoAlbum, {\n    imageUrl: coverPhoto.fullImage,\n    thumbnailUrl: coverPhoto.thumbnailUrl,\n    thumbnailDataUrl: encodeBitmapDataURL(coverPhoto?.mosaicColours),\n    loading: loadingMode(idx),\n    trip: undefined,\n    child: $md,\n    onclick: navigate(`/thing/${type}:${thingId}`),\n  })];\n}\n\n/*\n * Display the component albums and metadata\n * in the listing page\n */\nfunction AlbumsList() {\n  return {\n    view(vnode: m.Vnode<{ services: Services; things: TripleObject[] }>) {\n      const { services, things } = vnode.attrs;\n\n      const $albumComponents = things.flatMap((thing, idx) => {\n        console.log(\"Drawing album for thing:\", thing);\n        return drawThingAlbum(services, thing, idx);\n      });\n\n      return m(\"section.album-container\", $albumComponents);\n    },\n  };\n}\n\n/*\n * Display a pluralised title for the listing page,\n * e.g \"Countries\"\n */\nfunction ListingTitle() {\n  return {\n    view(vnode: m.Vnode<{ type: string }>) {\n      const { type } = vnode.attrs;\n      return m(\n        \"h1.albums-header\",\n        `${capitalise(pluralise(type))}`,\n      );\n    },\n  };\n}\n\n/*\n * Link to the things page for this type (wildcard)\n */\nfunction ListingThingsButton() {\n  return {\n    view(vnode: m.Vnode<{ type: string }>) {\n      const { type } = vnode.attrs;\n      return m(\"a\", {\n        href: `#/thing/${type}:*`,\n        onclick: navigate(`/thing/${type}:*`),\n      }, `See all ${type} photos`);\n    },\n  };\n}\n\ntype ListingPageAttrs = {\n  type: string;\n  things: TripleObject[];\n  services: Services;\n};\n\n/*\n * Render the listing page. It shows\n * each member of a category (e.g countries)\n */\nexport function ListingPage() {\n  return {\n    view(vnode: m.Vnode<ListingPageAttrs>) {\n      const { type, things, services } = vnode.attrs;\n\n      const $md = [\n        m(ListingTitle, { type }),\n      ];\n\n      if (!NonListableTypes.has(type)) {\n        $md.push(\n          m(\"section.album-metadata\", [\n            m(ListingThingsButton, { type }),\n          ]),\n        );\n      }\n\n      return m(\"div.page\", [\n        m(\"section.album-metadata\", $md),\n        m(AlbumsList, { services, things }),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { asUrn, type TripleObject } from \"@rgrannell1/tribbledb\";\nimport { one } from \"../commons/arrays.ts\";\nimport { KnownTypes } from \"../constants.ts\";\nimport { countryEmoji } from \"../services/emoji.ts\";\nimport { ThingUrls } from \"./thing-urls.ts\";\n\nexport function ThingMetadata() {\n  // excluding birds\n  const animals = new Set([\n    KnownTypes.AMPHIBIAN,\n    KnownTypes.REPTILE,\n    KnownTypes.INSECT,\n    KnownTypes.FISH,\n    KnownTypes.MAMMAL,\n  ]);\n\n  return {\n    view(vnode: m.Vnode<{ thing: TripleObject }>) {\n      const { thing } = vnode.attrs;\n      const { type } = asUrn(one(thing.id) as string);\n\n      const $links = m(ThingUrls, { things: [thing] });\n      const title = type === KnownTypes.COUNTRY\n        ? `${countryEmoji(thing)} ${one(thing.name)}`\n        : one(thing.name);\n\n      return m(\"div.photo-album-metadata\", [\n        m(\"p.photo-album-title\", title),\n        $links,\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { TripleObject } from \"@rgrannell1/tribbledb\";\nimport { one } from \"../commons/arrays.ts\";\nimport { ExternalLink } from \"./external-link.ts\";\n\n/*\n * Links to external sites about the thing\n */\nexport function ThingUrls() {\n  return {\n    view(vnode: m.Vnode<{ things: TripleObject[] }>) {\n      const { things } = vnode.attrs;\n\n      if (things.length !== 1) {\n        return m(\"ul\");\n      }\n\n      const [thing] = things;\n      const $links = [];\n\n      const wikipedia = one(thing.wikipedia);\n      if (wikipedia) {\n        $links.push(\n          m(\"li\", m(ExternalLink, { href: wikipedia, text: \"[wikipedia]\" })),\n        );\n      }\n\n      const birdwatch = one(thing.birdwatchUrl);\n      if (birdwatch) {\n        $links.push(\n          m(\"li\", m(ExternalLink, { href: birdwatch, text: \"[birdwatch]\" })),\n        );\n      }\n\n      // -- add google maps URL\n      return m(\"ul.link-list\", $links);\n    },\n  };\n}\n", "import m from \"mithril\";\n\nexport function ExternalLink() {\n  return {\n    view(vnode: m.Vnode<{ href: string; text: string }>) {\n      const { href, text } = vnode.attrs;\n      return m(\"a\", {\n        href,\n        target: \"_blank\",\n        rel: \"noopener\",\n      }, text);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { navigate } from \"../commons/events.ts\";\n\ntype ListingItemAttrs = {\n  name: string;\n  route: string;\n};\n\nfunction ListingItem() {\n  return {\n    view(vnode: m.Vnode<ListingItemAttrs>) {\n      return m(\n        \"li\",\n        m(\"a\", {\n          class: \"listing-item\",\n          onclick: navigate(vnode.attrs.route),\n        }, vnode.attrs.name),\n      );\n    },\n  };\n}\n\nexport function ListingsPage() {\n  return {\n    view() {\n      return m(\"div.page\", [\n        m(\"h1\", \"Listings\"),\n        m(\n          \"section\",\n          m(\"ul\", [\n            m(ListingItem, { route: \"/listing/place\", name: \"Places\" }),\n            m(ListingItem, { route: \"/listing/country\", name: \"Countries\" }),\n            m(ListingItem, { route: \"/listing/bird\", name: \"Birds\" }),\n            m(ListingItem, { route: \"/listing/mammal\", name: \"Mammals\" }),\n            m(ListingItem, { route: \"/listing/reptile\", name: \"Reptiles\" }),\n            m(ListingItem, { route: \"/listing/amphibian\", name: \"Amphibians\" }),\n            m(ListingItem, { route: \"/listing/insect\", name: \"Insects\" }),\n          ]),\n        ),\n      ]);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { ThingSubtitle, ThingTitle } from \"../components/thing-title.ts\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport type { TripleObject } from \"@rgrannell1/tribbledb\";\nimport { arrayify } from \"../commons/arrays.ts\";\nimport type { Services } from \"../types.ts\";\nimport { CountryLink } from \"../components/place-links.ts\";\nimport { Photo } from \"../components/photo.ts\";\nimport { encodeBitmapDataURL } from \"../services/photos.ts\";\nimport { PhotoAlbumMetadata } from \"../components/photo-album-metadata.ts\";\nimport { PhotoAlbum } from \"../components/photo-album.ts\";\nimport { block, broadcast } from \"../commons/events.ts\";\nimport { PlacesList } from \"../components/places-list.ts\";\nimport { setify, setOf } from \"../commons/sets.ts\";\nimport { KnownRelations } from \"../constants.ts\";\nimport { ListingLink } from \"../components/listing-link.ts\";\nimport { FeaturesList } from \"../components/features-list.ts\";\nimport { UnescoList } from \"../components/unesco-list.ts\";\nimport { loadingMode } from \"../services/photos.ts\";\nimport { ThingUrls } from \"../components/thing-urls.ts\";\n\ntype ThingPageAttrs = {\n  urn: string;\n  things: TripleObject[];\n  services: Services;\n};\n\nfunction _ThingPlaces() {\n  return {\n    view() {\n    },\n  };\n}\n\nfunction _ThingTypeLink() {\n  return {\n    view() {\n    },\n  };\n}\n\nfunction ThingMetadata() {\n  return {\n    view(vnode: m.Vnode<ThingPageAttrs>) {\n      const metadata: Record<string, m.Children> = {};\n      const { urn, things, services } = vnode.attrs;\n\n      metadata.Classification = m(ListingLink, { urn });\n\n      const locatedIn = setOf<string>(KnownRelations.IN, things);\n\n      if (locatedIn.size > 0) {\n        metadata[\"Located In\"] = m(PlacesList, { services, urns: locatedIn });\n      }\n\n      if (things.length !== 1) {\n        return;\n      }\n\n      const [thing] = things;\n      // The non-wildcard case\n\n      if (thing.features) {\n        metadata[\"Place Type\"] = m(FeaturesList, {\n          urns: setify(thing.features),\n          services,\n        });\n      }\n\n      if (thing.contains) {\n        metadata[\"Contains\"] = m(PlacesList, {\n          services,\n          urns: setify(thing.contains),\n        });\n      }\n\n      if (thing.unescoId) {\n        metadata[\"UNESCO\"] = m(UnescoList, {\n          urns: new Set(arrayify(thing.unescoId)),\n          services,\n        });\n      }\n\n      // TODO add `seen in`, first photographed\n\n      // convert the metadaTa to a table\n\n      const $rows = Object.entries(metadata).map(([key, value]) => {\n        return m(\"tr\", [\n          m(\"th.exif-heading\", key),\n          m(\"td\", value),\n        ]);\n      });\n\n      return m(\"div\", [\n        m(\"h3\", \"Details\"),\n        m(\"table.metadata-table\", $rows),\n      ]);\n    },\n  };\n}\n\nfunction onAlbumClick(id: string, title: string, event: Event) {\n  const parsed = asUrn(id);\n\n  broadcast(\"navigate\", { route: `/album/${parsed.id}`, title });\n  block(event);\n}\n\nfunction AlbumSection() {\n  return {\n    view(vnode: m.Vnode<ThingPageAttrs>) {\n      const { things, services } = vnode.attrs;\n\n      const urns = setOf<string>(\"id\", things);\n      const albums = services.readAlbumsByThingIds(new Set(urns));\n\n      const countries = services.readCountries(\n        setOf<string>(\"country\", albums as any),\n      );\n\n      const $albums = albums.map((album) => {\n        // duplicated model. move to render(model) code\n        const $countryLinks = [...countries].map((country) => {\n          return m(CountryLink, {\n            country,\n            key: `album-country-${album.id}-${country.id}`,\n            mode: \"flag\",\n          });\n        });\n\n        const $md = m(PhotoAlbumMetadata, {\n          title: album.name,\n          minDate: album.minDate,\n          maxDate: album.maxDate,\n          count: album.photosCount,\n          countryLinks: $countryLinks,\n        });\n\n        const $album = m(PhotoAlbum, {\n          imageUrl: album.thumbnailUrl,\n          thumbnailUrl: album.thumbnailUrl,\n          thumbnailDataUrl: encodeBitmapDataURL(album.mosaic),\n          loading: \"lazy\",\n          minDate: album.minDate,\n          onclick: onAlbumClick.bind(null, album.id, album.name),\n          trip: undefined,\n          child: m(\"p\"),\n        });\n\n        return m(\n          \"div\",\n          $album,\n          $md,\n        );\n      });\n\n      return m(\n        \"section.album-container\",\n        $albums,\n      );\n    },\n  };\n}\n\nfunction PhotoSection() {\n  return {\n    view(vnode: m.Vnode<ThingPageAttrs>) {\n      const { things, services } = vnode.attrs;\n\n      const urns = setOf<string>(\"id\", things);\n      const photos = services.readPhotosByThingIds(urns);\n\n      return m(\n        \"section.photo-container\",\n        photos.map((photo, idx) => {\n          const loading = loadingMode(idx);\n\n          return m(Photo, {\n            key: `photo-${photo.id}`,\n            photo,\n            loading,\n            interactive: true,\n          });\n        }),\n      );\n    },\n  };\n}\n\nexport function ThingPage() {\n  return {\n    view(vnode: m.Vnode<ThingPageAttrs>) {\n      const { urn, things, services } = vnode.attrs;\n\n      return m(\"div.page\", [\n        m(\"section.thing-page\", [\n          m(ThingTitle, { urn, things }),\n          m(ThingSubtitle, { urn }),\n          m(\"br\"),\n          m(ThingUrls, { things }),\n          m(ThingMetadata, { urn, things, services }),\n          m(\"h3\", \"Photos\"),\n          m(PhotoSection, { urn, things, services }),\n          m(\"h3\", \"Albums\"),\n          m(AlbumSection, { urn, things, services }),\n        ]),\n      ]);\n    },\n  };\n}\n", "import { asUrn, parseUrn } from \"@rgrannell1/tribbledb\";\nimport type { TripleObject } from \"@rgrannell1/tribbledb\";\nimport m from \"mithril\";\nimport { binomial, capitalise, pluralise } from \"../commons/strings.ts\";\nimport { BinomialTypes, KnownTypes } from \"../constants.ts\";\nimport { one } from \"../commons/arrays.ts\";\nimport { countryEmoji, placeEmoji } from \"../services/emoji.ts\";\nimport { setTitle } from \"../services/window.ts\";\n\nfunction computeTitle(urn: string, things: TripleObject[]): string {\n  const parsed = parseUrn(urn);\n\n  // if type:*, fall back to pretty render of type information\n  if (parsed.id === \"*\") {\n    return capitalise(pluralise(parsed.type));\n  }\n\n  if (things.length === 0) {\n    return urn;\n  }\n\n  const [thing] = things;\n  const name = one(thing.name) ?? parsed.id;\n\n  if (parsed.type === KnownTypes.COUNTRY) {\n    return `${countryEmoji(thing)} ${name}`;\n  } else if (parsed.type === KnownTypes.PLACE) {\n    return `${placeEmoji(thing)} ${name}`;\n  }\n\n  return name;\n}\n\ntype ThingTitleAttrs = {\n  urn: string;\n  things: TripleObject[];\n};\n\nexport function ThingTitle() {\n  return {\n    view(vnode: m.Vnode<ThingTitleAttrs>) {\n      const { urn, things } = vnode.attrs;\n      const title = computeTitle(urn, things);\n\n      setTitle(title);\n\n      return m(\"h1\", title);\n    },\n  };\n}\n\nexport function ThingSubtitle() {\n  return {\n    view(vnode: m.Vnode<{ urn: string }>) {\n      const parsed = asUrn(vnode.attrs.urn);\n\n      return BinomialTypes.has(parsed.type) && parsed.id !== \"*\"\n        ? m(\n          \"span\",\n          { class: `thing-binomial ${parsed.type}-binomial` },\n          binomial(parsed.id),\n        )\n        : m(\"span\");\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { one } from \"../commons/arrays.ts\";\nimport type { Services } from \"../types.ts\";\nimport { ThingLink } from \"./thing-link.ts\";\n\ntype PlacesListAttrs = {\n  urns: Set<string>;\n  services: Services;\n};\n\nexport function PlacesList() {\n  return {\n    view(vnode: m.Vnode<PlacesListAttrs>) {\n      const { urns, services } = vnode.attrs;\n      const locations = services.readLocations(urns).sort(\n        (loca, locb) => {\n          return (one(loca.name) ?? \"\").localeCompare(one(locb.name) ?? \"\");\n        },\n      );\n\n      const $places = locations.map((location) => {\n        const $link = m(ThingLink, {\n          urn: one(location.id)!,\n          thing: location,\n        });\n        return m(\"li\", { key: `place-${location.id}` }, $link);\n      });\n\n      return m(\"ul\", $places);\n    },\n  };\n}\n", "import { asUrn } from \"@rgrannell1/tribbledb\";\nimport m from \"mithril\";\nimport { capitalise } from \"../commons/strings.ts\";\nimport { block, broadcast } from \"../commons/events.ts\";\n\nfunction onListingClick(type: string, event: Event) {\n  broadcast(\"navigate\", {\n    route: `/listing/${type}`,\n  });\n  block(event);\n}\n\ntype ListingLinkAttrs = { urn: string } | { type: string };\n\nexport function ListingLink() {\n  return {\n    view(vnode: m.Vnode<ListingLinkAttrs>) {\n      let type = \"\";\n      if (\"type\" in vnode.attrs) {\n        type = vnode.attrs.type;\n      } else {\n        const parsed = asUrn(vnode.attrs.urn);\n        type = parsed.type;\n      }\n\n      return m(\"a\", {\n        href: `#/listing/${type}`,\n        onclick: onListingClick.bind(null, type),\n      }, capitalise(type));\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Services } from \"../types.ts\";\nimport { one } from \"../commons/arrays.ts\";\nimport { FeatureLink } from \"./feature-link.ts\";\n\ntype FeaturesListAttrs = {\n  urns: Set<string>;\n  services: Services;\n};\n\n/*\n * A list of place features. For the moment, things-links cannot be used\n */\nexport function FeaturesList() {\n  return {\n    view(vnode: m.Vnode<FeaturesListAttrs>) {\n      const { urns, services } = vnode.attrs;\n      const features = services.readFeatures(urns);\n\n      const $features = features.map((feature) => {\n        const id = one(feature.id)!;\n\n        return m(\"li\", {\n          key: `feature-${id}`,\n        }, m(FeatureLink, { urn: id, thing: feature }));\n      });\n\n      return m(\"ul\", $features);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\n\nimport { one } from \"../commons/arrays.ts\";\nimport { thingEmoji } from \"../services/emoji.ts\";\n\nexport type FeatureLinkAttrs = {\n  urn: string;\n  thing: any;\n};\n\n/*\n * Ideally, we'll extend the `thing` system to support more complex queries, which would\n * be needed here. The query would be \"show all photos / videos\" where the place has feature X, which\n * is more complex than the current system of \"show all photos / videos\" where the place is Y.\n */\nexport function FeatureLink() {\n  return {\n    view(vnode: m.Vnode<FeatureLinkAttrs>) {\n      const { urn, thing } = vnode.attrs;\n      const { type, id } = asUrn(urn);\n\n      const name = one(thing.name) ?? id;\n      const emoji = thingEmoji(urn, name, thing);\n      const text = `${emoji}\\t${name}`;\n\n      return m(\"p\", {\n        class: [\"thing-link\", `${type}-link`].join(\" \"),\n      }, text);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport type { Services } from \"../types.ts\";\nimport { UnescoLink } from \"./unesco-link.ts\";\nimport { one } from \"../commons/arrays.ts\";\n\ntype UnescoListAttrs = {\n  urns: Set<string>;\n  services: Services;\n};\n\nexport function UnescoList() {\n  return {\n    view(vnode: m.Vnode<UnescoListAttrs>) {\n      const { urns, services } = vnode.attrs;\n\n      const unescos = services.readUnescos(urns);\n      const $unescos = unescos.map((unesco) => {\n        const urn = one(unesco.id)!;\n\n        return m(\"li\", m(UnescoLink, { urn, thing: unesco }));\n      });\n\n      return m(\"ul\", $unescos);\n    },\n  };\n}\n", "import m from \"mithril\";\nimport { asUrn } from \"@rgrannell1/tribbledb\";\nimport { one } from \"../commons/arrays.ts\";\n\nexport type UnescoLinkAttrs = {\n  urn: string;\n  thing: any;\n};\n\n/* */\nexport function UnescoLink() {\n  return {\n    view(vnode: m.Vnode<UnescoLinkAttrs>) {\n      const { urn, thing } = vnode.attrs;\n      const { type, id } = asUrn(urn);\n\n      const name = one(thing.name) ?? id;\n\n      return m(\"a\", {\n        href: `https://whc.unesco.org/en/list/${id}`,\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        class: [\"thing-link\", `${type}-link`].join(\" \"),\n      }, name);\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["object", "state", "require_hyperscript", "v", "require_render", "console", "require_mount_redraw", "object", "key", "require_build", "m", "url", "promise", "require_request", "string", "require_parse", "url", "m", "m", "route", "state", "m", "import_mithril", "import_mithril", "m", "url", "binomial", "tdb", "triple", "triples", "import_mithril", "import_mithril", "m", "tdb", "m", "object", "tdb", "tdb", "location", "tdb", "tdb", "tdb", "import_mithril", "m", "import_mithril", "import_mithril", "m", "import_mithril", "dateRange", "m", "import_mithril", "import_mithril", "import_mithril", "m", "url", "m", "m", "import_mithril", "m", "state", "m", "import_mithril", "m", "import_mithril", "import_mithril", "m", "m", "tdb", "import_mithril", "import_mithril", "state", "url", "m", "import_mithril", "m", "dateRange", "country", "m", "import_mithril", "m", "import_mithril", "import_mithril", "m", "import_mithril", "m", "import_mithril", "Heading", "m", "m", "import_mithril", "import_mithril", "import_mithril", "import_mithril", "m", "m", "m", "m", "AlbumsList", "import_mithril", "m", "import_mithril", "import_mithril", "m", "import_mithril", "location", "m", "import_mithril", "m", "import_mithril", "import_mithril", "m", "m", "import_mithril", "import_mithril", "m", "m", "ThingMetadata", "m", "onAlbumClick", "m", "m"]
}
